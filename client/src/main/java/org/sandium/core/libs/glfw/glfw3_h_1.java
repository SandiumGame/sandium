// Generated by jextract

package org.sandium.core.libs.glfw;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class glfw3_h_1 extends glfw3_h_2 {

    glfw3_h_1() {
        // Should not be called directly
    }
    private static final int VK_COARSE_SAMPLE_ORDER_TYPE_RANGE_SIZE_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkCoarseSampleOrderTypeNV.VK_COARSE_SAMPLE_ORDER_TYPE_RANGE_SIZE_NV = 4
     * }
     */
    public static int VK_COARSE_SAMPLE_ORDER_TYPE_RANGE_SIZE_NV() {
        return VK_COARSE_SAMPLE_ORDER_TYPE_RANGE_SIZE_NV;
    }
    private static final int VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCoarseSampleOrderTypeNV.VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV() {
        return VK_COARSE_SAMPLE_ORDER_TYPE_MAX_ENUM_NV;
    }

    private static class vkCmdBindShadingRateImageNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdBindShadingRateImageNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
     * }
     */
    public static FunctionDescriptor vkCmdBindShadingRateImageNV$descriptor() {
        return vkCmdBindShadingRateImageNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
     * }
     */
    public static MethodHandle vkCmdBindShadingRateImageNV$handle() {
        return vkCmdBindShadingRateImageNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
     * }
     */
    public static MemorySegment vkCmdBindShadingRateImageNV$address() {
        return vkCmdBindShadingRateImageNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
     * }
     */
    public static void vkCmdBindShadingRateImageNV(MemorySegment commandBuffer, MemorySegment imageView, int imageLayout) {
        var mh$ = vkCmdBindShadingRateImageNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindShadingRateImageNV", commandBuffer, imageView, imageLayout);
            }
            mh$.invokeExact(commandBuffer, imageView, imageLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetViewportShadingRatePaletteNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdSetViewportShadingRatePaletteNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes)
     * }
     */
    public static FunctionDescriptor vkCmdSetViewportShadingRatePaletteNV$descriptor() {
        return vkCmdSetViewportShadingRatePaletteNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes)
     * }
     */
    public static MethodHandle vkCmdSetViewportShadingRatePaletteNV$handle() {
        return vkCmdSetViewportShadingRatePaletteNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes)
     * }
     */
    public static MemorySegment vkCmdSetViewportShadingRatePaletteNV$address() {
        return vkCmdSetViewportShadingRatePaletteNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes)
     * }
     */
    public static void vkCmdSetViewportShadingRatePaletteNV(MemorySegment commandBuffer, int firstViewport, int viewportCount, MemorySegment pShadingRatePalettes) {
        var mh$ = vkCmdSetViewportShadingRatePaletteNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetViewportShadingRatePaletteNV", commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
            }
            mh$.invokeExact(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetCoarseSampleOrderNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdSetCoarseSampleOrderNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders)
     * }
     */
    public static FunctionDescriptor vkCmdSetCoarseSampleOrderNV$descriptor() {
        return vkCmdSetCoarseSampleOrderNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders)
     * }
     */
    public static MethodHandle vkCmdSetCoarseSampleOrderNV$handle() {
        return vkCmdSetCoarseSampleOrderNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders)
     * }
     */
    public static MemorySegment vkCmdSetCoarseSampleOrderNV$address() {
        return vkCmdSetCoarseSampleOrderNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders)
     * }
     */
    public static void vkCmdSetCoarseSampleOrderNV(MemorySegment commandBuffer, int sampleOrderType, int customSampleOrderCount, MemorySegment pCustomSampleOrders) {
        var mh$ = vkCmdSetCoarseSampleOrderNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetCoarseSampleOrderNV", commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
            }
            mh$.invokeExact(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkAccelerationStructureNV_T *VkAccelerationStructureNV
     * }
     */
    public static final AddressLayout VkAccelerationStructureNV = glfw3_h.C_POINTER;
    private static final int VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureTypeNV.VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV = 0
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV() {
        return VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureTypeNV.VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV = 1
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV() {
        return VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_TYPE_BEGIN_RANGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureTypeNV.VK_ACCELERATION_STRUCTURE_TYPE_BEGIN_RANGE_NV = 0
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_TYPE_BEGIN_RANGE_NV() {
        return VK_ACCELERATION_STRUCTURE_TYPE_BEGIN_RANGE_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_TYPE_END_RANGE_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureTypeNV.VK_ACCELERATION_STRUCTURE_TYPE_END_RANGE_NV = 1
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_TYPE_END_RANGE_NV() {
        return VK_ACCELERATION_STRUCTURE_TYPE_END_RANGE_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_TYPE_RANGE_SIZE_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureTypeNV.VK_ACCELERATION_STRUCTURE_TYPE_RANGE_SIZE_NV = 2
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_TYPE_RANGE_SIZE_NV() {
        return VK_ACCELERATION_STRUCTURE_TYPE_RANGE_SIZE_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureTypeNV.VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV() {
        return VK_ACCELERATION_STRUCTURE_TYPE_MAX_ENUM_NV;
    }
    private static final int VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingShaderGroupTypeNV.VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV = 0
     * }
     */
    public static int VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV() {
        return VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV;
    }
    private static final int VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingShaderGroupTypeNV.VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV = 1
     * }
     */
    public static int VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV() {
        return VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV;
    }
    private static final int VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingShaderGroupTypeNV.VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV = 2
     * }
     */
    public static int VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV() {
        return VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV;
    }
    private static final int VK_RAY_TRACING_SHADER_GROUP_TYPE_BEGIN_RANGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingShaderGroupTypeNV.VK_RAY_TRACING_SHADER_GROUP_TYPE_BEGIN_RANGE_NV = 0
     * }
     */
    public static int VK_RAY_TRACING_SHADER_GROUP_TYPE_BEGIN_RANGE_NV() {
        return VK_RAY_TRACING_SHADER_GROUP_TYPE_BEGIN_RANGE_NV;
    }
    private static final int VK_RAY_TRACING_SHADER_GROUP_TYPE_END_RANGE_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingShaderGroupTypeNV.VK_RAY_TRACING_SHADER_GROUP_TYPE_END_RANGE_NV = 2
     * }
     */
    public static int VK_RAY_TRACING_SHADER_GROUP_TYPE_END_RANGE_NV() {
        return VK_RAY_TRACING_SHADER_GROUP_TYPE_END_RANGE_NV;
    }
    private static final int VK_RAY_TRACING_SHADER_GROUP_TYPE_RANGE_SIZE_NV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingShaderGroupTypeNV.VK_RAY_TRACING_SHADER_GROUP_TYPE_RANGE_SIZE_NV = 3
     * }
     */
    public static int VK_RAY_TRACING_SHADER_GROUP_TYPE_RANGE_SIZE_NV() {
        return VK_RAY_TRACING_SHADER_GROUP_TYPE_RANGE_SIZE_NV;
    }
    private static final int VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkRayTracingShaderGroupTypeNV.VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_NV() {
        return VK_RAY_TRACING_SHADER_GROUP_TYPE_MAX_ENUM_NV;
    }
    private static final int VK_GEOMETRY_TYPE_TRIANGLES_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryTypeNV.VK_GEOMETRY_TYPE_TRIANGLES_NV = 0
     * }
     */
    public static int VK_GEOMETRY_TYPE_TRIANGLES_NV() {
        return VK_GEOMETRY_TYPE_TRIANGLES_NV;
    }
    private static final int VK_GEOMETRY_TYPE_AABBS_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryTypeNV.VK_GEOMETRY_TYPE_AABBS_NV = 1
     * }
     */
    public static int VK_GEOMETRY_TYPE_AABBS_NV() {
        return VK_GEOMETRY_TYPE_AABBS_NV;
    }
    private static final int VK_GEOMETRY_TYPE_BEGIN_RANGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryTypeNV.VK_GEOMETRY_TYPE_BEGIN_RANGE_NV = 0
     * }
     */
    public static int VK_GEOMETRY_TYPE_BEGIN_RANGE_NV() {
        return VK_GEOMETRY_TYPE_BEGIN_RANGE_NV;
    }
    private static final int VK_GEOMETRY_TYPE_END_RANGE_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryTypeNV.VK_GEOMETRY_TYPE_END_RANGE_NV = 1
     * }
     */
    public static int VK_GEOMETRY_TYPE_END_RANGE_NV() {
        return VK_GEOMETRY_TYPE_END_RANGE_NV;
    }
    private static final int VK_GEOMETRY_TYPE_RANGE_SIZE_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryTypeNV.VK_GEOMETRY_TYPE_RANGE_SIZE_NV = 2
     * }
     */
    public static int VK_GEOMETRY_TYPE_RANGE_SIZE_NV() {
        return VK_GEOMETRY_TYPE_RANGE_SIZE_NV;
    }
    private static final int VK_GEOMETRY_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryTypeNV.VK_GEOMETRY_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_GEOMETRY_TYPE_MAX_ENUM_NV() {
        return VK_GEOMETRY_TYPE_MAX_ENUM_NV;
    }
    private static final int VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkCopyAccelerationStructureModeNV.VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV = 0
     * }
     */
    public static int VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV() {
        return VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV;
    }
    private static final int VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCopyAccelerationStructureModeNV.VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV = 1
     * }
     */
    public static int VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV() {
        return VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV;
    }
    private static final int VK_COPY_ACCELERATION_STRUCTURE_MODE_BEGIN_RANGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkCopyAccelerationStructureModeNV.VK_COPY_ACCELERATION_STRUCTURE_MODE_BEGIN_RANGE_NV = 0
     * }
     */
    public static int VK_COPY_ACCELERATION_STRUCTURE_MODE_BEGIN_RANGE_NV() {
        return VK_COPY_ACCELERATION_STRUCTURE_MODE_BEGIN_RANGE_NV;
    }
    private static final int VK_COPY_ACCELERATION_STRUCTURE_MODE_END_RANGE_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCopyAccelerationStructureModeNV.VK_COPY_ACCELERATION_STRUCTURE_MODE_END_RANGE_NV = 1
     * }
     */
    public static int VK_COPY_ACCELERATION_STRUCTURE_MODE_END_RANGE_NV() {
        return VK_COPY_ACCELERATION_STRUCTURE_MODE_END_RANGE_NV;
    }
    private static final int VK_COPY_ACCELERATION_STRUCTURE_MODE_RANGE_SIZE_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkCopyAccelerationStructureModeNV.VK_COPY_ACCELERATION_STRUCTURE_MODE_RANGE_SIZE_NV = 2
     * }
     */
    public static int VK_COPY_ACCELERATION_STRUCTURE_MODE_RANGE_SIZE_NV() {
        return VK_COPY_ACCELERATION_STRUCTURE_MODE_RANGE_SIZE_NV;
    }
    private static final int VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCopyAccelerationStructureModeNV.VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_NV() {
        return VK_COPY_ACCELERATION_STRUCTURE_MODE_MAX_ENUM_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMemoryRequirementsTypeNV.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV = 0
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV() {
        return VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMemoryRequirementsTypeNV.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV = 1
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV() {
        return VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMemoryRequirementsTypeNV.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV = 2
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV() {
        return VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BEGIN_RANGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMemoryRequirementsTypeNV.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BEGIN_RANGE_NV = 0
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BEGIN_RANGE_NV() {
        return VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BEGIN_RANGE_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_END_RANGE_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMemoryRequirementsTypeNV.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_END_RANGE_NV = 2
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_END_RANGE_NV() {
        return VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_END_RANGE_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_RANGE_SIZE_NV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMemoryRequirementsTypeNV.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_RANGE_SIZE_NV = 3
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_RANGE_SIZE_NV() {
        return VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_RANGE_SIZE_NV;
    }
    private static final int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkAccelerationStructureMemoryRequirementsTypeNV.VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV() {
        return VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_MAX_ENUM_NV;
    }
    private static final int VK_GEOMETRY_OPAQUE_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryFlagBitsNV.VK_GEOMETRY_OPAQUE_BIT_NV = 1
     * }
     */
    public static int VK_GEOMETRY_OPAQUE_BIT_NV() {
        return VK_GEOMETRY_OPAQUE_BIT_NV;
    }
    private static final int VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryFlagBitsNV.VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV = 2
     * }
     */
    public static int VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV() {
        return VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV;
    }
    private static final int VK_GEOMETRY_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryFlagBitsNV.VK_GEOMETRY_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_GEOMETRY_FLAG_BITS_MAX_ENUM_NV() {
        return VK_GEOMETRY_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkGeometryFlagsNV
     * }
     */
    public static final OfInt VkGeometryFlagsNV = glfw3_h.C_INT;
    private static final int VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryInstanceFlagBitsNV.VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV = 1
     * }
     */
    public static int VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV() {
        return VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV;
    }
    private static final int VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryInstanceFlagBitsNV.VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV = 2
     * }
     */
    public static int VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV() {
        return VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV;
    }
    private static final int VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryInstanceFlagBitsNV.VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV = 4
     * }
     */
    public static int VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV() {
        return VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV;
    }
    private static final int VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryInstanceFlagBitsNV.VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV = 8
     * }
     */
    public static int VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV() {
        return VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV;
    }
    private static final int VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkGeometryInstanceFlagBitsNV.VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_GEOMETRY_INSTANCE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkGeometryInstanceFlagsNV
     * }
     */
    public static final OfInt VkGeometryInstanceFlagsNV = glfw3_h.C_INT;
    private static final int VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkBuildAccelerationStructureFlagBitsNV.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV = 1
     * }
     */
    public static int VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV() {
        return VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV;
    }
    private static final int VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkBuildAccelerationStructureFlagBitsNV.VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV = 2
     * }
     */
    public static int VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV() {
        return VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV;
    }
    private static final int VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkBuildAccelerationStructureFlagBitsNV.VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV = 4
     * }
     */
    public static int VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV() {
        return VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV;
    }
    private static final int VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkBuildAccelerationStructureFlagBitsNV.VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV = 8
     * }
     */
    public static int VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV() {
        return VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV;
    }
    private static final int VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkBuildAccelerationStructureFlagBitsNV.VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV = 16
     * }
     */
    public static int VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV() {
        return VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV;
    }
    private static final int VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkBuildAccelerationStructureFlagBitsNV.VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkBuildAccelerationStructureFlagsNV
     * }
     */
    public static final OfInt VkBuildAccelerationStructureFlagsNV = glfw3_h.C_INT;

    private static class vkCreateAccelerationStructureNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCreateAccelerationStructureNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure)
     * }
     */
    public static FunctionDescriptor vkCreateAccelerationStructureNV$descriptor() {
        return vkCreateAccelerationStructureNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure)
     * }
     */
    public static MethodHandle vkCreateAccelerationStructureNV$handle() {
        return vkCreateAccelerationStructureNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure)
     * }
     */
    public static MemorySegment vkCreateAccelerationStructureNV$address() {
        return vkCreateAccelerationStructureNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure)
     * }
     */
    public static int vkCreateAccelerationStructureNV(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pAccelerationStructure) {
        var mh$ = vkCreateAccelerationStructureNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateAccelerationStructureNV", device, pCreateInfo, pAllocator, pAccelerationStructure);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pAccelerationStructure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyAccelerationStructureNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkDestroyAccelerationStructureNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyAccelerationStructureNV$descriptor() {
        return vkDestroyAccelerationStructureNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyAccelerationStructureNV$handle() {
        return vkDestroyAccelerationStructureNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyAccelerationStructureNV$address() {
        return vkDestroyAccelerationStructureNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyAccelerationStructureNV(MemorySegment device, MemorySegment accelerationStructure, MemorySegment pAllocator) {
        var mh$ = vkDestroyAccelerationStructureNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyAccelerationStructureNV", device, accelerationStructure, pAllocator);
            }
            mh$.invokeExact(device, accelerationStructure, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetAccelerationStructureMemoryRequirementsNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetAccelerationStructureMemoryRequirementsNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetAccelerationStructureMemoryRequirementsNV$descriptor() {
        return vkGetAccelerationStructureMemoryRequirementsNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetAccelerationStructureMemoryRequirementsNV$handle() {
        return vkGetAccelerationStructureMemoryRequirementsNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetAccelerationStructureMemoryRequirementsNV$address() {
        return vkGetAccelerationStructureMemoryRequirementsNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements)
     * }
     */
    public static void vkGetAccelerationStructureMemoryRequirementsNV(MemorySegment device, MemorySegment pInfo, MemorySegment pMemoryRequirements) {
        var mh$ = vkGetAccelerationStructureMemoryRequirementsNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetAccelerationStructureMemoryRequirementsNV", device, pInfo, pMemoryRequirements);
            }
            mh$.invokeExact(device, pInfo, pMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBindAccelerationStructureMemoryNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkBindAccelerationStructureMemoryNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos)
     * }
     */
    public static FunctionDescriptor vkBindAccelerationStructureMemoryNV$descriptor() {
        return vkBindAccelerationStructureMemoryNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos)
     * }
     */
    public static MethodHandle vkBindAccelerationStructureMemoryNV$handle() {
        return vkBindAccelerationStructureMemoryNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkBindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos)
     * }
     */
    public static MemorySegment vkBindAccelerationStructureMemoryNV$address() {
        return vkBindAccelerationStructureMemoryNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkBindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos)
     * }
     */
    public static int vkBindAccelerationStructureMemoryNV(MemorySegment device, int bindInfoCount, MemorySegment pBindInfos) {
        var mh$ = vkBindAccelerationStructureMemoryNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBindAccelerationStructureMemoryNV", device, bindInfoCount, pBindInfos);
            }
            return (int)mh$.invokeExact(device, bindInfoCount, pBindInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBuildAccelerationStructureNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdBuildAccelerationStructureNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset)
     * }
     */
    public static FunctionDescriptor vkCmdBuildAccelerationStructureNV$descriptor() {
        return vkCmdBuildAccelerationStructureNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset)
     * }
     */
    public static MethodHandle vkCmdBuildAccelerationStructureNV$handle() {
        return vkCmdBuildAccelerationStructureNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset)
     * }
     */
    public static MemorySegment vkCmdBuildAccelerationStructureNV$address() {
        return vkCmdBuildAccelerationStructureNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset)
     * }
     */
    public static void vkCmdBuildAccelerationStructureNV(MemorySegment commandBuffer, MemorySegment pInfo, MemorySegment instanceData, long instanceOffset, int update, MemorySegment dst, MemorySegment src, MemorySegment scratch, long scratchOffset) {
        var mh$ = vkCmdBuildAccelerationStructureNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBuildAccelerationStructureNV", commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
            }
            mh$.invokeExact(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyAccelerationStructureNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdCopyAccelerationStructureNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeNV mode)
     * }
     */
    public static FunctionDescriptor vkCmdCopyAccelerationStructureNV$descriptor() {
        return vkCmdCopyAccelerationStructureNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeNV mode)
     * }
     */
    public static MethodHandle vkCmdCopyAccelerationStructureNV$handle() {
        return vkCmdCopyAccelerationStructureNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeNV mode)
     * }
     */
    public static MemorySegment vkCmdCopyAccelerationStructureNV$address() {
        return vkCmdCopyAccelerationStructureNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeNV mode)
     * }
     */
    public static void vkCmdCopyAccelerationStructureNV(MemorySegment commandBuffer, MemorySegment dst, MemorySegment src, int mode) {
        var mh$ = vkCmdCopyAccelerationStructureNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyAccelerationStructureNV", commandBuffer, dst, src, mode);
            }
            mh$.invokeExact(commandBuffer, dst, src, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdTraceRaysNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_LONG,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_LONG,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_LONG,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdTraceRaysNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth)
     * }
     */
    public static FunctionDescriptor vkCmdTraceRaysNV$descriptor() {
        return vkCmdTraceRaysNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth)
     * }
     */
    public static MethodHandle vkCmdTraceRaysNV$handle() {
        return vkCmdTraceRaysNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth)
     * }
     */
    public static MemorySegment vkCmdTraceRaysNV$address() {
        return vkCmdTraceRaysNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth)
     * }
     */
    public static void vkCmdTraceRaysNV(MemorySegment commandBuffer, MemorySegment raygenShaderBindingTableBuffer, long raygenShaderBindingOffset, MemorySegment missShaderBindingTableBuffer, long missShaderBindingOffset, long missShaderBindingStride, MemorySegment hitShaderBindingTableBuffer, long hitShaderBindingOffset, long hitShaderBindingStride, MemorySegment callableShaderBindingTableBuffer, long callableShaderBindingOffset, long callableShaderBindingStride, int width, int height, int depth) {
        var mh$ = vkCmdTraceRaysNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdTraceRaysNV", commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
            }
            mh$.invokeExact(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateRayTracingPipelinesNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCreateRayTracingPipelinesNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static FunctionDescriptor vkCreateRayTracingPipelinesNV$descriptor() {
        return vkCreateRayTracingPipelinesNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static MethodHandle vkCreateRayTracingPipelinesNV$handle() {
        return vkCreateRayTracingPipelinesNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static MemorySegment vkCreateRayTracingPipelinesNV$address() {
        return vkCreateRayTracingPipelinesNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static int vkCreateRayTracingPipelinesNV(MemorySegment device, MemorySegment pipelineCache, int createInfoCount, MemorySegment pCreateInfos, MemorySegment pAllocator, MemorySegment pPipelines) {
        var mh$ = vkCreateRayTracingPipelinesNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateRayTracingPipelinesNV", device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
            }
            return (int)mh$.invokeExact(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetRayTracingShaderGroupHandlesNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_LONG,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetRayTracingShaderGroupHandlesNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetRayTracingShaderGroupHandlesNV$descriptor() {
        return vkGetRayTracingShaderGroupHandlesNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData)
     * }
     */
    public static MethodHandle vkGetRayTracingShaderGroupHandlesNV$handle() {
        return vkGetRayTracingShaderGroupHandlesNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData)
     * }
     */
    public static MemorySegment vkGetRayTracingShaderGroupHandlesNV$address() {
        return vkGetRayTracingShaderGroupHandlesNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData)
     * }
     */
    public static int vkGetRayTracingShaderGroupHandlesNV(MemorySegment device, MemorySegment pipeline, int firstGroup, int groupCount, long dataSize, MemorySegment pData) {
        var mh$ = vkGetRayTracingShaderGroupHandlesNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetRayTracingShaderGroupHandlesNV", device, pipeline, firstGroup, groupCount, dataSize, pData);
            }
            return (int)mh$.invokeExact(device, pipeline, firstGroup, groupCount, dataSize, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetAccelerationStructureHandleNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetAccelerationStructureHandleNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetAccelerationStructureHandleNV$descriptor() {
        return vkGetAccelerationStructureHandleNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData)
     * }
     */
    public static MethodHandle vkGetAccelerationStructureHandleNV$handle() {
        return vkGetAccelerationStructureHandleNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData)
     * }
     */
    public static MemorySegment vkGetAccelerationStructureHandleNV$address() {
        return vkGetAccelerationStructureHandleNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData)
     * }
     */
    public static int vkGetAccelerationStructureHandleNV(MemorySegment device, MemorySegment accelerationStructure, long dataSize, MemorySegment pData) {
        var mh$ = vkGetAccelerationStructureHandleNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetAccelerationStructureHandleNV", device, accelerationStructure, dataSize, pData);
            }
            return (int)mh$.invokeExact(device, accelerationStructure, dataSize, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdWriteAccelerationStructuresPropertiesNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdWriteAccelerationStructuresPropertiesNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static FunctionDescriptor vkCmdWriteAccelerationStructuresPropertiesNV$descriptor() {
        return vkCmdWriteAccelerationStructuresPropertiesNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static MethodHandle vkCmdWriteAccelerationStructuresPropertiesNV$handle() {
        return vkCmdWriteAccelerationStructuresPropertiesNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static MemorySegment vkCmdWriteAccelerationStructuresPropertiesNV$address() {
        return vkCmdWriteAccelerationStructuresPropertiesNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
     * }
     */
    public static void vkCmdWriteAccelerationStructuresPropertiesNV(MemorySegment commandBuffer, int accelerationStructureCount, MemorySegment pAccelerationStructures, int queryType, MemorySegment queryPool, int firstQuery) {
        var mh$ = vkCmdWriteAccelerationStructuresPropertiesNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdWriteAccelerationStructuresPropertiesNV", commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
            }
            mh$.invokeExact(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCompileDeferredNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCompileDeferredNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader)
     * }
     */
    public static FunctionDescriptor vkCompileDeferredNV$descriptor() {
        return vkCompileDeferredNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader)
     * }
     */
    public static MethodHandle vkCompileDeferredNV$handle() {
        return vkCompileDeferredNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader)
     * }
     */
    public static MemorySegment vkCompileDeferredNV$address() {
        return vkCompileDeferredNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader)
     * }
     */
    public static int vkCompileDeferredNV(MemorySegment device, MemorySegment pipeline, int shader) {
        var mh$ = vkCompileDeferredNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCompileDeferredNV", device, pipeline, shader);
            }
            return (int)mh$.invokeExact(device, pipeline, shader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128
     * }
     */
    public static int VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT() {
        return VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT;
    }
    private static final int VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256
     * }
     */
    public static int VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT() {
        return VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT;
    }
    private static final int VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = (int)512L;
    /**
     * {@snippet lang=c :
     * enum VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512
     * }
     */
    public static int VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT() {
        return VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT;
    }
    private static final int VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024
     * }
     */
    public static int VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT() {
        return VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT;
    }
    private static final int VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT = 128
     * }
     */
    public static int VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT() {
        return VK_QUEUE_GLOBAL_PRIORITY_BEGIN_RANGE_EXT;
    }
    private static final int VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT = 1024
     * }
     */
    public static int VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT() {
        return VK_QUEUE_GLOBAL_PRIORITY_END_RANGE_EXT;
    }
    private static final int VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT = (int)897L;
    /**
     * {@snippet lang=c :
     * enum VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT = 897
     * }
     */
    public static int VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT() {
        return VK_QUEUE_GLOBAL_PRIORITY_RANGE_SIZE_EXT;
    }
    private static final int VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkQueueGlobalPriorityEXT.VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT() {
        return VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM_EXT;
    }

    private static class vkGetMemoryHostPointerPropertiesEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetMemoryHostPointerPropertiesEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties)
     * }
     */
    public static FunctionDescriptor vkGetMemoryHostPointerPropertiesEXT$descriptor() {
        return vkGetMemoryHostPointerPropertiesEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties)
     * }
     */
    public static MethodHandle vkGetMemoryHostPointerPropertiesEXT$handle() {
        return vkGetMemoryHostPointerPropertiesEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties)
     * }
     */
    public static MemorySegment vkGetMemoryHostPointerPropertiesEXT$address() {
        return vkGetMemoryHostPointerPropertiesEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties)
     * }
     */
    public static int vkGetMemoryHostPointerPropertiesEXT(MemorySegment device, int handleType, MemorySegment pHostPointer, MemorySegment pMemoryHostPointerProperties) {
        var mh$ = vkGetMemoryHostPointerPropertiesEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetMemoryHostPointerPropertiesEXT", device, handleType, pHostPointer, pMemoryHostPointerProperties);
            }
            return (int)mh$.invokeExact(device, handleType, pHostPointer, pMemoryHostPointerProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdWriteBufferMarkerAMD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdWriteBufferMarkerAMD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker)
     * }
     */
    public static FunctionDescriptor vkCmdWriteBufferMarkerAMD$descriptor() {
        return vkCmdWriteBufferMarkerAMD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker)
     * }
     */
    public static MethodHandle vkCmdWriteBufferMarkerAMD$handle() {
        return vkCmdWriteBufferMarkerAMD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker)
     * }
     */
    public static MemorySegment vkCmdWriteBufferMarkerAMD$address() {
        return vkCmdWriteBufferMarkerAMD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker)
     * }
     */
    public static void vkCmdWriteBufferMarkerAMD(MemorySegment commandBuffer, int pipelineStage, MemorySegment dstBuffer, long dstOffset, int marker) {
        var mh$ = vkCmdWriteBufferMarkerAMD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdWriteBufferMarkerAMD", commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
            }
            mh$.invokeExact(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCompilerControlFlagBitsAMD.VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD = 2147483647
     * }
     */
    public static int VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD() {
        return VK_PIPELINE_COMPILER_CONTROL_FLAG_BITS_MAX_ENUM_AMD;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineCompilerControlFlagsAMD
     * }
     */
    public static final OfInt VkPipelineCompilerControlFlagsAMD = glfw3_h.C_INT;
    private static final int VK_TIME_DOMAIN_DEVICE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkTimeDomainEXT.VK_TIME_DOMAIN_DEVICE_EXT = 0
     * }
     */
    public static int VK_TIME_DOMAIN_DEVICE_EXT() {
        return VK_TIME_DOMAIN_DEVICE_EXT;
    }
    private static final int VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkTimeDomainEXT.VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT = 1
     * }
     */
    public static int VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT() {
        return VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT;
    }
    private static final int VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkTimeDomainEXT.VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT = 2
     * }
     */
    public static int VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT() {
        return VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT;
    }
    private static final int VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkTimeDomainEXT.VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT = 3
     * }
     */
    public static int VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT() {
        return VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT;
    }
    private static final int VK_TIME_DOMAIN_BEGIN_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkTimeDomainEXT.VK_TIME_DOMAIN_BEGIN_RANGE_EXT = 0
     * }
     */
    public static int VK_TIME_DOMAIN_BEGIN_RANGE_EXT() {
        return VK_TIME_DOMAIN_BEGIN_RANGE_EXT;
    }
    private static final int VK_TIME_DOMAIN_END_RANGE_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkTimeDomainEXT.VK_TIME_DOMAIN_END_RANGE_EXT = 3
     * }
     */
    public static int VK_TIME_DOMAIN_END_RANGE_EXT() {
        return VK_TIME_DOMAIN_END_RANGE_EXT;
    }
    private static final int VK_TIME_DOMAIN_RANGE_SIZE_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkTimeDomainEXT.VK_TIME_DOMAIN_RANGE_SIZE_EXT = 4
     * }
     */
    public static int VK_TIME_DOMAIN_RANGE_SIZE_EXT() {
        return VK_TIME_DOMAIN_RANGE_SIZE_EXT;
    }
    private static final int VK_TIME_DOMAIN_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkTimeDomainEXT.VK_TIME_DOMAIN_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_TIME_DOMAIN_MAX_ENUM_EXT() {
        return VK_TIME_DOMAIN_MAX_ENUM_EXT;
    }

    private static class vkGetPhysicalDeviceCalibrateableTimeDomainsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainEXT *pTimeDomains)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceCalibrateableTimeDomainsEXT$descriptor() {
        return vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainEXT *pTimeDomains)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceCalibrateableTimeDomainsEXT$handle() {
        return vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainEXT *pTimeDomains)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceCalibrateableTimeDomainsEXT$address() {
        return vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainEXT *pTimeDomains)
     * }
     */
    public static int vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(MemorySegment physicalDevice, MemorySegment pTimeDomainCount, MemorySegment pTimeDomains) {
        var mh$ = vkGetPhysicalDeviceCalibrateableTimeDomainsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", physicalDevice, pTimeDomainCount, pTimeDomains);
            }
            return (int)mh$.invokeExact(physicalDevice, pTimeDomainCount, pTimeDomains);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetCalibratedTimestampsEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetCalibratedTimestampsEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation)
     * }
     */
    public static FunctionDescriptor vkGetCalibratedTimestampsEXT$descriptor() {
        return vkGetCalibratedTimestampsEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation)
     * }
     */
    public static MethodHandle vkGetCalibratedTimestampsEXT$handle() {
        return vkGetCalibratedTimestampsEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation)
     * }
     */
    public static MemorySegment vkGetCalibratedTimestampsEXT$address() {
        return vkGetCalibratedTimestampsEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation)
     * }
     */
    public static int vkGetCalibratedTimestampsEXT(MemorySegment device, int timestampCount, MemorySegment pTimestampInfos, MemorySegment pTimestamps, MemorySegment pMaxDeviation) {
        var mh$ = vkGetCalibratedTimestampsEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetCalibratedTimestampsEXT", device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
            }
            return (int)mh$.invokeExact(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryOverallocationBehaviorAMD.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0
     * }
     */
    public static int VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD() {
        return VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD;
    }
    private static final int VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryOverallocationBehaviorAMD.VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1
     * }
     */
    public static int VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD() {
        return VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD;
    }
    private static final int VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryOverallocationBehaviorAMD.VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2
     * }
     */
    public static int VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD() {
        return VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD;
    }
    private static final int VK_MEMORY_OVERALLOCATION_BEHAVIOR_BEGIN_RANGE_AMD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryOverallocationBehaviorAMD.VK_MEMORY_OVERALLOCATION_BEHAVIOR_BEGIN_RANGE_AMD = 0
     * }
     */
    public static int VK_MEMORY_OVERALLOCATION_BEHAVIOR_BEGIN_RANGE_AMD() {
        return VK_MEMORY_OVERALLOCATION_BEHAVIOR_BEGIN_RANGE_AMD;
    }
    private static final int VK_MEMORY_OVERALLOCATION_BEHAVIOR_END_RANGE_AMD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryOverallocationBehaviorAMD.VK_MEMORY_OVERALLOCATION_BEHAVIOR_END_RANGE_AMD = 2
     * }
     */
    public static int VK_MEMORY_OVERALLOCATION_BEHAVIOR_END_RANGE_AMD() {
        return VK_MEMORY_OVERALLOCATION_BEHAVIOR_END_RANGE_AMD;
    }
    private static final int VK_MEMORY_OVERALLOCATION_BEHAVIOR_RANGE_SIZE_AMD = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryOverallocationBehaviorAMD.VK_MEMORY_OVERALLOCATION_BEHAVIOR_RANGE_SIZE_AMD = 3
     * }
     */
    public static int VK_MEMORY_OVERALLOCATION_BEHAVIOR_RANGE_SIZE_AMD() {
        return VK_MEMORY_OVERALLOCATION_BEHAVIOR_RANGE_SIZE_AMD;
    }
    private static final int VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryOverallocationBehaviorAMD.VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD = 2147483647
     * }
     */
    public static int VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD() {
        return VK_MEMORY_OVERALLOCATION_BEHAVIOR_MAX_ENUM_AMD;
    }
    private static final int VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreationFeedbackFlagBitsEXT.VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT = 1
     * }
     */
    public static int VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT() {
        return VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT;
    }
    private static final int VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreationFeedbackFlagBitsEXT.VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT = 2
     * }
     */
    public static int VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT() {
        return VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT;
    }
    private static final int VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreationFeedbackFlagBitsEXT.VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT = 4
     * }
     */
    public static int VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT() {
        return VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT;
    }
    private static final int VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreationFeedbackFlagBitsEXT.VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineCreationFeedbackFlagsEXT
     * }
     */
    public static final OfInt VkPipelineCreationFeedbackFlagsEXT = glfw3_h.C_INT;

    private static class vkCmdDrawMeshTasksNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdDrawMeshTasksNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask)
     * }
     */
    public static FunctionDescriptor vkCmdDrawMeshTasksNV$descriptor() {
        return vkCmdDrawMeshTasksNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask)
     * }
     */
    public static MethodHandle vkCmdDrawMeshTasksNV$handle() {
        return vkCmdDrawMeshTasksNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask)
     * }
     */
    public static MemorySegment vkCmdDrawMeshTasksNV$address() {
        return vkCmdDrawMeshTasksNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask)
     * }
     */
    public static void vkCmdDrawMeshTasksNV(MemorySegment commandBuffer, int taskCount, int firstTask) {
        var mh$ = vkCmdDrawMeshTasksNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawMeshTasksNV", commandBuffer, taskCount, firstTask);
            }
            mh$.invokeExact(commandBuffer, taskCount, firstTask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawMeshTasksIndirectNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdDrawMeshTasksIndirectNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawMeshTasksIndirectNV$descriptor() {
        return vkCmdDrawMeshTasksIndirectNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawMeshTasksIndirectNV$handle() {
        return vkCmdDrawMeshTasksIndirectNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawMeshTasksIndirectNV$address() {
        return vkCmdDrawMeshTasksIndirectNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawMeshTasksIndirectNV(MemorySegment commandBuffer, MemorySegment buffer, long offset, int drawCount, int stride) {
        var mh$ = vkCmdDrawMeshTasksIndirectNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawMeshTasksIndirectNV", commandBuffer, buffer, offset, drawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, drawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawMeshTasksIndirectCountNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_POINTER,
            glfw3_h.C_LONG,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdDrawMeshTasksIndirectCountNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawMeshTasksIndirectCountNV$descriptor() {
        return vkCmdDrawMeshTasksIndirectCountNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawMeshTasksIndirectCountNV$handle() {
        return vkCmdDrawMeshTasksIndirectCountNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawMeshTasksIndirectCountNV$address() {
        return vkCmdDrawMeshTasksIndirectCountNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawMeshTasksIndirectCountNV(MemorySegment commandBuffer, MemorySegment buffer, long offset, MemorySegment countBuffer, long countBufferOffset, int maxDrawCount, int stride) {
        var mh$ = vkCmdDrawMeshTasksIndirectCountNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawMeshTasksIndirectCountNV", commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetExclusiveScissorNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdSetExclusiveScissorNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors)
     * }
     */
    public static FunctionDescriptor vkCmdSetExclusiveScissorNV$descriptor() {
        return vkCmdSetExclusiveScissorNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors)
     * }
     */
    public static MethodHandle vkCmdSetExclusiveScissorNV$handle() {
        return vkCmdSetExclusiveScissorNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors)
     * }
     */
    public static MemorySegment vkCmdSetExclusiveScissorNV$address() {
        return vkCmdSetExclusiveScissorNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors)
     * }
     */
    public static void vkCmdSetExclusiveScissorNV(MemorySegment commandBuffer, int firstExclusiveScissor, int exclusiveScissorCount, MemorySegment pExclusiveScissors) {
        var mh$ = vkCmdSetExclusiveScissorNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetExclusiveScissorNV", commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
            }
            mh$.invokeExact(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetCheckpointNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdSetCheckpointNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker)
     * }
     */
    public static FunctionDescriptor vkCmdSetCheckpointNV$descriptor() {
        return vkCmdSetCheckpointNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker)
     * }
     */
    public static MethodHandle vkCmdSetCheckpointNV$handle() {
        return vkCmdSetCheckpointNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker)
     * }
     */
    public static MemorySegment vkCmdSetCheckpointNV$address() {
        return vkCmdSetCheckpointNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker)
     * }
     */
    public static void vkCmdSetCheckpointNV(MemorySegment commandBuffer, MemorySegment pCheckpointMarker) {
        var mh$ = vkCmdSetCheckpointNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetCheckpointNV", commandBuffer, pCheckpointMarker);
            }
            mh$.invokeExact(commandBuffer, pCheckpointMarker);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetQueueCheckpointDataNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetQueueCheckpointDataNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData)
     * }
     */
    public static FunctionDescriptor vkGetQueueCheckpointDataNV$descriptor() {
        return vkGetQueueCheckpointDataNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData)
     * }
     */
    public static MethodHandle vkGetQueueCheckpointDataNV$handle() {
        return vkGetQueueCheckpointDataNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData)
     * }
     */
    public static MemorySegment vkGetQueueCheckpointDataNV$address() {
        return vkGetQueueCheckpointDataNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData)
     * }
     */
    public static void vkGetQueueCheckpointDataNV(MemorySegment queue, MemorySegment pCheckpointDataCount, MemorySegment pCheckpointData) {
        var mh$ = vkGetQueueCheckpointDataNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetQueueCheckpointDataNV", queue, pCheckpointDataCount, pCheckpointData);
            }
            mh$.invokeExact(queue, pCheckpointDataCount, pCheckpointData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkPerformanceConfigurationINTEL_T *VkPerformanceConfigurationINTEL
     * }
     */
    public static final AddressLayout VkPerformanceConfigurationINTEL = glfw3_h.C_POINTER;
    private static final int VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceConfigurationTypeINTEL.VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL = 0
     * }
     */
    public static int VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL() {
        return VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL;
    }
    private static final int VK_PERFORMANCE_CONFIGURATION_TYPE_BEGIN_RANGE_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceConfigurationTypeINTEL.VK_PERFORMANCE_CONFIGURATION_TYPE_BEGIN_RANGE_INTEL = 0
     * }
     */
    public static int VK_PERFORMANCE_CONFIGURATION_TYPE_BEGIN_RANGE_INTEL() {
        return VK_PERFORMANCE_CONFIGURATION_TYPE_BEGIN_RANGE_INTEL;
    }
    private static final int VK_PERFORMANCE_CONFIGURATION_TYPE_END_RANGE_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceConfigurationTypeINTEL.VK_PERFORMANCE_CONFIGURATION_TYPE_END_RANGE_INTEL = 0
     * }
     */
    public static int VK_PERFORMANCE_CONFIGURATION_TYPE_END_RANGE_INTEL() {
        return VK_PERFORMANCE_CONFIGURATION_TYPE_END_RANGE_INTEL;
    }
    private static final int VK_PERFORMANCE_CONFIGURATION_TYPE_RANGE_SIZE_INTEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceConfigurationTypeINTEL.VK_PERFORMANCE_CONFIGURATION_TYPE_RANGE_SIZE_INTEL = 1
     * }
     */
    public static int VK_PERFORMANCE_CONFIGURATION_TYPE_RANGE_SIZE_INTEL() {
        return VK_PERFORMANCE_CONFIGURATION_TYPE_RANGE_SIZE_INTEL;
    }
    private static final int VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceConfigurationTypeINTEL.VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL = 2147483647
     * }
     */
    public static int VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL() {
        return VK_PERFORMANCE_CONFIGURATION_TYPE_MAX_ENUM_INTEL;
    }
    private static final int VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkQueryPoolSamplingModeINTEL.VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL = 0
     * }
     */
    public static int VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL() {
        return VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL;
    }
    private static final int VK_QUERY_POOL_SAMPLING_MODE_BEGIN_RANGE_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkQueryPoolSamplingModeINTEL.VK_QUERY_POOL_SAMPLING_MODE_BEGIN_RANGE_INTEL = 0
     * }
     */
    public static int VK_QUERY_POOL_SAMPLING_MODE_BEGIN_RANGE_INTEL() {
        return VK_QUERY_POOL_SAMPLING_MODE_BEGIN_RANGE_INTEL;
    }
    private static final int VK_QUERY_POOL_SAMPLING_MODE_END_RANGE_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkQueryPoolSamplingModeINTEL.VK_QUERY_POOL_SAMPLING_MODE_END_RANGE_INTEL = 0
     * }
     */
    public static int VK_QUERY_POOL_SAMPLING_MODE_END_RANGE_INTEL() {
        return VK_QUERY_POOL_SAMPLING_MODE_END_RANGE_INTEL;
    }
    private static final int VK_QUERY_POOL_SAMPLING_MODE_RANGE_SIZE_INTEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkQueryPoolSamplingModeINTEL.VK_QUERY_POOL_SAMPLING_MODE_RANGE_SIZE_INTEL = 1
     * }
     */
    public static int VK_QUERY_POOL_SAMPLING_MODE_RANGE_SIZE_INTEL() {
        return VK_QUERY_POOL_SAMPLING_MODE_RANGE_SIZE_INTEL;
    }
    private static final int VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkQueryPoolSamplingModeINTEL.VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL = 2147483647
     * }
     */
    public static int VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL() {
        return VK_QUERY_POOL_SAMPLING_MODE_MAX_ENUM_INTEL;
    }
    private static final int VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceOverrideTypeINTEL.VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL = 0
     * }
     */
    public static int VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL() {
        return VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL;
    }
    private static final int VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceOverrideTypeINTEL.VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL = 1
     * }
     */
    public static int VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL() {
        return VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL;
    }
    private static final int VK_PERFORMANCE_OVERRIDE_TYPE_BEGIN_RANGE_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceOverrideTypeINTEL.VK_PERFORMANCE_OVERRIDE_TYPE_BEGIN_RANGE_INTEL = 0
     * }
     */
    public static int VK_PERFORMANCE_OVERRIDE_TYPE_BEGIN_RANGE_INTEL() {
        return VK_PERFORMANCE_OVERRIDE_TYPE_BEGIN_RANGE_INTEL;
    }
    private static final int VK_PERFORMANCE_OVERRIDE_TYPE_END_RANGE_INTEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceOverrideTypeINTEL.VK_PERFORMANCE_OVERRIDE_TYPE_END_RANGE_INTEL = 1
     * }
     */
    public static int VK_PERFORMANCE_OVERRIDE_TYPE_END_RANGE_INTEL() {
        return VK_PERFORMANCE_OVERRIDE_TYPE_END_RANGE_INTEL;
    }
    private static final int VK_PERFORMANCE_OVERRIDE_TYPE_RANGE_SIZE_INTEL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceOverrideTypeINTEL.VK_PERFORMANCE_OVERRIDE_TYPE_RANGE_SIZE_INTEL = 2
     * }
     */
    public static int VK_PERFORMANCE_OVERRIDE_TYPE_RANGE_SIZE_INTEL() {
        return VK_PERFORMANCE_OVERRIDE_TYPE_RANGE_SIZE_INTEL;
    }
    private static final int VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceOverrideTypeINTEL.VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL = 2147483647
     * }
     */
    public static int VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL() {
        return VK_PERFORMANCE_OVERRIDE_TYPE_MAX_ENUM_INTEL;
    }
    private static final int VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceParameterTypeINTEL.VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL = 0
     * }
     */
    public static int VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL() {
        return VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL;
    }
    private static final int VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceParameterTypeINTEL.VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL = 1
     * }
     */
    public static int VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL() {
        return VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL;
    }
    private static final int VK_PERFORMANCE_PARAMETER_TYPE_BEGIN_RANGE_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceParameterTypeINTEL.VK_PERFORMANCE_PARAMETER_TYPE_BEGIN_RANGE_INTEL = 0
     * }
     */
    public static int VK_PERFORMANCE_PARAMETER_TYPE_BEGIN_RANGE_INTEL() {
        return VK_PERFORMANCE_PARAMETER_TYPE_BEGIN_RANGE_INTEL;
    }
    private static final int VK_PERFORMANCE_PARAMETER_TYPE_END_RANGE_INTEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceParameterTypeINTEL.VK_PERFORMANCE_PARAMETER_TYPE_END_RANGE_INTEL = 1
     * }
     */
    public static int VK_PERFORMANCE_PARAMETER_TYPE_END_RANGE_INTEL() {
        return VK_PERFORMANCE_PARAMETER_TYPE_END_RANGE_INTEL;
    }
    private static final int VK_PERFORMANCE_PARAMETER_TYPE_RANGE_SIZE_INTEL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceParameterTypeINTEL.VK_PERFORMANCE_PARAMETER_TYPE_RANGE_SIZE_INTEL = 2
     * }
     */
    public static int VK_PERFORMANCE_PARAMETER_TYPE_RANGE_SIZE_INTEL() {
        return VK_PERFORMANCE_PARAMETER_TYPE_RANGE_SIZE_INTEL;
    }
    private static final int VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceParameterTypeINTEL.VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL = 2147483647
     * }
     */
    public static int VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL() {
        return VK_PERFORMANCE_PARAMETER_TYPE_MAX_ENUM_INTEL;
    }
    private static final int VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceValueTypeINTEL.VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL = 0
     * }
     */
    public static int VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL() {
        return VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL;
    }
    private static final int VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceValueTypeINTEL.VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL = 1
     * }
     */
    public static int VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL() {
        return VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL;
    }
    private static final int VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceValueTypeINTEL.VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL = 2
     * }
     */
    public static int VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL() {
        return VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL;
    }
    private static final int VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceValueTypeINTEL.VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL = 3
     * }
     */
    public static int VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL() {
        return VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL;
    }
    private static final int VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceValueTypeINTEL.VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL = 4
     * }
     */
    public static int VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL() {
        return VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL;
    }
    private static final int VK_PERFORMANCE_VALUE_TYPE_BEGIN_RANGE_INTEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceValueTypeINTEL.VK_PERFORMANCE_VALUE_TYPE_BEGIN_RANGE_INTEL = 0
     * }
     */
    public static int VK_PERFORMANCE_VALUE_TYPE_BEGIN_RANGE_INTEL() {
        return VK_PERFORMANCE_VALUE_TYPE_BEGIN_RANGE_INTEL;
    }
    private static final int VK_PERFORMANCE_VALUE_TYPE_END_RANGE_INTEL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceValueTypeINTEL.VK_PERFORMANCE_VALUE_TYPE_END_RANGE_INTEL = 4
     * }
     */
    public static int VK_PERFORMANCE_VALUE_TYPE_END_RANGE_INTEL() {
        return VK_PERFORMANCE_VALUE_TYPE_END_RANGE_INTEL;
    }
    private static final int VK_PERFORMANCE_VALUE_TYPE_RANGE_SIZE_INTEL = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceValueTypeINTEL.VK_PERFORMANCE_VALUE_TYPE_RANGE_SIZE_INTEL = 5
     * }
     */
    public static int VK_PERFORMANCE_VALUE_TYPE_RANGE_SIZE_INTEL() {
        return VK_PERFORMANCE_VALUE_TYPE_RANGE_SIZE_INTEL;
    }
    private static final int VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceValueTypeINTEL.VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL = 2147483647
     * }
     */
    public static int VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL() {
        return VK_PERFORMANCE_VALUE_TYPE_MAX_ENUM_INTEL;
    }

    private static class vkInitializePerformanceApiINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkInitializePerformanceApiINTEL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo)
     * }
     */
    public static FunctionDescriptor vkInitializePerformanceApiINTEL$descriptor() {
        return vkInitializePerformanceApiINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo)
     * }
     */
    public static MethodHandle vkInitializePerformanceApiINTEL$handle() {
        return vkInitializePerformanceApiINTEL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo)
     * }
     */
    public static MemorySegment vkInitializePerformanceApiINTEL$address() {
        return vkInitializePerformanceApiINTEL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkInitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo)
     * }
     */
    public static int vkInitializePerformanceApiINTEL(MemorySegment device, MemorySegment pInitializeInfo) {
        var mh$ = vkInitializePerformanceApiINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkInitializePerformanceApiINTEL", device, pInitializeInfo);
            }
            return (int)mh$.invokeExact(device, pInitializeInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkUninitializePerformanceApiINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkUninitializePerformanceApiINTEL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkUninitializePerformanceApiINTEL(VkDevice device)
     * }
     */
    public static FunctionDescriptor vkUninitializePerformanceApiINTEL$descriptor() {
        return vkUninitializePerformanceApiINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkUninitializePerformanceApiINTEL(VkDevice device)
     * }
     */
    public static MethodHandle vkUninitializePerformanceApiINTEL$handle() {
        return vkUninitializePerformanceApiINTEL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkUninitializePerformanceApiINTEL(VkDevice device)
     * }
     */
    public static MemorySegment vkUninitializePerformanceApiINTEL$address() {
        return vkUninitializePerformanceApiINTEL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkUninitializePerformanceApiINTEL(VkDevice device)
     * }
     */
    public static void vkUninitializePerformanceApiINTEL(MemorySegment device) {
        var mh$ = vkUninitializePerformanceApiINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkUninitializePerformanceApiINTEL", device);
            }
            mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetPerformanceMarkerINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdSetPerformanceMarkerINTEL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo)
     * }
     */
    public static FunctionDescriptor vkCmdSetPerformanceMarkerINTEL$descriptor() {
        return vkCmdSetPerformanceMarkerINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo)
     * }
     */
    public static MethodHandle vkCmdSetPerformanceMarkerINTEL$handle() {
        return vkCmdSetPerformanceMarkerINTEL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo)
     * }
     */
    public static MemorySegment vkCmdSetPerformanceMarkerINTEL$address() {
        return vkCmdSetPerformanceMarkerINTEL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo)
     * }
     */
    public static int vkCmdSetPerformanceMarkerINTEL(MemorySegment commandBuffer, MemorySegment pMarkerInfo) {
        var mh$ = vkCmdSetPerformanceMarkerINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetPerformanceMarkerINTEL", commandBuffer, pMarkerInfo);
            }
            return (int)mh$.invokeExact(commandBuffer, pMarkerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetPerformanceStreamMarkerINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdSetPerformanceStreamMarkerINTEL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo)
     * }
     */
    public static FunctionDescriptor vkCmdSetPerformanceStreamMarkerINTEL$descriptor() {
        return vkCmdSetPerformanceStreamMarkerINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo)
     * }
     */
    public static MethodHandle vkCmdSetPerformanceStreamMarkerINTEL$handle() {
        return vkCmdSetPerformanceStreamMarkerINTEL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo)
     * }
     */
    public static MemorySegment vkCmdSetPerformanceStreamMarkerINTEL$address() {
        return vkCmdSetPerformanceStreamMarkerINTEL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo)
     * }
     */
    public static int vkCmdSetPerformanceStreamMarkerINTEL(MemorySegment commandBuffer, MemorySegment pMarkerInfo) {
        var mh$ = vkCmdSetPerformanceStreamMarkerINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetPerformanceStreamMarkerINTEL", commandBuffer, pMarkerInfo);
            }
            return (int)mh$.invokeExact(commandBuffer, pMarkerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetPerformanceOverrideINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdSetPerformanceOverrideINTEL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo)
     * }
     */
    public static FunctionDescriptor vkCmdSetPerformanceOverrideINTEL$descriptor() {
        return vkCmdSetPerformanceOverrideINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo)
     * }
     */
    public static MethodHandle vkCmdSetPerformanceOverrideINTEL$handle() {
        return vkCmdSetPerformanceOverrideINTEL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo)
     * }
     */
    public static MemorySegment vkCmdSetPerformanceOverrideINTEL$address() {
        return vkCmdSetPerformanceOverrideINTEL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo)
     * }
     */
    public static int vkCmdSetPerformanceOverrideINTEL(MemorySegment commandBuffer, MemorySegment pOverrideInfo) {
        var mh$ = vkCmdSetPerformanceOverrideINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetPerformanceOverrideINTEL", commandBuffer, pOverrideInfo);
            }
            return (int)mh$.invokeExact(commandBuffer, pOverrideInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkAcquirePerformanceConfigurationINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkAcquirePerformanceConfigurationINTEL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkAcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration)
     * }
     */
    public static FunctionDescriptor vkAcquirePerformanceConfigurationINTEL$descriptor() {
        return vkAcquirePerformanceConfigurationINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkAcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration)
     * }
     */
    public static MethodHandle vkAcquirePerformanceConfigurationINTEL$handle() {
        return vkAcquirePerformanceConfigurationINTEL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkAcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration)
     * }
     */
    public static MemorySegment vkAcquirePerformanceConfigurationINTEL$address() {
        return vkAcquirePerformanceConfigurationINTEL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkAcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration)
     * }
     */
    public static int vkAcquirePerformanceConfigurationINTEL(MemorySegment device, MemorySegment pAcquireInfo, MemorySegment pConfiguration) {
        var mh$ = vkAcquirePerformanceConfigurationINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkAcquirePerformanceConfigurationINTEL", device, pAcquireInfo, pConfiguration);
            }
            return (int)mh$.invokeExact(device, pAcquireInfo, pConfiguration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkReleasePerformanceConfigurationINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkReleasePerformanceConfigurationINTEL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration)
     * }
     */
    public static FunctionDescriptor vkReleasePerformanceConfigurationINTEL$descriptor() {
        return vkReleasePerformanceConfigurationINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration)
     * }
     */
    public static MethodHandle vkReleasePerformanceConfigurationINTEL$handle() {
        return vkReleasePerformanceConfigurationINTEL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration)
     * }
     */
    public static MemorySegment vkReleasePerformanceConfigurationINTEL$address() {
        return vkReleasePerformanceConfigurationINTEL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration)
     * }
     */
    public static int vkReleasePerformanceConfigurationINTEL(MemorySegment device, MemorySegment configuration) {
        var mh$ = vkReleasePerformanceConfigurationINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkReleasePerformanceConfigurationINTEL", device, configuration);
            }
            return (int)mh$.invokeExact(device, configuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkQueueSetPerformanceConfigurationINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkQueueSetPerformanceConfigurationINTEL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkQueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration)
     * }
     */
    public static FunctionDescriptor vkQueueSetPerformanceConfigurationINTEL$descriptor() {
        return vkQueueSetPerformanceConfigurationINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkQueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration)
     * }
     */
    public static MethodHandle vkQueueSetPerformanceConfigurationINTEL$handle() {
        return vkQueueSetPerformanceConfigurationINTEL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkQueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration)
     * }
     */
    public static MemorySegment vkQueueSetPerformanceConfigurationINTEL$address() {
        return vkQueueSetPerformanceConfigurationINTEL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkQueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration)
     * }
     */
    public static int vkQueueSetPerformanceConfigurationINTEL(MemorySegment queue, MemorySegment configuration) {
        var mh$ = vkQueueSetPerformanceConfigurationINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkQueueSetPerformanceConfigurationINTEL", queue, configuration);
            }
            return (int)mh$.invokeExact(queue, configuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPerformanceParameterINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetPerformanceParameterINTEL");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue)
     * }
     */
    public static FunctionDescriptor vkGetPerformanceParameterINTEL$descriptor() {
        return vkGetPerformanceParameterINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue)
     * }
     */
    public static MethodHandle vkGetPerformanceParameterINTEL$handle() {
        return vkGetPerformanceParameterINTEL.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue)
     * }
     */
    public static MemorySegment vkGetPerformanceParameterINTEL$address() {
        return vkGetPerformanceParameterINTEL.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue)
     * }
     */
    public static int vkGetPerformanceParameterINTEL(MemorySegment device, int parameter, MemorySegment pValue) {
        var mh$ = vkGetPerformanceParameterINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPerformanceParameterINTEL", device, parameter, pValue);
            }
            return (int)mh$.invokeExact(device, parameter, pValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkSetLocalDimmingAMD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkSetLocalDimmingAMD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable)
     * }
     */
    public static FunctionDescriptor vkSetLocalDimmingAMD$descriptor() {
        return vkSetLocalDimmingAMD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable)
     * }
     */
    public static MethodHandle vkSetLocalDimmingAMD$handle() {
        return vkSetLocalDimmingAMD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable)
     * }
     */
    public static MemorySegment vkSetLocalDimmingAMD$address() {
        return vkSetLocalDimmingAMD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable)
     * }
     */
    public static void vkSetLocalDimmingAMD(MemorySegment device, MemorySegment swapChain, int localDimmingEnable) {
        var mh$ = vkSetLocalDimmingAMD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkSetLocalDimmingAMD", device, swapChain, localDimmingEnable);
            }
            mh$.invokeExact(device, swapChain, localDimmingEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkShaderCorePropertiesFlagBitsAMD.VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD = 2147483647
     * }
     */
    public static int VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD() {
        return VK_SHADER_CORE_PROPERTIES_FLAG_BITS_MAX_ENUM_AMD;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkShaderCorePropertiesFlagsAMD
     * }
     */
    public static final OfInt VkShaderCorePropertiesFlagsAMD = glfw3_h.C_INT;

    private static class vkGetBufferDeviceAddressEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_LONG,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetBufferDeviceAddressEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetBufferDeviceAddressEXT$descriptor() {
        return vkGetBufferDeviceAddressEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MethodHandle vkGetBufferDeviceAddressEXT$handle() {
        return vkGetBufferDeviceAddressEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MemorySegment vkGetBufferDeviceAddressEXT$address() {
        return vkGetBufferDeviceAddressEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static long vkGetBufferDeviceAddressEXT(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetBufferDeviceAddressEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetBufferDeviceAddressEXT", device, pInfo);
            }
            return (long)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkToolPurposeFlagBitsEXT.VK_TOOL_PURPOSE_VALIDATION_BIT_EXT = 1
     * }
     */
    public static int VK_TOOL_PURPOSE_VALIDATION_BIT_EXT() {
        return VK_TOOL_PURPOSE_VALIDATION_BIT_EXT;
    }
    private static final int VK_TOOL_PURPOSE_PROFILING_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkToolPurposeFlagBitsEXT.VK_TOOL_PURPOSE_PROFILING_BIT_EXT = 2
     * }
     */
    public static int VK_TOOL_PURPOSE_PROFILING_BIT_EXT() {
        return VK_TOOL_PURPOSE_PROFILING_BIT_EXT;
    }
    private static final int VK_TOOL_PURPOSE_TRACING_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkToolPurposeFlagBitsEXT.VK_TOOL_PURPOSE_TRACING_BIT_EXT = 4
     * }
     */
    public static int VK_TOOL_PURPOSE_TRACING_BIT_EXT() {
        return VK_TOOL_PURPOSE_TRACING_BIT_EXT;
    }
    private static final int VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkToolPurposeFlagBitsEXT.VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT = 8
     * }
     */
    public static int VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT() {
        return VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT;
    }
    private static final int VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkToolPurposeFlagBitsEXT.VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT = 16
     * }
     */
    public static int VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT() {
        return VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT;
    }
    private static final int VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkToolPurposeFlagBitsEXT.VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT = 32
     * }
     */
    public static int VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT() {
        return VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT;
    }
    private static final int VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkToolPurposeFlagBitsEXT.VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT = 64
     * }
     */
    public static int VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT() {
        return VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT;
    }
    private static final int VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkToolPurposeFlagBitsEXT.VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkToolPurposeFlagsEXT
     * }
     */
    public static final OfInt VkToolPurposeFlagsEXT = glfw3_h.C_INT;

    private static class vkGetPhysicalDeviceToolPropertiesEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetPhysicalDeviceToolPropertiesEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolPropertiesEXT *pToolProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceToolPropertiesEXT$descriptor() {
        return vkGetPhysicalDeviceToolPropertiesEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolPropertiesEXT *pToolProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceToolPropertiesEXT$handle() {
        return vkGetPhysicalDeviceToolPropertiesEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolPropertiesEXT *pToolProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceToolPropertiesEXT$address() {
        return vkGetPhysicalDeviceToolPropertiesEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolPropertiesEXT *pToolProperties)
     * }
     */
    public static int vkGetPhysicalDeviceToolPropertiesEXT(MemorySegment physicalDevice, MemorySegment pToolCount, MemorySegment pToolProperties) {
        var mh$ = vkGetPhysicalDeviceToolPropertiesEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceToolPropertiesEXT", physicalDevice, pToolCount, pToolProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pToolCount, pToolProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT = 0
     * }
     */
    public static int VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT() {
        return VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT = 1
     * }
     */
    public static int VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT() {
        return VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT = 2
     * }
     */
    public static int VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT() {
        return VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_ENABLE_BEGIN_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_BEGIN_RANGE_EXT = 0
     * }
     */
    public static int VK_VALIDATION_FEATURE_ENABLE_BEGIN_RANGE_EXT() {
        return VK_VALIDATION_FEATURE_ENABLE_BEGIN_RANGE_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_ENABLE_END_RANGE_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_END_RANGE_EXT = 2
     * }
     */
    public static int VK_VALIDATION_FEATURE_ENABLE_END_RANGE_EXT() {
        return VK_VALIDATION_FEATURE_ENABLE_END_RANGE_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_ENABLE_RANGE_SIZE_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_RANGE_SIZE_EXT = 3
     * }
     */
    public static int VK_VALIDATION_FEATURE_ENABLE_RANGE_SIZE_EXT() {
        return VK_VALIDATION_FEATURE_ENABLE_RANGE_SIZE_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureEnableEXT.VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT() {
        return VK_VALIDATION_FEATURE_ENABLE_MAX_ENUM_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_ALL_EXT = 0
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_ALL_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_ALL_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT = 1
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT = 2
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT = 3
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT = 4
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT = 5
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT = 6
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_BEGIN_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_BEGIN_RANGE_EXT = 0
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_BEGIN_RANGE_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_BEGIN_RANGE_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_END_RANGE_EXT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_END_RANGE_EXT = 6
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_END_RANGE_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_END_RANGE_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_RANGE_SIZE_EXT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_RANGE_SIZE_EXT = 7
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_RANGE_SIZE_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_RANGE_SIZE_EXT;
    }
    private static final int VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkValidationFeatureDisableEXT.VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT() {
        return VK_VALIDATION_FEATURE_DISABLE_MAX_ENUM_EXT;
    }
    private static final int VK_COMPONENT_TYPE_FLOAT16_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_FLOAT16_NV = 0
     * }
     */
    public static int VK_COMPONENT_TYPE_FLOAT16_NV() {
        return VK_COMPONENT_TYPE_FLOAT16_NV;
    }
    private static final int VK_COMPONENT_TYPE_FLOAT32_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_FLOAT32_NV = 1
     * }
     */
    public static int VK_COMPONENT_TYPE_FLOAT32_NV() {
        return VK_COMPONENT_TYPE_FLOAT32_NV;
    }
    private static final int VK_COMPONENT_TYPE_FLOAT64_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_FLOAT64_NV = 2
     * }
     */
    public static int VK_COMPONENT_TYPE_FLOAT64_NV() {
        return VK_COMPONENT_TYPE_FLOAT64_NV;
    }
    private static final int VK_COMPONENT_TYPE_SINT8_NV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_SINT8_NV = 3
     * }
     */
    public static int VK_COMPONENT_TYPE_SINT8_NV() {
        return VK_COMPONENT_TYPE_SINT8_NV;
    }
    private static final int VK_COMPONENT_TYPE_SINT16_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_SINT16_NV = 4
     * }
     */
    public static int VK_COMPONENT_TYPE_SINT16_NV() {
        return VK_COMPONENT_TYPE_SINT16_NV;
    }
    private static final int VK_COMPONENT_TYPE_SINT32_NV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_SINT32_NV = 5
     * }
     */
    public static int VK_COMPONENT_TYPE_SINT32_NV() {
        return VK_COMPONENT_TYPE_SINT32_NV;
    }
    private static final int VK_COMPONENT_TYPE_SINT64_NV = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_SINT64_NV = 6
     * }
     */
    public static int VK_COMPONENT_TYPE_SINT64_NV() {
        return VK_COMPONENT_TYPE_SINT64_NV;
    }
    private static final int VK_COMPONENT_TYPE_UINT8_NV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_UINT8_NV = 7
     * }
     */
    public static int VK_COMPONENT_TYPE_UINT8_NV() {
        return VK_COMPONENT_TYPE_UINT8_NV;
    }
    private static final int VK_COMPONENT_TYPE_UINT16_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_UINT16_NV = 8
     * }
     */
    public static int VK_COMPONENT_TYPE_UINT16_NV() {
        return VK_COMPONENT_TYPE_UINT16_NV;
    }
    private static final int VK_COMPONENT_TYPE_UINT32_NV = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_UINT32_NV = 9
     * }
     */
    public static int VK_COMPONENT_TYPE_UINT32_NV() {
        return VK_COMPONENT_TYPE_UINT32_NV;
    }
    private static final int VK_COMPONENT_TYPE_UINT64_NV = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_UINT64_NV = 10
     * }
     */
    public static int VK_COMPONENT_TYPE_UINT64_NV() {
        return VK_COMPONENT_TYPE_UINT64_NV;
    }
    private static final int VK_COMPONENT_TYPE_BEGIN_RANGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_BEGIN_RANGE_NV = 0
     * }
     */
    public static int VK_COMPONENT_TYPE_BEGIN_RANGE_NV() {
        return VK_COMPONENT_TYPE_BEGIN_RANGE_NV;
    }
    private static final int VK_COMPONENT_TYPE_END_RANGE_NV = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_END_RANGE_NV = 10
     * }
     */
    public static int VK_COMPONENT_TYPE_END_RANGE_NV() {
        return VK_COMPONENT_TYPE_END_RANGE_NV;
    }
    private static final int VK_COMPONENT_TYPE_RANGE_SIZE_NV = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_RANGE_SIZE_NV = 11
     * }
     */
    public static int VK_COMPONENT_TYPE_RANGE_SIZE_NV() {
        return VK_COMPONENT_TYPE_RANGE_SIZE_NV;
    }
    private static final int VK_COMPONENT_TYPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkComponentTypeNV.VK_COMPONENT_TYPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_COMPONENT_TYPE_MAX_ENUM_NV() {
        return VK_COMPONENT_TYPE_MAX_ENUM_NV;
    }
    private static final int VK_SCOPE_DEVICE_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkScopeNV.VK_SCOPE_DEVICE_NV = 1
     * }
     */
    public static int VK_SCOPE_DEVICE_NV() {
        return VK_SCOPE_DEVICE_NV;
    }
    private static final int VK_SCOPE_WORKGROUP_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkScopeNV.VK_SCOPE_WORKGROUP_NV = 2
     * }
     */
    public static int VK_SCOPE_WORKGROUP_NV() {
        return VK_SCOPE_WORKGROUP_NV;
    }
    private static final int VK_SCOPE_SUBGROUP_NV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkScopeNV.VK_SCOPE_SUBGROUP_NV = 3
     * }
     */
    public static int VK_SCOPE_SUBGROUP_NV() {
        return VK_SCOPE_SUBGROUP_NV;
    }
    private static final int VK_SCOPE_QUEUE_FAMILY_NV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkScopeNV.VK_SCOPE_QUEUE_FAMILY_NV = 5
     * }
     */
    public static int VK_SCOPE_QUEUE_FAMILY_NV() {
        return VK_SCOPE_QUEUE_FAMILY_NV;
    }
    private static final int VK_SCOPE_BEGIN_RANGE_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkScopeNV.VK_SCOPE_BEGIN_RANGE_NV = 1
     * }
     */
    public static int VK_SCOPE_BEGIN_RANGE_NV() {
        return VK_SCOPE_BEGIN_RANGE_NV;
    }
    private static final int VK_SCOPE_END_RANGE_NV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkScopeNV.VK_SCOPE_END_RANGE_NV = 5
     * }
     */
    public static int VK_SCOPE_END_RANGE_NV() {
        return VK_SCOPE_END_RANGE_NV;
    }
    private static final int VK_SCOPE_RANGE_SIZE_NV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkScopeNV.VK_SCOPE_RANGE_SIZE_NV = 5
     * }
     */
    public static int VK_SCOPE_RANGE_SIZE_NV() {
        return VK_SCOPE_RANGE_SIZE_NV;
    }
    private static final int VK_SCOPE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkScopeNV.VK_SCOPE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_SCOPE_MAX_ENUM_NV() {
        return VK_SCOPE_MAX_ENUM_NV;
    }

    private static class vkGetPhysicalDeviceCooperativeMatrixPropertiesNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceCooperativeMatrixPropertiesNV$descriptor() {
        return vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceCooperativeMatrixPropertiesNV$handle() {
        return vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceCooperativeMatrixPropertiesNV$address() {
        return vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties)
     * }
     */
    public static int vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(MemorySegment physicalDevice, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceCooperativeMatrixPropertiesNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", physicalDevice, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_COVERAGE_REDUCTION_MODE_MERGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkCoverageReductionModeNV.VK_COVERAGE_REDUCTION_MODE_MERGE_NV = 0
     * }
     */
    public static int VK_COVERAGE_REDUCTION_MODE_MERGE_NV() {
        return VK_COVERAGE_REDUCTION_MODE_MERGE_NV;
    }
    private static final int VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCoverageReductionModeNV.VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV = 1
     * }
     */
    public static int VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV() {
        return VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV;
    }
    private static final int VK_COVERAGE_REDUCTION_MODE_BEGIN_RANGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkCoverageReductionModeNV.VK_COVERAGE_REDUCTION_MODE_BEGIN_RANGE_NV = 0
     * }
     */
    public static int VK_COVERAGE_REDUCTION_MODE_BEGIN_RANGE_NV() {
        return VK_COVERAGE_REDUCTION_MODE_BEGIN_RANGE_NV;
    }
    private static final int VK_COVERAGE_REDUCTION_MODE_END_RANGE_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCoverageReductionModeNV.VK_COVERAGE_REDUCTION_MODE_END_RANGE_NV = 1
     * }
     */
    public static int VK_COVERAGE_REDUCTION_MODE_END_RANGE_NV() {
        return VK_COVERAGE_REDUCTION_MODE_END_RANGE_NV;
    }
    private static final int VK_COVERAGE_REDUCTION_MODE_RANGE_SIZE_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkCoverageReductionModeNV.VK_COVERAGE_REDUCTION_MODE_RANGE_SIZE_NV = 2
     * }
     */
    public static int VK_COVERAGE_REDUCTION_MODE_RANGE_SIZE_NV() {
        return VK_COVERAGE_REDUCTION_MODE_RANGE_SIZE_NV;
    }
    private static final int VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCoverageReductionModeNV.VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV() {
        return VK_COVERAGE_REDUCTION_MODE_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineCoverageReductionStateCreateFlagsNV
     * }
     */
    public static final OfInt VkPipelineCoverageReductionStateCreateFlagsNV = glfw3_h.C_INT;

    private static class vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV$descriptor() {
        return vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV$handle() {
        return vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV$address() {
        return vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations)
     * }
     */
    public static int vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(MemorySegment physicalDevice, MemorySegment pCombinationCount, MemorySegment pCombinations) {
        var mh$ = vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", physicalDevice, pCombinationCount, pCombinations);
            }
            return (int)mh$.invokeExact(physicalDevice, pCombinationCount, pCombinations);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkHeadlessSurfaceCreateFlagsEXT
     * }
     */
    public static final OfInt VkHeadlessSurfaceCreateFlagsEXT = glfw3_h.C_INT;

    private static class vkCreateHeadlessSurfaceEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCreateHeadlessSurfaceEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static FunctionDescriptor vkCreateHeadlessSurfaceEXT$descriptor() {
        return vkCreateHeadlessSurfaceEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static MethodHandle vkCreateHeadlessSurfaceEXT$handle() {
        return vkCreateHeadlessSurfaceEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static MemorySegment vkCreateHeadlessSurfaceEXT$address() {
        return vkCreateHeadlessSurfaceEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static int vkCreateHeadlessSurfaceEXT(MemorySegment instance, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSurface) {
        var mh$ = vkCreateHeadlessSurfaceEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateHeadlessSurfaceEXT", instance, pCreateInfo, pAllocator, pSurface);
            }
            return (int)mh$.invokeExact(instance, pCreateInfo, pAllocator, pSurface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkLineRasterizationModeEXT.VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT = 0
     * }
     */
    public static int VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT() {
        return VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT;
    }
    private static final int VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkLineRasterizationModeEXT.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT = 1
     * }
     */
    public static int VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT() {
        return VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT;
    }
    private static final int VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkLineRasterizationModeEXT.VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT = 2
     * }
     */
    public static int VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT() {
        return VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT;
    }
    private static final int VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkLineRasterizationModeEXT.VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT = 3
     * }
     */
    public static int VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT() {
        return VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT;
    }
    private static final int VK_LINE_RASTERIZATION_MODE_BEGIN_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkLineRasterizationModeEXT.VK_LINE_RASTERIZATION_MODE_BEGIN_RANGE_EXT = 0
     * }
     */
    public static int VK_LINE_RASTERIZATION_MODE_BEGIN_RANGE_EXT() {
        return VK_LINE_RASTERIZATION_MODE_BEGIN_RANGE_EXT;
    }
    private static final int VK_LINE_RASTERIZATION_MODE_END_RANGE_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkLineRasterizationModeEXT.VK_LINE_RASTERIZATION_MODE_END_RANGE_EXT = 3
     * }
     */
    public static int VK_LINE_RASTERIZATION_MODE_END_RANGE_EXT() {
        return VK_LINE_RASTERIZATION_MODE_END_RANGE_EXT;
    }
    private static final int VK_LINE_RASTERIZATION_MODE_RANGE_SIZE_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkLineRasterizationModeEXT.VK_LINE_RASTERIZATION_MODE_RANGE_SIZE_EXT = 4
     * }
     */
    public static int VK_LINE_RASTERIZATION_MODE_RANGE_SIZE_EXT() {
        return VK_LINE_RASTERIZATION_MODE_RANGE_SIZE_EXT;
    }
    private static final int VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkLineRasterizationModeEXT.VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT() {
        return VK_LINE_RASTERIZATION_MODE_MAX_ENUM_EXT;
    }

    private static class vkCmdSetLineStippleEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkCmdSetLineStippleEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
     * }
     */
    public static FunctionDescriptor vkCmdSetLineStippleEXT$descriptor() {
        return vkCmdSetLineStippleEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
     * }
     */
    public static MethodHandle vkCmdSetLineStippleEXT$handle() {
        return vkCmdSetLineStippleEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
     * }
     */
    public static MemorySegment vkCmdSetLineStippleEXT$address() {
        return vkCmdSetLineStippleEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
     * }
     */
    public static void vkCmdSetLineStippleEXT(MemorySegment commandBuffer, int lineStippleFactor, short lineStipplePattern) {
        var mh$ = vkCmdSetLineStippleEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetLineStippleEXT", commandBuffer, lineStippleFactor, lineStipplePattern);
            }
            mh$.invokeExact(commandBuffer, lineStippleFactor, lineStipplePattern);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkResetQueryPoolEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("vkResetQueryPoolEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static FunctionDescriptor vkResetQueryPoolEXT$descriptor() {
        return vkResetQueryPoolEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static MethodHandle vkResetQueryPoolEXT$handle() {
        return vkResetQueryPoolEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static MemorySegment vkResetQueryPoolEXT$address() {
        return vkResetQueryPoolEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static void vkResetQueryPoolEXT(MemorySegment device, MemorySegment queryPool, int firstQuery, int queryCount) {
        var mh$ = vkResetQueryPoolEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkResetQueryPoolEXT", device, queryPool, firstQuery, queryCount);
            }
            mh$.invokeExact(device, queryPool, firstQuery, queryCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLenum
     * }
     */
    public static final OfInt GLenum = glfw3_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char GLboolean
     * }
     */
    public static final OfByte GLboolean = glfw3_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLbitfield
     * }
     */
    public static final OfInt GLbitfield = glfw3_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char GLbyte
     * }
     */
    public static final OfByte GLbyte = glfw3_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short GLshort
     * }
     */
    public static final OfShort GLshort = glfw3_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int GLint
     * }
     */
    public static final OfInt GLint = glfw3_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned char GLubyte
     * }
     */
    public static final OfByte GLubyte = glfw3_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short GLushort
     * }
     */
    public static final OfShort GLushort = glfw3_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLuint
     * }
     */
    public static final OfInt GLuint = glfw3_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int GLsizei
     * }
     */
    public static final OfInt GLsizei = glfw3_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef float GLfloat
     * }
     */
    public static final OfFloat GLfloat = glfw3_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef float GLclampf
     * }
     */
    public static final OfFloat GLclampf = glfw3_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double GLdouble
     * }
     */
    public static final OfDouble GLdouble = glfw3_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double GLclampd
     * }
     */
    public static final OfDouble GLclampd = glfw3_h.C_DOUBLE;

    private static class glClearIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glClearIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static FunctionDescriptor glClearIndex$descriptor() {
        return glClearIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static MethodHandle glClearIndex$handle() {
        return glClearIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static MemorySegment glClearIndex$address() {
        return glClearIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearIndex(GLfloat c)
     * }
     */
    public static void glClearIndex(float c) {
        var mh$ = glClearIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearIndex", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glClearColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glClearColor$descriptor() {
        return glClearColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glClearColor$handle() {
        return glClearColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glClearColor$address() {
        return glClearColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glClearColor(float red, float green, float blue, float alpha) {
        var mh$ = glClearColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearColor", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glClear$descriptor() {
        return glClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static MethodHandle glClear$handle() {
        return glClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static MemorySegment glClear$address() {
        return glClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClear(GLbitfield mask)
     * }
     */
    public static void glClear(int mask) {
        var mh$ = glClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClear", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glIndexMask$descriptor() {
        return glIndexMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static MethodHandle glIndexMask$handle() {
        return glIndexMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static MemorySegment glIndexMask$address() {
        return glIndexMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexMask(GLuint mask)
     * }
     */
    public static void glIndexMask(int mask) {
        var mh$ = glIndexMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColorMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static FunctionDescriptor glColorMask$descriptor() {
        return glColorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MethodHandle glColorMask$handle() {
        return glColorMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static MemorySegment glColorMask$address() {
        return glColorMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
     * }
     */
    public static void glColorMask(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMask", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAlphaFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glAlphaFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static FunctionDescriptor glAlphaFunc$descriptor() {
        return glAlphaFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MethodHandle glAlphaFunc$handle() {
        return glAlphaFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static MemorySegment glAlphaFunc$address() {
        return glAlphaFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glAlphaFunc(GLenum func, GLclampf ref)
     * }
     */
    public static void glAlphaFunc(int func, float ref) {
        var mh$ = glAlphaFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAlphaFunc", func, ref);
            }
            mh$.invokeExact(func, ref);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glBlendFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static FunctionDescriptor glBlendFunc$descriptor() {
        return glBlendFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MethodHandle glBlendFunc$handle() {
        return glBlendFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static MemorySegment glBlendFunc$address() {
        return glBlendFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendFunc(GLenum sfactor, GLenum dfactor)
     * }
     */
    public static void glBlendFunc(int sfactor, int dfactor) {
        var mh$ = glBlendFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendFunc", sfactor, dfactor);
            }
            mh$.invokeExact(sfactor, dfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLogicOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLogicOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static FunctionDescriptor glLogicOp$descriptor() {
        return glLogicOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static MethodHandle glLogicOp$handle() {
        return glLogicOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static MemorySegment glLogicOp$address() {
        return glLogicOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLogicOp(GLenum opcode)
     * }
     */
    public static void glLogicOp(int opcode) {
        var mh$ = glLogicOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLogicOp", opcode);
            }
            mh$.invokeExact(opcode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCullFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCullFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glCullFace$descriptor() {
        return glCullFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static MethodHandle glCullFace$handle() {
        return glCullFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static MemorySegment glCullFace$address() {
        return glCullFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCullFace(GLenum mode)
     * }
     */
    public static void glCullFace(int mode) {
        var mh$ = glCullFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCullFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrontFace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glFrontFace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static FunctionDescriptor glFrontFace$descriptor() {
        return glFrontFace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static MethodHandle glFrontFace$handle() {
        return glFrontFace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static MemorySegment glFrontFace$address() {
        return glFrontFace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFrontFace(GLenum mode)
     * }
     */
    public static void glFrontFace(int mode) {
        var mh$ = glFrontFace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrontFace", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPointSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPointSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static FunctionDescriptor glPointSize$descriptor() {
        return glPointSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static MethodHandle glPointSize$handle() {
        return glPointSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static MemorySegment glPointSize$address() {
        return glPointSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPointSize(GLfloat size)
     * }
     */
    public static void glPointSize(float size) {
        var mh$ = glPointSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPointSize", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static FunctionDescriptor glLineWidth$descriptor() {
        return glLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static MethodHandle glLineWidth$handle() {
        return glLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static MemorySegment glLineWidth$address() {
        return glLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLineWidth(GLfloat width)
     * }
     */
    public static void glLineWidth(float width) {
        var mh$ = glLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineWidth", width);
            }
            mh$.invokeExact(width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLineStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLineStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static FunctionDescriptor glLineStipple$descriptor() {
        return glLineStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MethodHandle glLineStipple$handle() {
        return glLineStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static MemorySegment glLineStipple$address() {
        return glLineStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLineStipple(GLint factor, GLushort pattern)
     * }
     */
    public static void glLineStipple(int factor, short pattern) {
        var mh$ = glLineStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLineStipple", factor, pattern);
            }
            mh$.invokeExact(factor, pattern);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPolygonMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glPolygonMode$descriptor() {
        return glPolygonMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glPolygonMode$handle() {
        return glPolygonMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glPolygonMode$address() {
        return glPolygonMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonMode(GLenum face, GLenum mode)
     * }
     */
    public static void glPolygonMode(int face, int mode) {
        var mh$ = glPolygonMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonMode", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPolygonOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static FunctionDescriptor glPolygonOffset$descriptor() {
        return glPolygonOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MethodHandle glPolygonOffset$handle() {
        return glPolygonOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static MemorySegment glPolygonOffset$address() {
        return glPolygonOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonOffset(GLfloat factor, GLfloat units)
     * }
     */
    public static void glPolygonOffset(float factor, float units) {
        var mh$ = glPolygonOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonOffset", factor, units);
            }
            mh$.invokeExact(factor, units);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glPolygonStipple$descriptor() {
        return glPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MethodHandle glPolygonStipple$handle() {
        return glPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static MemorySegment glPolygonStipple$address() {
        return glPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPolygonStipple(const GLubyte *mask)
     * }
     */
    public static void glPolygonStipple(MemorySegment mask) {
        var mh$ = glPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPolygonStipple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetPolygonStipple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static FunctionDescriptor glGetPolygonStipple$descriptor() {
        return glGetPolygonStipple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MethodHandle glGetPolygonStipple$handle() {
        return glGetPolygonStipple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static MemorySegment glGetPolygonStipple$address() {
        return glGetPolygonStipple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPolygonStipple(GLubyte *mask)
     * }
     */
    public static void glGetPolygonStipple(MemorySegment mask) {
        var mh$ = glGetPolygonStipple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPolygonStipple", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEdgeFlag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlag$descriptor() {
        return glEdgeFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MethodHandle glEdgeFlag$handle() {
        return glEdgeFlag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static MemorySegment glEdgeFlag$address() {
        return glEdgeFlag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlag(GLboolean flag)
     * }
     */
    public static void glEdgeFlag(byte flag) {
        var mh$ = glEdgeFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlag", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEdgeFlagv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static FunctionDescriptor glEdgeFlagv$descriptor() {
        return glEdgeFlagv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MethodHandle glEdgeFlagv$handle() {
        return glEdgeFlagv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static MemorySegment glEdgeFlagv$address() {
        return glEdgeFlagv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlagv(const GLboolean *flag)
     * }
     */
    public static void glEdgeFlagv(MemorySegment flag) {
        var mh$ = glEdgeFlagv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagv", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScissor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glScissor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glScissor$descriptor() {
        return glScissor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glScissor$handle() {
        return glScissor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glScissor$address() {
        return glScissor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glScissor(int x, int y, int width, int height) {
        var mh$ = glScissor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScissor", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glClipPlane$descriptor() {
        return glClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MethodHandle glClipPlane$handle() {
        return glClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static MemorySegment glClipPlane$address() {
        return glClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClipPlane(GLenum plane, const GLdouble *equation)
     * }
     */
    public static void glClipPlane(int plane, MemorySegment equation) {
        var mh$ = glClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetClipPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetClipPlane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static FunctionDescriptor glGetClipPlane$descriptor() {
        return glGetClipPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MethodHandle glGetClipPlane$handle() {
        return glGetClipPlane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static MemorySegment glGetClipPlane$address() {
        return glGetClipPlane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetClipPlane(GLenum plane, GLdouble *equation)
     * }
     */
    public static void glGetClipPlane(int plane, MemorySegment equation) {
        var mh$ = glGetClipPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetClipPlane", plane, equation);
            }
            mh$.invokeExact(plane, equation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDrawBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glDrawBuffer$descriptor() {
        return glDrawBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glDrawBuffer$handle() {
        return glDrawBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glDrawBuffer$address() {
        return glDrawBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawBuffer(GLenum mode)
     * }
     */
    public static void glDrawBuffer(int mode) {
        var mh$ = glDrawBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glReadBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static FunctionDescriptor glReadBuffer$descriptor() {
        return glReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static MethodHandle glReadBuffer$handle() {
        return glReadBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static MemorySegment glReadBuffer$address() {
        return glReadBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glReadBuffer(GLenum mode)
     * }
     */
    public static void glReadBuffer(int mode) {
        var mh$ = glReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadBuffer", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEnable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glEnable$descriptor() {
        return glEnable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static MethodHandle glEnable$handle() {
        return glEnable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static MemorySegment glEnable$address() {
        return glEnable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnable(GLenum cap)
     * }
     */
    public static void glEnable(int cap) {
        var mh$ = glEnable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static FunctionDescriptor glDisable$descriptor() {
        return glDisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static MethodHandle glDisable$handle() {
        return glDisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static MemorySegment glDisable$address() {
        return glDisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDisable(GLenum cap)
     * }
     */
    public static void glDisable(int cap) {
        var mh$ = glDisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisable", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_CHAR,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static FunctionDescriptor glIsEnabled$descriptor() {
        return glIsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MethodHandle glIsEnabled$handle() {
        return glIsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static MemorySegment glIsEnabled$address() {
        return glIsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsEnabled(GLenum cap)
     * }
     */
    public static byte glIsEnabled(int cap) {
        var mh$ = glIsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsEnabled", cap);
            }
            return (byte)mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEnableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum cap)
     * }
     */
    public static FunctionDescriptor glEnableClientState$descriptor() {
        return glEnableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum cap)
     * }
     */
    public static MethodHandle glEnableClientState$handle() {
        return glEnableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnableClientState(GLenum cap)
     * }
     */
    public static MemorySegment glEnableClientState$address() {
        return glEnableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnableClientState(GLenum cap)
     * }
     */
    public static void glEnableClientState(int cap) {
        var mh$ = glEnableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnableClientState", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDisableClientState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDisableClientState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum cap)
     * }
     */
    public static FunctionDescriptor glDisableClientState$descriptor() {
        return glDisableClientState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum cap)
     * }
     */
    public static MethodHandle glDisableClientState$handle() {
        return glDisableClientState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDisableClientState(GLenum cap)
     * }
     */
    public static MemorySegment glDisableClientState$address() {
        return glDisableClientState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDisableClientState(GLenum cap)
     * }
     */
    public static void glDisableClientState(int cap) {
        var mh$ = glDisableClientState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDisableClientState", cap);
            }
            mh$.invokeExact(cap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetBooleanv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetBooleanv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static FunctionDescriptor glGetBooleanv$descriptor() {
        return glGetBooleanv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MethodHandle glGetBooleanv$handle() {
        return glGetBooleanv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static MemorySegment glGetBooleanv$address() {
        return glGetBooleanv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetBooleanv(GLenum pname, GLboolean *params)
     * }
     */
    public static void glGetBooleanv(int pname, MemorySegment params) {
        var mh$ = glGetBooleanv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetBooleanv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetDoublev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetDoublev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetDoublev$descriptor() {
        return glGetDoublev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetDoublev$handle() {
        return glGetDoublev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetDoublev$address() {
        return glGetDoublev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetDoublev(GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetDoublev(int pname, MemorySegment params) {
        var mh$ = glGetDoublev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetDoublev", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetFloatv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetFloatv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetFloatv$descriptor() {
        return glGetFloatv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetFloatv$handle() {
        return glGetFloatv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetFloatv$address() {
        return glGetFloatv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetFloatv(GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetFloatv(int pname, MemorySegment params) {
        var mh$ = glGetFloatv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetFloatv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetIntegerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetIntegerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetIntegerv$descriptor() {
        return glGetIntegerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetIntegerv$handle() {
        return glGetIntegerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetIntegerv$address() {
        return glGetIntegerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetIntegerv(GLenum pname, GLint *params)
     * }
     */
    public static void glGetIntegerv(int pname, MemorySegment params) {
        var mh$ = glGetIntegerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetIntegerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPushAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushAttrib$descriptor() {
        return glPushAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushAttrib$handle() {
        return glPushAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushAttrib$address() {
        return glPushAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushAttrib(GLbitfield mask)
     * }
     */
    public static void glPushAttrib(int mask) {
        var mh$ = glPushAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPopAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static FunctionDescriptor glPopAttrib$descriptor() {
        return glPopAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static MethodHandle glPopAttrib$handle() {
        return glPopAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static MemorySegment glPopAttrib$address() {
        return glPopAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopAttrib()
     * }
     */
    public static void glPopAttrib() {
        var mh$ = glPopAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPushClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static FunctionDescriptor glPushClientAttrib$descriptor() {
        return glPushClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MethodHandle glPushClientAttrib$handle() {
        return glPushClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static MemorySegment glPushClientAttrib$address() {
        return glPushClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushClientAttrib(GLbitfield mask)
     * }
     */
    public static void glPushClientAttrib(int mask) {
        var mh$ = glPushClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushClientAttrib", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopClientAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPopClientAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static FunctionDescriptor glPopClientAttrib$descriptor() {
        return glPopClientAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static MethodHandle glPopClientAttrib$handle() {
        return glPopClientAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static MemorySegment glPopClientAttrib$address() {
        return glPopClientAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopClientAttrib()
     * }
     */
    public static void glPopClientAttrib() {
        var mh$ = glPopClientAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopClientAttrib");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRenderMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRenderMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glRenderMode$descriptor() {
        return glRenderMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static MethodHandle glRenderMode$handle() {
        return glRenderMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static MemorySegment glRenderMode$address() {
        return glRenderMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLint glRenderMode(GLenum mode)
     * }
     */
    public static int glRenderMode(int mode) {
        var mh$ = glRenderMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRenderMode", mode);
            }
            return (int)mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static FunctionDescriptor glGetError$descriptor() {
        return glGetError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static MethodHandle glGetError$handle() {
        return glGetError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static MemorySegment glGetError$address() {
        return glGetError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLenum glGetError()
     * }
     */
    public static int glGetError() {
        var mh$ = glGetError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static FunctionDescriptor glGetString$descriptor() {
        return glGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MethodHandle glGetString$handle() {
        return glGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString$address() {
        return glGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLubyte *glGetString(GLenum name)
     * }
     */
    public static MemorySegment glGetString(int name) {
        var mh$ = glGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetString", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glFinish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static FunctionDescriptor glFinish$descriptor() {
        return glFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static MethodHandle glFinish$handle() {
        return glFinish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static MemorySegment glFinish$address() {
        return glFinish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFinish()
     * }
     */
    public static void glFinish() {
        var mh$ = glFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFinish");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glFlush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static FunctionDescriptor glFlush$descriptor() {
        return glFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static MethodHandle glFlush$handle() {
        return glFlush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static MemorySegment glFlush$address() {
        return glFlush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFlush()
     * }
     */
    public static void glFlush() {
        var mh$ = glFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFlush");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glHint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glHint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static FunctionDescriptor glHint$descriptor() {
        return glHint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MethodHandle glHint$handle() {
        return glHint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static MemorySegment glHint$address() {
        return glHint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glHint(GLenum target, GLenum mode)
     * }
     */
    public static void glHint(int target, int mode) {
        var mh$ = glHint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glHint", target, mode);
            }
            mh$.invokeExact(target, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glClearDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static FunctionDescriptor glClearDepth$descriptor() {
        return glClearDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static MethodHandle glClearDepth$handle() {
        return glClearDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static MemorySegment glClearDepth$address() {
        return glClearDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearDepth(GLclampd depth)
     * }
     */
    public static void glClearDepth(double depth) {
        var mh$ = glClearDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearDepth", depth);
            }
            mh$.invokeExact(depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDepthFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static FunctionDescriptor glDepthFunc$descriptor() {
        return glDepthFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static MethodHandle glDepthFunc$handle() {
        return glDepthFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static MemorySegment glDepthFunc$address() {
        return glDepthFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthFunc(GLenum func)
     * }
     */
    public static void glDepthFunc(int func) {
        var mh$ = glDepthFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthFunc", func);
            }
            mh$.invokeExact(func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDepthMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static FunctionDescriptor glDepthMask$descriptor() {
        return glDepthMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static MethodHandle glDepthMask$handle() {
        return glDepthMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static MemorySegment glDepthMask$address() {
        return glDepthMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthMask(GLboolean flag)
     * }
     */
    public static void glDepthMask(byte flag) {
        var mh$ = glDepthMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthMask", flag);
            }
            mh$.invokeExact(flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDepthRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDepthRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd near_val, GLclampd far_val)
     * }
     */
    public static FunctionDescriptor glDepthRange$descriptor() {
        return glDepthRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd near_val, GLclampd far_val)
     * }
     */
    public static MethodHandle glDepthRange$handle() {
        return glDepthRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDepthRange(GLclampd near_val, GLclampd far_val)
     * }
     */
    public static MemorySegment glDepthRange$address() {
        return glDepthRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDepthRange(GLclampd near_val, GLclampd far_val)
     * }
     */
    public static void glDepthRange(double near_val, double far_val) {
        var mh$ = glDepthRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDepthRange", near_val, far_val);
            }
            mh$.invokeExact(near_val, far_val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glClearAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glClearAccum$descriptor() {
        return glClearAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glClearAccum$handle() {
        return glClearAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glClearAccum$address() {
        return glClearAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glClearAccum(float red, float green, float blue, float alpha) {
        var mh$ = glClearAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearAccum", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAccum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glAccum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static FunctionDescriptor glAccum$descriptor() {
        return glAccum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MethodHandle glAccum$handle() {
        return glAccum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static MemorySegment glAccum$address() {
        return glAccum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glAccum(GLenum op, GLfloat value)
     * }
     */
    public static void glAccum(int op, float value) {
        var mh$ = glAccum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAccum", op, value);
            }
            mh$.invokeExact(op, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMatrixMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMatrixMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static FunctionDescriptor glMatrixMode$descriptor() {
        return glMatrixMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static MethodHandle glMatrixMode$handle() {
        return glMatrixMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static MemorySegment glMatrixMode$address() {
        return glMatrixMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMatrixMode(GLenum mode)
     * }
     */
    public static void glMatrixMode(int mode) {
        var mh$ = glMatrixMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMatrixMode", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static FunctionDescriptor glOrtho$descriptor() {
        return glOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static MethodHandle glOrtho$handle() {
        return glOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static MemorySegment glOrtho$address() {
        return glOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static void glOrtho(double left, double right, double bottom, double top, double near_val, double far_val) {
        var mh$ = glOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glOrtho", left, right, bottom, top, near_val, far_val);
            }
            mh$.invokeExact(left, right, bottom, top, near_val, far_val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFrustum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glFrustum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static FunctionDescriptor glFrustum$descriptor() {
        return glFrustum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static MethodHandle glFrustum$handle() {
        return glFrustum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static MemorySegment glFrustum$address() {
        return glFrustum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near_val, GLdouble far_val)
     * }
     */
    public static void glFrustum(double left, double right, double bottom, double top, double near_val, double far_val) {
        var mh$ = glFrustum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFrustum", left, right, bottom, top, near_val, far_val);
            }
            mh$.invokeExact(left, right, bottom, top, near_val, far_val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glViewport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glViewport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glViewport$descriptor() {
        return glViewport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glViewport$handle() {
        return glViewport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glViewport$address() {
        return glViewport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glViewport(int x, int y, int width, int height) {
        var mh$ = glViewport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glViewport", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPushMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static FunctionDescriptor glPushMatrix$descriptor() {
        return glPushMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static MethodHandle glPushMatrix$handle() {
        return glPushMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static MemorySegment glPushMatrix$address() {
        return glPushMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushMatrix()
     * }
     */
    public static void glPushMatrix() {
        var mh$ = glPushMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPopMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static FunctionDescriptor glPopMatrix$descriptor() {
        return glPopMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static MethodHandle glPopMatrix$handle() {
        return glPopMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static MemorySegment glPopMatrix$address() {
        return glPopMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopMatrix()
     * }
     */
    public static void glPopMatrix() {
        var mh$ = glPopMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopMatrix");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLoadIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static FunctionDescriptor glLoadIdentity$descriptor() {
        return glLoadIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static MethodHandle glLoadIdentity$handle() {
        return glLoadIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static MemorySegment glLoadIdentity$address() {
        return glLoadIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadIdentity()
     * }
     */
    public static void glLoadIdentity() {
        var mh$ = glLoadIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadIdentity");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLoadMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixd$descriptor() {
        return glLoadMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glLoadMatrixd$handle() {
        return glLoadMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glLoadMatrixd$address() {
        return glLoadMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadMatrixd(const GLdouble *m)
     * }
     */
    public static void glLoadMatrixd(MemorySegment m) {
        var mh$ = glLoadMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLoadMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glLoadMatrixf$descriptor() {
        return glLoadMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glLoadMatrixf$handle() {
        return glLoadMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glLoadMatrixf$address() {
        return glLoadMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadMatrixf(const GLfloat *m)
     * }
     */
    public static void glLoadMatrixf(MemorySegment m) {
        var mh$ = glLoadMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixd$descriptor() {
        return glMultMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MethodHandle glMultMatrixd$handle() {
        return glMultMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static MemorySegment glMultMatrixd$address() {
        return glMultMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultMatrixd(const GLdouble *m)
     * }
     */
    public static void glMultMatrixd(MemorySegment m) {
        var mh$ = glMultMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static FunctionDescriptor glMultMatrixf$descriptor() {
        return glMultMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MethodHandle glMultMatrixf$handle() {
        return glMultMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static MemorySegment glMultMatrixf$address() {
        return glMultMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultMatrixf(const GLfloat *m)
     * }
     */
    public static void glMultMatrixf(MemorySegment m) {
        var mh$ = glMultMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRotated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRotated$descriptor() {
        return glRotated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRotated$handle() {
        return glRotated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRotated$address() {
        return glRotated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRotated(double angle, double x, double y, double z) {
        var mh$ = glRotated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotated", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRotatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRotatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRotatef$descriptor() {
        return glRotatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRotatef$handle() {
        return glRotatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRotatef$address() {
        return glRotatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRotatef(float angle, float x, float y, float z) {
        var mh$ = glRotatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRotatef", angle, x, y, z);
            }
            mh$.invokeExact(angle, x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScaled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glScaled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glScaled$descriptor() {
        return glScaled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glScaled$handle() {
        return glScaled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glScaled$address() {
        return glScaled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScaled(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glScaled(double x, double y, double z) {
        var mh$ = glScaled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScaled", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glScalef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glScalef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glScalef$descriptor() {
        return glScalef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glScalef$handle() {
        return glScalef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glScalef$address() {
        return glScalef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glScalef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glScalef(float x, float y, float z) {
        var mh$ = glScalef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glScalef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTranslated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glTranslated$descriptor() {
        return glTranslated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glTranslated$handle() {
        return glTranslated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glTranslated$address() {
        return glTranslated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTranslated(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glTranslated(double x, double y, double z) {
        var mh$ = glTranslated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslated", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTranslatef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTranslatef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glTranslatef$descriptor() {
        return glTranslatef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glTranslatef$handle() {
        return glTranslatef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glTranslatef$address() {
        return glTranslatef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTranslatef(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glTranslatef(float x, float y, float z) {
        var mh$ = glTranslatef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTranslatef", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_CHAR,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIsList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static FunctionDescriptor glIsList$descriptor() {
        return glIsList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static MethodHandle glIsList$handle() {
        return glIsList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static MemorySegment glIsList$address() {
        return glIsList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsList(GLuint list)
     * }
     */
    public static byte glIsList(int list) {
        var mh$ = glIsList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsList", list);
            }
            return (byte)mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDeleteLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static FunctionDescriptor glDeleteLists$descriptor() {
        return glDeleteLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MethodHandle glDeleteLists$handle() {
        return glDeleteLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static MemorySegment glDeleteLists$address() {
        return glDeleteLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDeleteLists(GLuint list, GLsizei range)
     * }
     */
    public static void glDeleteLists(int list, int range) {
        var mh$ = glDeleteLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteLists", list, range);
            }
            mh$.invokeExact(list, range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGenLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static FunctionDescriptor glGenLists$descriptor() {
        return glGenLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static MethodHandle glGenLists$handle() {
        return glGenLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static MemorySegment glGenLists$address() {
        return glGenLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLuint glGenLists(GLsizei range)
     * }
     */
    public static int glGenLists(int range) {
        var mh$ = glGenLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenLists", range);
            }
            return (int)mh$.invokeExact(range);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNewList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNewList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static FunctionDescriptor glNewList$descriptor() {
        return glNewList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MethodHandle glNewList$handle() {
        return glNewList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static MemorySegment glNewList$address() {
        return glNewList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNewList(GLuint list, GLenum mode)
     * }
     */
    public static void glNewList(int list, int mode) {
        var mh$ = glNewList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNewList", list, mode);
            }
            mh$.invokeExact(list, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEndList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEndList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static FunctionDescriptor glEndList$descriptor() {
        return glEndList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static MethodHandle glEndList$handle() {
        return glEndList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static MemorySegment glEndList$address() {
        return glEndList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEndList()
     * }
     */
    public static void glEndList() {
        var mh$ = glEndList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEndList");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCallList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static FunctionDescriptor glCallList$descriptor() {
        return glCallList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static MethodHandle glCallList$handle() {
        return glCallList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static MemorySegment glCallList$address() {
        return glCallList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCallList(GLuint list)
     * }
     */
    public static void glCallList(int list) {
        var mh$ = glCallList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallList", list);
            }
            mh$.invokeExact(list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCallLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCallLists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static FunctionDescriptor glCallLists$descriptor() {
        return glCallLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MethodHandle glCallLists$handle() {
        return glCallLists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static MemorySegment glCallLists$address() {
        return glCallLists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
     * }
     */
    public static void glCallLists(int n, int type, MemorySegment lists) {
        var mh$ = glCallLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCallLists", n, type, lists);
            }
            mh$.invokeExact(n, type, lists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glListBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glListBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static FunctionDescriptor glListBase$descriptor() {
        return glListBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static MethodHandle glListBase$handle() {
        return glListBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static MemorySegment glListBase$address() {
        return glListBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glListBase(GLuint base)
     * }
     */
    public static void glListBase(int base) {
        var mh$ = glListBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glListBase", base);
            }
            mh$.invokeExact(base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBegin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glBegin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBegin$descriptor() {
        return glBegin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static MethodHandle glBegin$handle() {
        return glBegin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static MemorySegment glBegin$address() {
        return glBegin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBegin(GLenum mode)
     * }
     */
    public static void glBegin(int mode) {
        var mh$ = glBegin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBegin", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static FunctionDescriptor glEnd$descriptor() {
        return glEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static MethodHandle glEnd$handle() {
        return glEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static MemorySegment glEnd$address() {
        return glEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEnd()
     * }
     */
    public static void glEnd() {
        var mh$ = glEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEnd");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glVertex2d$descriptor() {
        return glVertex2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glVertex2d$handle() {
        return glVertex2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glVertex2d$address() {
        return glVertex2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glVertex2d(double x, double y) {
        var mh$ = glVertex2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glVertex2f$descriptor() {
        return glVertex2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glVertex2f$handle() {
        return glVertex2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glVertex2f$address() {
        return glVertex2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glVertex2f(float x, float y) {
        var mh$ = glVertex2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glVertex2i$descriptor() {
        return glVertex2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glVertex2i$handle() {
        return glVertex2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glVertex2i$address() {
        return glVertex2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2i(GLint x, GLint y)
     * }
     */
    public static void glVertex2i(int x, int y) {
        var mh$ = glVertex2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glVertex2s$descriptor() {
        return glVertex2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glVertex2s$handle() {
        return glVertex2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glVertex2s$address() {
        return glVertex2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2s(GLshort x, GLshort y)
     * }
     */
    public static void glVertex2s(short x, short y) {
        var mh$ = glVertex2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glVertex3d$descriptor() {
        return glVertex3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glVertex3d$handle() {
        return glVertex3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glVertex3d$address() {
        return glVertex3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glVertex3d(double x, double y, double z) {
        var mh$ = glVertex3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glVertex3f$descriptor() {
        return glVertex3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glVertex3f$handle() {
        return glVertex3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glVertex3f$address() {
        return glVertex3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glVertex3f(float x, float y, float z) {
        var mh$ = glVertex3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glVertex3i$descriptor() {
        return glVertex3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glVertex3i$handle() {
        return glVertex3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glVertex3i$address() {
        return glVertex3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glVertex3i(int x, int y, int z) {
        var mh$ = glVertex3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glVertex3s$descriptor() {
        return glVertex3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glVertex3s$handle() {
        return glVertex3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glVertex3s$address() {
        return glVertex3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glVertex3s(short x, short y, short z) {
        var mh$ = glVertex3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glVertex4d$descriptor() {
        return glVertex4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glVertex4d$handle() {
        return glVertex4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glVertex4d$address() {
        return glVertex4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glVertex4d(double x, double y, double z, double w) {
        var mh$ = glVertex4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glVertex4f$descriptor() {
        return glVertex4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glVertex4f$handle() {
        return glVertex4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glVertex4f$address() {
        return glVertex4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glVertex4f(float x, float y, float z, float w) {
        var mh$ = glVertex4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glVertex4i$descriptor() {
        return glVertex4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glVertex4i$handle() {
        return glVertex4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glVertex4i$address() {
        return glVertex4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glVertex4i(int x, int y, int z, int w) {
        var mh$ = glVertex4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glVertex4s$descriptor() {
        return glVertex4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glVertex4s$handle() {
        return glVertex4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glVertex4s$address() {
        return glVertex4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glVertex4s(short x, short y, short z, short w) {
        var mh$ = glVertex4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex2dv$descriptor() {
        return glVertex2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex2dv$handle() {
        return glVertex2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex2dv$address() {
        return glVertex2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2dv(const GLdouble *v)
     * }
     */
    public static void glVertex2dv(MemorySegment v) {
        var mh$ = glVertex2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex2fv$descriptor() {
        return glVertex2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex2fv$handle() {
        return glVertex2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex2fv$address() {
        return glVertex2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2fv(const GLfloat *v)
     * }
     */
    public static void glVertex2fv(MemorySegment v) {
        var mh$ = glVertex2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex2iv$descriptor() {
        return glVertex2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex2iv$handle() {
        return glVertex2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex2iv$address() {
        return glVertex2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2iv(const GLint *v)
     * }
     */
    public static void glVertex2iv(MemorySegment v) {
        var mh$ = glVertex2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex2sv$descriptor() {
        return glVertex2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex2sv$handle() {
        return glVertex2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex2sv$address() {
        return glVertex2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex2sv(const GLshort *v)
     * }
     */
    public static void glVertex2sv(MemorySegment v) {
        var mh$ = glVertex2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex3dv$descriptor() {
        return glVertex3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex3dv$handle() {
        return glVertex3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex3dv$address() {
        return glVertex3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3dv(const GLdouble *v)
     * }
     */
    public static void glVertex3dv(MemorySegment v) {
        var mh$ = glVertex3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex3fv$descriptor() {
        return glVertex3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex3fv$handle() {
        return glVertex3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex3fv$address() {
        return glVertex3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3fv(const GLfloat *v)
     * }
     */
    public static void glVertex3fv(MemorySegment v) {
        var mh$ = glVertex3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex3iv$descriptor() {
        return glVertex3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex3iv$handle() {
        return glVertex3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex3iv$address() {
        return glVertex3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3iv(const GLint *v)
     * }
     */
    public static void glVertex3iv(MemorySegment v) {
        var mh$ = glVertex3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex3sv$descriptor() {
        return glVertex3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex3sv$handle() {
        return glVertex3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex3sv$address() {
        return glVertex3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex3sv(const GLshort *v)
     * }
     */
    public static void glVertex3sv(MemorySegment v) {
        var mh$ = glVertex3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glVertex4dv$descriptor() {
        return glVertex4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glVertex4dv$handle() {
        return glVertex4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glVertex4dv$address() {
        return glVertex4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4dv(const GLdouble *v)
     * }
     */
    public static void glVertex4dv(MemorySegment v) {
        var mh$ = glVertex4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glVertex4fv$descriptor() {
        return glVertex4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glVertex4fv$handle() {
        return glVertex4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glVertex4fv$address() {
        return glVertex4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4fv(const GLfloat *v)
     * }
     */
    public static void glVertex4fv(MemorySegment v) {
        var mh$ = glVertex4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glVertex4iv$descriptor() {
        return glVertex4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static MethodHandle glVertex4iv$handle() {
        return glVertex4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static MemorySegment glVertex4iv$address() {
        return glVertex4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4iv(const GLint *v)
     * }
     */
    public static void glVertex4iv(MemorySegment v) {
        var mh$ = glVertex4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertex4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertex4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glVertex4sv$descriptor() {
        return glVertex4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glVertex4sv$handle() {
        return glVertex4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glVertex4sv$address() {
        return glVertex4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertex4sv(const GLshort *v)
     * }
     */
    public static void glVertex4sv(MemorySegment v) {
        var mh$ = glVertex4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertex4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static FunctionDescriptor glNormal3b$descriptor() {
        return glNormal3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MethodHandle glNormal3b$handle() {
        return glNormal3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static MemorySegment glNormal3b$address() {
        return glNormal3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
     * }
     */
    public static void glNormal3b(byte nx, byte ny, byte nz) {
        var mh$ = glNormal3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3b", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static FunctionDescriptor glNormal3d$descriptor() {
        return glNormal3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MethodHandle glNormal3d$handle() {
        return glNormal3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static MemorySegment glNormal3d$address() {
        return glNormal3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
     * }
     */
    public static void glNormal3d(double nx, double ny, double nz) {
        var mh$ = glNormal3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3d", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static FunctionDescriptor glNormal3f$descriptor() {
        return glNormal3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MethodHandle glNormal3f$handle() {
        return glNormal3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static MemorySegment glNormal3f$address() {
        return glNormal3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
     * }
     */
    public static void glNormal3f(float nx, float ny, float nz) {
        var mh$ = glNormal3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3f", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static FunctionDescriptor glNormal3i$descriptor() {
        return glNormal3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MethodHandle glNormal3i$handle() {
        return glNormal3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static MemorySegment glNormal3i$address() {
        return glNormal3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3i(GLint nx, GLint ny, GLint nz)
     * }
     */
    public static void glNormal3i(int nx, int ny, int nz) {
        var mh$ = glNormal3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3i", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static FunctionDescriptor glNormal3s$descriptor() {
        return glNormal3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MethodHandle glNormal3s$handle() {
        return glNormal3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static MemorySegment glNormal3s$address() {
        return glNormal3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3s(GLshort nx, GLshort ny, GLshort nz)
     * }
     */
    public static void glNormal3s(short nx, short ny, short nz) {
        var mh$ = glNormal3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3s", nx, ny, nz);
            }
            mh$.invokeExact(nx, ny, nz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glNormal3bv$descriptor() {
        return glNormal3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glNormal3bv$handle() {
        return glNormal3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glNormal3bv$address() {
        return glNormal3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3bv(const GLbyte *v)
     * }
     */
    public static void glNormal3bv(MemorySegment v) {
        var mh$ = glNormal3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glNormal3dv$descriptor() {
        return glNormal3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glNormal3dv$handle() {
        return glNormal3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glNormal3dv$address() {
        return glNormal3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3dv(const GLdouble *v)
     * }
     */
    public static void glNormal3dv(MemorySegment v) {
        var mh$ = glNormal3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glNormal3fv$descriptor() {
        return glNormal3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glNormal3fv$handle() {
        return glNormal3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glNormal3fv$address() {
        return glNormal3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3fv(const GLfloat *v)
     * }
     */
    public static void glNormal3fv(MemorySegment v) {
        var mh$ = glNormal3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glNormal3iv$descriptor() {
        return glNormal3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MethodHandle glNormal3iv$handle() {
        return glNormal3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static MemorySegment glNormal3iv$address() {
        return glNormal3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3iv(const GLint *v)
     * }
     */
    public static void glNormal3iv(MemorySegment v) {
        var mh$ = glNormal3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormal3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormal3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glNormal3sv$descriptor() {
        return glNormal3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glNormal3sv$handle() {
        return glNormal3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glNormal3sv$address() {
        return glNormal3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormal3sv(const GLshort *v)
     * }
     */
    public static void glNormal3sv(MemorySegment v) {
        var mh$ = glNormal3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormal3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static FunctionDescriptor glIndexd$descriptor() {
        return glIndexd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MethodHandle glIndexd$handle() {
        return glIndexd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static MemorySegment glIndexd$address() {
        return glIndexd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexd(GLdouble c)
     * }
     */
    public static void glIndexd(double c) {
        var mh$ = glIndexd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexd", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static FunctionDescriptor glIndexf$descriptor() {
        return glIndexf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MethodHandle glIndexf$handle() {
        return glIndexf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static MemorySegment glIndexf$address() {
        return glIndexf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexf(GLfloat c)
     * }
     */
    public static void glIndexf(float c) {
        var mh$ = glIndexf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexf", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static FunctionDescriptor glIndexi$descriptor() {
        return glIndexi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MethodHandle glIndexi$handle() {
        return glIndexi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static MemorySegment glIndexi$address() {
        return glIndexi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexi(GLint c)
     * }
     */
    public static void glIndexi(int c) {
        var mh$ = glIndexi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexi", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static FunctionDescriptor glIndexs$descriptor() {
        return glIndexs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MethodHandle glIndexs$handle() {
        return glIndexs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static MemorySegment glIndexs$address() {
        return glIndexs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexs(GLshort c)
     * }
     */
    public static void glIndexs(short c) {
        var mh$ = glIndexs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexs", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static FunctionDescriptor glIndexub$descriptor() {
        return glIndexub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MethodHandle glIndexub$handle() {
        return glIndexub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static MemorySegment glIndexub$address() {
        return glIndexub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexub(GLubyte c)
     * }
     */
    public static void glIndexub(byte c) {
        var mh$ = glIndexub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexub", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static FunctionDescriptor glIndexdv$descriptor() {
        return glIndexdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MethodHandle glIndexdv$handle() {
        return glIndexdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static MemorySegment glIndexdv$address() {
        return glIndexdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexdv(const GLdouble *c)
     * }
     */
    public static void glIndexdv(MemorySegment c) {
        var mh$ = glIndexdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexdv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static FunctionDescriptor glIndexfv$descriptor() {
        return glIndexfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MethodHandle glIndexfv$handle() {
        return glIndexfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static MemorySegment glIndexfv$address() {
        return glIndexfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexfv(const GLfloat *c)
     * }
     */
    public static void glIndexfv(MemorySegment c) {
        var mh$ = glIndexfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexfv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static FunctionDescriptor glIndexiv$descriptor() {
        return glIndexiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MethodHandle glIndexiv$handle() {
        return glIndexiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static MemorySegment glIndexiv$address() {
        return glIndexiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexiv(const GLint *c)
     * }
     */
    public static void glIndexiv(MemorySegment c) {
        var mh$ = glIndexiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexiv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static FunctionDescriptor glIndexsv$descriptor() {
        return glIndexsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MethodHandle glIndexsv$handle() {
        return glIndexsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static MemorySegment glIndexsv$address() {
        return glIndexsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexsv(const GLshort *c)
     * }
     */
    public static void glIndexsv(MemorySegment c) {
        var mh$ = glIndexsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexsv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static FunctionDescriptor glIndexubv$descriptor() {
        return glIndexubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MethodHandle glIndexubv$handle() {
        return glIndexubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static MemorySegment glIndexubv$address() {
        return glIndexubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexubv(const GLubyte *c)
     * }
     */
    public static void glIndexubv(MemorySegment c) {
        var mh$ = glIndexubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexubv", c);
            }
            mh$.invokeExact(c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static FunctionDescriptor glColor3b$descriptor() {
        return glColor3b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MethodHandle glColor3b$handle() {
        return glColor3b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static MemorySegment glColor3b$address() {
        return glColor3b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3b(GLbyte red, GLbyte green, GLbyte blue)
     * }
     */
    public static void glColor3b(byte red, byte green, byte blue) {
        var mh$ = glColor3b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3b", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static FunctionDescriptor glColor3d$descriptor() {
        return glColor3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MethodHandle glColor3d$handle() {
        return glColor3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static MemorySegment glColor3d$address() {
        return glColor3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3d(GLdouble red, GLdouble green, GLdouble blue)
     * }
     */
    public static void glColor3d(double red, double green, double blue) {
        var mh$ = glColor3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3d", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static FunctionDescriptor glColor3f$descriptor() {
        return glColor3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MethodHandle glColor3f$handle() {
        return glColor3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static MemorySegment glColor3f$address() {
        return glColor3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3f(GLfloat red, GLfloat green, GLfloat blue)
     * }
     */
    public static void glColor3f(float red, float green, float blue) {
        var mh$ = glColor3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3f", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static FunctionDescriptor glColor3i$descriptor() {
        return glColor3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MethodHandle glColor3i$handle() {
        return glColor3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static MemorySegment glColor3i$address() {
        return glColor3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3i(GLint red, GLint green, GLint blue)
     * }
     */
    public static void glColor3i(int red, int green, int blue) {
        var mh$ = glColor3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3i", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static FunctionDescriptor glColor3s$descriptor() {
        return glColor3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MethodHandle glColor3s$handle() {
        return glColor3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static MemorySegment glColor3s$address() {
        return glColor3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3s(GLshort red, GLshort green, GLshort blue)
     * }
     */
    public static void glColor3s(short red, short green, short blue) {
        var mh$ = glColor3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3s", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static FunctionDescriptor glColor3ub$descriptor() {
        return glColor3ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MethodHandle glColor3ub$handle() {
        return glColor3ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static MemorySegment glColor3ub$address() {
        return glColor3ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
     * }
     */
    public static void glColor3ub(byte red, byte green, byte blue) {
        var mh$ = glColor3ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ub", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static FunctionDescriptor glColor3ui$descriptor() {
        return glColor3ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MethodHandle glColor3ui$handle() {
        return glColor3ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static MemorySegment glColor3ui$address() {
        return glColor3ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ui(GLuint red, GLuint green, GLuint blue)
     * }
     */
    public static void glColor3ui(int red, int green, int blue) {
        var mh$ = glColor3ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ui", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static FunctionDescriptor glColor3us$descriptor() {
        return glColor3us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MethodHandle glColor3us$handle() {
        return glColor3us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static MemorySegment glColor3us$address() {
        return glColor3us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3us(GLushort red, GLushort green, GLushort blue)
     * }
     */
    public static void glColor3us(short red, short green, short blue) {
        var mh$ = glColor3us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3us", red, green, blue);
            }
            mh$.invokeExact(red, green, blue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4b$descriptor() {
        return glColor4b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MethodHandle glColor4b$handle() {
        return glColor4b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static MemorySegment glColor4b$address() {
        return glColor4b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
     * }
     */
    public static void glColor4b(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4b", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static FunctionDescriptor glColor4d$descriptor() {
        return glColor4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MethodHandle glColor4d$handle() {
        return glColor4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static MemorySegment glColor4d$address() {
        return glColor4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
     * }
     */
    public static void glColor4d(double red, double green, double blue, double alpha) {
        var mh$ = glColor4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4d", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static FunctionDescriptor glColor4f$descriptor() {
        return glColor4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MethodHandle glColor4f$handle() {
        return glColor4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static MemorySegment glColor4f$address() {
        return glColor4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
     * }
     */
    public static void glColor4f(float red, float green, float blue, float alpha) {
        var mh$ = glColor4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4f", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static FunctionDescriptor glColor4i$descriptor() {
        return glColor4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MethodHandle glColor4i$handle() {
        return glColor4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static MemorySegment glColor4i$address() {
        return glColor4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
     * }
     */
    public static void glColor4i(int red, int green, int blue, int alpha) {
        var mh$ = glColor4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4i", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static FunctionDescriptor glColor4s$descriptor() {
        return glColor4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MethodHandle glColor4s$handle() {
        return glColor4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static MemorySegment glColor4s$address() {
        return glColor4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
     * }
     */
    public static void glColor4s(short red, short green, short blue, short alpha) {
        var mh$ = glColor4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4s", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR,
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4ub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static FunctionDescriptor glColor4ub$descriptor() {
        return glColor4ub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MethodHandle glColor4ub$handle() {
        return glColor4ub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static MemorySegment glColor4ub$address() {
        return glColor4ub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
     * }
     */
    public static void glColor4ub(byte red, byte green, byte blue, byte alpha) {
        var mh$ = glColor4ub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ub", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static FunctionDescriptor glColor4ui$descriptor() {
        return glColor4ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MethodHandle glColor4ui$handle() {
        return glColor4ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static MemorySegment glColor4ui$address() {
        return glColor4ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
     * }
     */
    public static void glColor4ui(int red, int green, int blue, int alpha) {
        var mh$ = glColor4ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ui", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4us {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4us");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static FunctionDescriptor glColor4us$descriptor() {
        return glColor4us.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MethodHandle glColor4us$handle() {
        return glColor4us.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static MemorySegment glColor4us$address() {
        return glColor4us.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
     * }
     */
    public static void glColor4us(short red, short green, short blue, short alpha) {
        var mh$ = glColor4us.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4us", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor3bv$descriptor() {
        return glColor3bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor3bv$handle() {
        return glColor3bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor3bv$address() {
        return glColor3bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3bv(const GLbyte *v)
     * }
     */
    public static void glColor3bv(MemorySegment v) {
        var mh$ = glColor3bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor3dv$descriptor() {
        return glColor3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor3dv$handle() {
        return glColor3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor3dv$address() {
        return glColor3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3dv(const GLdouble *v)
     * }
     */
    public static void glColor3dv(MemorySegment v) {
        var mh$ = glColor3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor3fv$descriptor() {
        return glColor3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor3fv$handle() {
        return glColor3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor3fv$address() {
        return glColor3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3fv(const GLfloat *v)
     * }
     */
    public static void glColor3fv(MemorySegment v) {
        var mh$ = glColor3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor3iv$descriptor() {
        return glColor3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor3iv$handle() {
        return glColor3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor3iv$address() {
        return glColor3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3iv(const GLint *v)
     * }
     */
    public static void glColor3iv(MemorySegment v) {
        var mh$ = glColor3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor3sv$descriptor() {
        return glColor3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor3sv$handle() {
        return glColor3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor3sv$address() {
        return glColor3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3sv(const GLshort *v)
     * }
     */
    public static void glColor3sv(MemorySegment v) {
        var mh$ = glColor3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor3ubv$descriptor() {
        return glColor3ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor3ubv$handle() {
        return glColor3ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor3ubv$address() {
        return glColor3ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3ubv(const GLubyte *v)
     * }
     */
    public static void glColor3ubv(MemorySegment v) {
        var mh$ = glColor3ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor3uiv$descriptor() {
        return glColor3uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor3uiv$handle() {
        return glColor3uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor3uiv$address() {
        return glColor3uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3uiv(const GLuint *v)
     * }
     */
    public static void glColor3uiv(MemorySegment v) {
        var mh$ = glColor3uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor3usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor3usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor3usv$descriptor() {
        return glColor3usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor3usv$handle() {
        return glColor3usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor3usv$address() {
        return glColor3usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor3usv(const GLushort *v)
     * }
     */
    public static void glColor3usv(MemorySegment v) {
        var mh$ = glColor3usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor3usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4bv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4bv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static FunctionDescriptor glColor4bv$descriptor() {
        return glColor4bv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MethodHandle glColor4bv$handle() {
        return glColor4bv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static MemorySegment glColor4bv$address() {
        return glColor4bv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4bv(const GLbyte *v)
     * }
     */
    public static void glColor4bv(MemorySegment v) {
        var mh$ = glColor4bv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4bv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glColor4dv$descriptor() {
        return glColor4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glColor4dv$handle() {
        return glColor4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glColor4dv$address() {
        return glColor4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4dv(const GLdouble *v)
     * }
     */
    public static void glColor4dv(MemorySegment v) {
        var mh$ = glColor4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glColor4fv$descriptor() {
        return glColor4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glColor4fv$handle() {
        return glColor4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glColor4fv$address() {
        return glColor4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4fv(const GLfloat *v)
     * }
     */
    public static void glColor4fv(MemorySegment v) {
        var mh$ = glColor4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glColor4iv$descriptor() {
        return glColor4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MethodHandle glColor4iv$handle() {
        return glColor4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static MemorySegment glColor4iv$address() {
        return glColor4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4iv(const GLint *v)
     * }
     */
    public static void glColor4iv(MemorySegment v) {
        var mh$ = glColor4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glColor4sv$descriptor() {
        return glColor4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glColor4sv$handle() {
        return glColor4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glColor4sv$address() {
        return glColor4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4sv(const GLshort *v)
     * }
     */
    public static void glColor4sv(MemorySegment v) {
        var mh$ = glColor4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4ubv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4ubv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static FunctionDescriptor glColor4ubv$descriptor() {
        return glColor4ubv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MethodHandle glColor4ubv$handle() {
        return glColor4ubv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static MemorySegment glColor4ubv$address() {
        return glColor4ubv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4ubv(const GLubyte *v)
     * }
     */
    public static void glColor4ubv(MemorySegment v) {
        var mh$ = glColor4ubv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4ubv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4uiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4uiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static FunctionDescriptor glColor4uiv$descriptor() {
        return glColor4uiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MethodHandle glColor4uiv$handle() {
        return glColor4uiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static MemorySegment glColor4uiv$address() {
        return glColor4uiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4uiv(const GLuint *v)
     * }
     */
    public static void glColor4uiv(MemorySegment v) {
        var mh$ = glColor4uiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4uiv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColor4usv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColor4usv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static FunctionDescriptor glColor4usv$descriptor() {
        return glColor4usv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MethodHandle glColor4usv$handle() {
        return glColor4usv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static MemorySegment glColor4usv$address() {
        return glColor4usv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColor4usv(const GLushort *v)
     * }
     */
    public static void glColor4usv(MemorySegment v) {
        var mh$ = glColor4usv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColor4usv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static FunctionDescriptor glTexCoord1d$descriptor() {
        return glTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MethodHandle glTexCoord1d$handle() {
        return glTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static MemorySegment glTexCoord1d$address() {
        return glTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1d(GLdouble s)
     * }
     */
    public static void glTexCoord1d(double s) {
        var mh$ = glTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1d", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static FunctionDescriptor glTexCoord1f$descriptor() {
        return glTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MethodHandle glTexCoord1f$handle() {
        return glTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static MemorySegment glTexCoord1f$address() {
        return glTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1f(GLfloat s)
     * }
     */
    public static void glTexCoord1f(float s) {
        var mh$ = glTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1f", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static FunctionDescriptor glTexCoord1i$descriptor() {
        return glTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MethodHandle glTexCoord1i$handle() {
        return glTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static MemorySegment glTexCoord1i$address() {
        return glTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1i(GLint s)
     * }
     */
    public static void glTexCoord1i(int s) {
        var mh$ = glTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1i", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static FunctionDescriptor glTexCoord1s$descriptor() {
        return glTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MethodHandle glTexCoord1s$handle() {
        return glTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static MemorySegment glTexCoord1s$address() {
        return glTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1s(GLshort s)
     * }
     */
    public static void glTexCoord1s(short s) {
        var mh$ = glTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1s", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glTexCoord2d$descriptor() {
        return glTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glTexCoord2d$handle() {
        return glTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glTexCoord2d$address() {
        return glTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2d(GLdouble s, GLdouble t)
     * }
     */
    public static void glTexCoord2d(double s, double t) {
        var mh$ = glTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2d", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glTexCoord2f$descriptor() {
        return glTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glTexCoord2f$handle() {
        return glTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glTexCoord2f$address() {
        return glTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2f(GLfloat s, GLfloat t)
     * }
     */
    public static void glTexCoord2f(float s, float t) {
        var mh$ = glTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2f", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glTexCoord2i$descriptor() {
        return glTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MethodHandle glTexCoord2i$handle() {
        return glTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static MemorySegment glTexCoord2i$address() {
        return glTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2i(GLint s, GLint t)
     * }
     */
    public static void glTexCoord2i(int s, int t) {
        var mh$ = glTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2i", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glTexCoord2s$descriptor() {
        return glTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glTexCoord2s$handle() {
        return glTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glTexCoord2s$address() {
        return glTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2s(GLshort s, GLshort t)
     * }
     */
    public static void glTexCoord2s(short s, short t) {
        var mh$ = glTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2s", s, t);
            }
            mh$.invokeExact(s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glTexCoord3d$descriptor() {
        return glTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glTexCoord3d$handle() {
        return glTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glTexCoord3d$address() {
        return glTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glTexCoord3d(double s, double t, double r) {
        var mh$ = glTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3d", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glTexCoord3f$descriptor() {
        return glTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glTexCoord3f$handle() {
        return glTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glTexCoord3f$address() {
        return glTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glTexCoord3f(float s, float t, float r) {
        var mh$ = glTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3f", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glTexCoord3i$descriptor() {
        return glTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glTexCoord3i$handle() {
        return glTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glTexCoord3i$address() {
        return glTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3i(GLint s, GLint t, GLint r)
     * }
     */
    public static void glTexCoord3i(int s, int t, int r) {
        var mh$ = glTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3i", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glTexCoord3s$descriptor() {
        return glTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glTexCoord3s$handle() {
        return glTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glTexCoord3s$address() {
        return glTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3s(GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glTexCoord3s(short s, short t, short r) {
        var mh$ = glTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3s", s, t, r);
            }
            mh$.invokeExact(s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glTexCoord4d$descriptor() {
        return glTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glTexCoord4d$handle() {
        return glTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glTexCoord4d$address() {
        return glTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glTexCoord4d(double s, double t, double r, double q) {
        var mh$ = glTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4d", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glTexCoord4f$descriptor() {
        return glTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glTexCoord4f$handle() {
        return glTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glTexCoord4f$address() {
        return glTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glTexCoord4f(float s, float t, float r, float q) {
        var mh$ = glTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4f", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glTexCoord4i$descriptor() {
        return glTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glTexCoord4i$handle() {
        return glTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glTexCoord4i$address() {
        return glTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glTexCoord4i(int s, int t, int r, int q) {
        var mh$ = glTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4i", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glTexCoord4s$descriptor() {
        return glTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glTexCoord4s$handle() {
        return glTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glTexCoord4s$address() {
        return glTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glTexCoord4s(short s, short t, short r, short q) {
        var mh$ = glTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4s", s, t, r, q);
            }
            mh$.invokeExact(s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1dv$descriptor() {
        return glTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord1dv$handle() {
        return glTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord1dv$address() {
        return glTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord1dv(MemorySegment v) {
        var mh$ = glTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1fv$descriptor() {
        return glTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord1fv$handle() {
        return glTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord1fv$address() {
        return glTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord1fv(MemorySegment v) {
        var mh$ = glTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1iv$descriptor() {
        return glTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord1iv$handle() {
        return glTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord1iv$address() {
        return glTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1iv(const GLint *v)
     * }
     */
    public static void glTexCoord1iv(MemorySegment v) {
        var mh$ = glTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord1sv$descriptor() {
        return glTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord1sv$handle() {
        return glTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord1sv$address() {
        return glTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord1sv(const GLshort *v)
     * }
     */
    public static void glTexCoord1sv(MemorySegment v) {
        var mh$ = glTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord1sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2dv$descriptor() {
        return glTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord2dv$handle() {
        return glTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord2dv$address() {
        return glTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord2dv(MemorySegment v) {
        var mh$ = glTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2fv$descriptor() {
        return glTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord2fv$handle() {
        return glTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord2fv$address() {
        return glTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord2fv(MemorySegment v) {
        var mh$ = glTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2iv$descriptor() {
        return glTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord2iv$handle() {
        return glTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord2iv$address() {
        return glTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2iv(const GLint *v)
     * }
     */
    public static void glTexCoord2iv(MemorySegment v) {
        var mh$ = glTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord2sv$descriptor() {
        return glTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord2sv$handle() {
        return glTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord2sv$address() {
        return glTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord2sv(const GLshort *v)
     * }
     */
    public static void glTexCoord2sv(MemorySegment v) {
        var mh$ = glTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3dv$descriptor() {
        return glTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord3dv$handle() {
        return glTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord3dv$address() {
        return glTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord3dv(MemorySegment v) {
        var mh$ = glTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3fv$descriptor() {
        return glTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord3fv$handle() {
        return glTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord3fv$address() {
        return glTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord3fv(MemorySegment v) {
        var mh$ = glTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3iv$descriptor() {
        return glTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord3iv$handle() {
        return glTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord3iv$address() {
        return glTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3iv(const GLint *v)
     * }
     */
    public static void glTexCoord3iv(MemorySegment v) {
        var mh$ = glTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord3sv$descriptor() {
        return glTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord3sv$handle() {
        return glTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord3sv$address() {
        return glTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord3sv(const GLshort *v)
     * }
     */
    public static void glTexCoord3sv(MemorySegment v) {
        var mh$ = glTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4dv$descriptor() {
        return glTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glTexCoord4dv$handle() {
        return glTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glTexCoord4dv$address() {
        return glTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4dv(const GLdouble *v)
     * }
     */
    public static void glTexCoord4dv(MemorySegment v) {
        var mh$ = glTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4fv$descriptor() {
        return glTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glTexCoord4fv$handle() {
        return glTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glTexCoord4fv$address() {
        return glTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4fv(const GLfloat *v)
     * }
     */
    public static void glTexCoord4fv(MemorySegment v) {
        var mh$ = glTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4iv$descriptor() {
        return glTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MethodHandle glTexCoord4iv$handle() {
        return glTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static MemorySegment glTexCoord4iv$address() {
        return glTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4iv(const GLint *v)
     * }
     */
    public static void glTexCoord4iv(MemorySegment v) {
        var mh$ = glTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glTexCoord4sv$descriptor() {
        return glTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glTexCoord4sv$handle() {
        return glTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glTexCoord4sv$address() {
        return glTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoord4sv(const GLshort *v)
     * }
     */
    public static void glTexCoord4sv(MemorySegment v) {
        var mh$ = glTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoord4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static FunctionDescriptor glRasterPos2d$descriptor() {
        return glRasterPos2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MethodHandle glRasterPos2d$handle() {
        return glRasterPos2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static MemorySegment glRasterPos2d$address() {
        return glRasterPos2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2d(GLdouble x, GLdouble y)
     * }
     */
    public static void glRasterPos2d(double x, double y) {
        var mh$ = glRasterPos2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2d", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static FunctionDescriptor glRasterPos2f$descriptor() {
        return glRasterPos2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MethodHandle glRasterPos2f$handle() {
        return glRasterPos2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static MemorySegment glRasterPos2f$address() {
        return glRasterPos2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2f(GLfloat x, GLfloat y)
     * }
     */
    public static void glRasterPos2f(float x, float y) {
        var mh$ = glRasterPos2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2f", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static FunctionDescriptor glRasterPos2i$descriptor() {
        return glRasterPos2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MethodHandle glRasterPos2i$handle() {
        return glRasterPos2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static MemorySegment glRasterPos2i$address() {
        return glRasterPos2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2i(GLint x, GLint y)
     * }
     */
    public static void glRasterPos2i(int x, int y) {
        var mh$ = glRasterPos2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2i", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static FunctionDescriptor glRasterPos2s$descriptor() {
        return glRasterPos2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MethodHandle glRasterPos2s$handle() {
        return glRasterPos2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static MemorySegment glRasterPos2s$address() {
        return glRasterPos2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2s(GLshort x, GLshort y)
     * }
     */
    public static void glRasterPos2s(short x, short y) {
        var mh$ = glRasterPos2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2s", x, y);
            }
            mh$.invokeExact(x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static FunctionDescriptor glRasterPos3d$descriptor() {
        return glRasterPos3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MethodHandle glRasterPos3d$handle() {
        return glRasterPos3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static MemorySegment glRasterPos3d$address() {
        return glRasterPos3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
     * }
     */
    public static void glRasterPos3d(double x, double y, double z) {
        var mh$ = glRasterPos3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3d", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static FunctionDescriptor glRasterPos3f$descriptor() {
        return glRasterPos3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MethodHandle glRasterPos3f$handle() {
        return glRasterPos3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static MemorySegment glRasterPos3f$address() {
        return glRasterPos3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
     * }
     */
    public static void glRasterPos3f(float x, float y, float z) {
        var mh$ = glRasterPos3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3f", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static FunctionDescriptor glRasterPos3i$descriptor() {
        return glRasterPos3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MethodHandle glRasterPos3i$handle() {
        return glRasterPos3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static MemorySegment glRasterPos3i$address() {
        return glRasterPos3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3i(GLint x, GLint y, GLint z)
     * }
     */
    public static void glRasterPos3i(int x, int y, int z) {
        var mh$ = glRasterPos3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3i", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static FunctionDescriptor glRasterPos3s$descriptor() {
        return glRasterPos3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MethodHandle glRasterPos3s$handle() {
        return glRasterPos3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static MemorySegment glRasterPos3s$address() {
        return glRasterPos3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3s(GLshort x, GLshort y, GLshort z)
     * }
     */
    public static void glRasterPos3s(short x, short y, short z) {
        var mh$ = glRasterPos3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3s", x, y, z);
            }
            mh$.invokeExact(x, y, z);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static FunctionDescriptor glRasterPos4d$descriptor() {
        return glRasterPos4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MethodHandle glRasterPos4d$handle() {
        return glRasterPos4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static MemorySegment glRasterPos4d$address() {
        return glRasterPos4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
     * }
     */
    public static void glRasterPos4d(double x, double y, double z, double w) {
        var mh$ = glRasterPos4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4d", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static FunctionDescriptor glRasterPos4f$descriptor() {
        return glRasterPos4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MethodHandle glRasterPos4f$handle() {
        return glRasterPos4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static MemorySegment glRasterPos4f$address() {
        return glRasterPos4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
     * }
     */
    public static void glRasterPos4f(float x, float y, float z, float w) {
        var mh$ = glRasterPos4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4f", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static FunctionDescriptor glRasterPos4i$descriptor() {
        return glRasterPos4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MethodHandle glRasterPos4i$handle() {
        return glRasterPos4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static MemorySegment glRasterPos4i$address() {
        return glRasterPos4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
     * }
     */
    public static void glRasterPos4i(int x, int y, int z, int w) {
        var mh$ = glRasterPos4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4i", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static FunctionDescriptor glRasterPos4s$descriptor() {
        return glRasterPos4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MethodHandle glRasterPos4s$handle() {
        return glRasterPos4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static MemorySegment glRasterPos4s$address() {
        return glRasterPos4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
     * }
     */
    public static void glRasterPos4s(short x, short y, short z, short w) {
        var mh$ = glRasterPos4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4s", x, y, z, w);
            }
            mh$.invokeExact(x, y, z, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2dv$descriptor() {
        return glRasterPos2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos2dv$handle() {
        return glRasterPos2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos2dv$address() {
        return glRasterPos2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos2dv(MemorySegment v) {
        var mh$ = glRasterPos2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2fv$descriptor() {
        return glRasterPos2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos2fv$handle() {
        return glRasterPos2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos2fv$address() {
        return glRasterPos2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos2fv(MemorySegment v) {
        var mh$ = glRasterPos2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2iv$descriptor() {
        return glRasterPos2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos2iv$handle() {
        return glRasterPos2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos2iv$address() {
        return glRasterPos2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2iv(const GLint *v)
     * }
     */
    public static void glRasterPos2iv(MemorySegment v) {
        var mh$ = glRasterPos2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos2sv$descriptor() {
        return glRasterPos2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos2sv$handle() {
        return glRasterPos2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos2sv$address() {
        return glRasterPos2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos2sv(const GLshort *v)
     * }
     */
    public static void glRasterPos2sv(MemorySegment v) {
        var mh$ = glRasterPos2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos2sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3dv$descriptor() {
        return glRasterPos3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos3dv$handle() {
        return glRasterPos3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos3dv$address() {
        return glRasterPos3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos3dv(MemorySegment v) {
        var mh$ = glRasterPos3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3fv$descriptor() {
        return glRasterPos3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos3fv$handle() {
        return glRasterPos3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos3fv$address() {
        return glRasterPos3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos3fv(MemorySegment v) {
        var mh$ = glRasterPos3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3iv$descriptor() {
        return glRasterPos3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos3iv$handle() {
        return glRasterPos3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos3iv$address() {
        return glRasterPos3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3iv(const GLint *v)
     * }
     */
    public static void glRasterPos3iv(MemorySegment v) {
        var mh$ = glRasterPos3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos3sv$descriptor() {
        return glRasterPos3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos3sv$handle() {
        return glRasterPos3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos3sv$address() {
        return glRasterPos3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos3sv(const GLshort *v)
     * }
     */
    public static void glRasterPos3sv(MemorySegment v) {
        var mh$ = glRasterPos3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos3sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4dv$descriptor() {
        return glRasterPos4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MethodHandle glRasterPos4dv$handle() {
        return glRasterPos4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static MemorySegment glRasterPos4dv$address() {
        return glRasterPos4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4dv(const GLdouble *v)
     * }
     */
    public static void glRasterPos4dv(MemorySegment v) {
        var mh$ = glRasterPos4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4dv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4fv$descriptor() {
        return glRasterPos4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MethodHandle glRasterPos4fv$handle() {
        return glRasterPos4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static MemorySegment glRasterPos4fv$address() {
        return glRasterPos4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4fv(const GLfloat *v)
     * }
     */
    public static void glRasterPos4fv(MemorySegment v) {
        var mh$ = glRasterPos4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4fv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4iv$descriptor() {
        return glRasterPos4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MethodHandle glRasterPos4iv$handle() {
        return glRasterPos4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static MemorySegment glRasterPos4iv$address() {
        return glRasterPos4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4iv(const GLint *v)
     * }
     */
    public static void glRasterPos4iv(MemorySegment v) {
        var mh$ = glRasterPos4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4iv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRasterPos4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRasterPos4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static FunctionDescriptor glRasterPos4sv$descriptor() {
        return glRasterPos4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MethodHandle glRasterPos4sv$handle() {
        return glRasterPos4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static MemorySegment glRasterPos4sv$address() {
        return glRasterPos4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRasterPos4sv(const GLshort *v)
     * }
     */
    public static void glRasterPos4sv(MemorySegment v) {
        var mh$ = glRasterPos4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRasterPos4sv", v);
            }
            mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRectd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static FunctionDescriptor glRectd$descriptor() {
        return glRectd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MethodHandle glRectd$handle() {
        return glRectd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static MemorySegment glRectd$address() {
        return glRectd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
     * }
     */
    public static void glRectd(double x1, double y1, double x2, double y2) {
        var mh$ = glRectd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectd", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRectf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static FunctionDescriptor glRectf$descriptor() {
        return glRectf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MethodHandle glRectf$handle() {
        return glRectf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static MemorySegment glRectf$address() {
        return glRectf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
     * }
     */
    public static void glRectf(float x1, float y1, float x2, float y2) {
        var mh$ = glRectf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectf", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRecti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRecti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static FunctionDescriptor glRecti$descriptor() {
        return glRecti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MethodHandle glRecti$handle() {
        return glRecti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static MemorySegment glRecti$address() {
        return glRecti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
     * }
     */
    public static void glRecti(int x1, int y1, int x2, int y2) {
        var mh$ = glRecti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRecti", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRects");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static FunctionDescriptor glRects$descriptor() {
        return glRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MethodHandle glRects$handle() {
        return glRects.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static MemorySegment glRects$address() {
        return glRects.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
     * }
     */
    public static void glRects(short x1, short y1, short x2, short y2) {
        var mh$ = glRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRects", x1, y1, x2, y2);
            }
            mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRectdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static FunctionDescriptor glRectdv$descriptor() {
        return glRectdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MethodHandle glRectdv$handle() {
        return glRectdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static MemorySegment glRectdv$address() {
        return glRectdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectdv(const GLdouble *v1, const GLdouble *v2)
     * }
     */
    public static void glRectdv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectdv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRectfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static FunctionDescriptor glRectfv$descriptor() {
        return glRectfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MethodHandle glRectfv$handle() {
        return glRectfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static MemorySegment glRectfv$address() {
        return glRectfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectfv(const GLfloat *v1, const GLfloat *v2)
     * }
     */
    public static void glRectfv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectfv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRectiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static FunctionDescriptor glRectiv$descriptor() {
        return glRectiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MethodHandle glRectiv$handle() {
        return glRectiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static MemorySegment glRectiv$address() {
        return glRectiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectiv(const GLint *v1, const GLint *v2)
     * }
     */
    public static void glRectiv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectiv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glRectsv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glRectsv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static FunctionDescriptor glRectsv$descriptor() {
        return glRectsv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MethodHandle glRectsv$handle() {
        return glRectsv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static MemorySegment glRectsv$address() {
        return glRectsv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glRectsv(const GLshort *v1, const GLshort *v2)
     * }
     */
    public static void glRectsv(MemorySegment v1, MemorySegment v2) {
        var mh$ = glRectsv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glRectsv", v1, v2);
            }
            mh$.invokeExact(v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glVertexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glVertexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glVertexPointer$descriptor() {
        return glVertexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glVertexPointer$handle() {
        return glVertexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glVertexPointer$address() {
        return glVertexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glVertexPointer(int size, int type, int stride, MemorySegment ptr) {
        var mh$ = glVertexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glVertexPointer", size, type, stride, ptr);
            }
            mh$.invokeExact(size, type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glNormalPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glNormalPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glNormalPointer$descriptor() {
        return glNormalPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glNormalPointer$handle() {
        return glNormalPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glNormalPointer$address() {
        return glNormalPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glNormalPointer(int type, int stride, MemorySegment ptr) {
        var mh$ = glNormalPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glNormalPointer", type, stride, ptr);
            }
            mh$.invokeExact(type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColorPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glColorPointer$descriptor() {
        return glColorPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glColorPointer$handle() {
        return glColorPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glColorPointer$address() {
        return glColorPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glColorPointer(int size, int type, int stride, MemorySegment ptr) {
        var mh$ = glColorPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorPointer", size, type, stride, ptr);
            }
            mh$.invokeExact(size, type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIndexPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIndexPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glIndexPointer$descriptor() {
        return glIndexPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glIndexPointer$handle() {
        return glIndexPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glIndexPointer$address() {
        return glIndexPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glIndexPointer(int type, int stride, MemorySegment ptr) {
        var mh$ = glIndexPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIndexPointer", type, stride, ptr);
            }
            mh$.invokeExact(type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexCoordPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexCoordPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glTexCoordPointer$descriptor() {
        return glTexCoordPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glTexCoordPointer$handle() {
        return glTexCoordPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glTexCoordPointer$address() {
        return glTexCoordPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glTexCoordPointer(int size, int type, int stride, MemorySegment ptr) {
        var mh$ = glTexCoordPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexCoordPointer", size, type, stride, ptr);
            }
            mh$.invokeExact(size, type, stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEdgeFlagPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEdgeFlagPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static FunctionDescriptor glEdgeFlagPointer$descriptor() {
        return glEdgeFlagPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MethodHandle glEdgeFlagPointer$handle() {
        return glEdgeFlagPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static MemorySegment glEdgeFlagPointer$address() {
        return glEdgeFlagPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
     * }
     */
    public static void glEdgeFlagPointer(int stride, MemorySegment ptr) {
        var mh$ = glEdgeFlagPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEdgeFlagPointer", stride, ptr);
            }
            mh$.invokeExact(stride, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPointerv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetPointerv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static FunctionDescriptor glGetPointerv$descriptor() {
        return glGetPointerv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MethodHandle glGetPointerv$handle() {
        return glGetPointerv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static MemorySegment glGetPointerv$address() {
        return glGetPointerv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPointerv(GLenum pname, GLvoid **params)
     * }
     */
    public static void glGetPointerv(int pname, MemorySegment params) {
        var mh$ = glGetPointerv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPointerv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glArrayElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glArrayElement");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static FunctionDescriptor glArrayElement$descriptor() {
        return glArrayElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MethodHandle glArrayElement$handle() {
        return glArrayElement.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static MemorySegment glArrayElement$address() {
        return glArrayElement.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glArrayElement(GLint i)
     * }
     */
    public static void glArrayElement(int i) {
        var mh$ = glArrayElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glArrayElement", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDrawArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static FunctionDescriptor glDrawArrays$descriptor() {
        return glDrawArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MethodHandle glDrawArrays$handle() {
        return glDrawArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static MemorySegment glDrawArrays$address() {
        return glDrawArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawArrays(GLenum mode, GLint first, GLsizei count)
     * }
     */
    public static void glDrawArrays(int mode, int first, int count) {
        var mh$ = glDrawArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawArrays", mode, first, count);
            }
            mh$.invokeExact(mode, first, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDrawElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawElements$descriptor() {
        return glDrawElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawElements$handle() {
        return glDrawElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawElements$address() {
        return glDrawElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawElements(int mode, int count, int type, MemorySegment indices) {
        var mh$ = glDrawElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawElements", mode, count, type, indices);
            }
            mh$.invokeExact(mode, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInterleavedArrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glInterleavedArrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static FunctionDescriptor glInterleavedArrays$descriptor() {
        return glInterleavedArrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MethodHandle glInterleavedArrays$handle() {
        return glInterleavedArrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static MemorySegment glInterleavedArrays$address() {
        return glInterleavedArrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
     * }
     */
    public static void glInterleavedArrays(int format, int stride, MemorySegment pointer) {
        var mh$ = glInterleavedArrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInterleavedArrays", format, stride, pointer);
            }
            mh$.invokeExact(format, stride, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glShadeModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glShadeModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static FunctionDescriptor glShadeModel$descriptor() {
        return glShadeModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MethodHandle glShadeModel$handle() {
        return glShadeModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static MemorySegment glShadeModel$address() {
        return glShadeModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glShadeModel(GLenum mode)
     * }
     */
    public static void glShadeModel(int mode) {
        var mh$ = glShadeModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glShadeModel", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLightf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightf$descriptor() {
        return glLightf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightf$handle() {
        return glLightf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightf$address() {
        return glLightf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightf(GLenum light, GLenum pname, GLfloat param)
     * }
     */
    public static void glLightf(int light, int pname, float param) {
        var mh$ = glLightf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightf", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLighti {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLighti");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLighti$descriptor() {
        return glLighti.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLighti$handle() {
        return glLighti.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLighti$address() {
        return glLighti.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLighti(GLenum light, GLenum pname, GLint param)
     * }
     */
    public static void glLighti(int light, int pname, int param) {
        var mh$ = glLighti.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLighti", light, pname, param);
            }
            mh$.invokeExact(light, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightfv$descriptor() {
        return glLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightfv$handle() {
        return glLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightfv$address() {
        return glLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightfv(GLenum light, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightiv$descriptor() {
        return glLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightiv$handle() {
        return glLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightiv$address() {
        return glLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightiv(GLenum light, GLenum pname, const GLint *params)
     * }
     */
    public static void glLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetLightfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetLightfv$descriptor() {
        return glGetLightfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetLightfv$handle() {
        return glGetLightfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetLightfv$address() {
        return glGetLightfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetLightfv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightfv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetLightiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetLightiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetLightiv$descriptor() {
        return glGetLightiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetLightiv$handle() {
        return glGetLightiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetLightiv$address() {
        return glGetLightiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetLightiv(GLenum light, GLenum pname, GLint *params)
     * }
     */
    public static void glGetLightiv(int light, int pname, MemorySegment params) {
        var mh$ = glGetLightiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetLightiv", light, pname, params);
            }
            mh$.invokeExact(light, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLightModelf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glLightModelf$descriptor() {
        return glLightModelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glLightModelf$handle() {
        return glLightModelf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glLightModelf$address() {
        return glLightModelf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelf(GLenum pname, GLfloat param)
     * }
     */
    public static void glLightModelf(int pname, float param) {
        var mh$ = glLightModelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeli {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLightModeli");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glLightModeli$descriptor() {
        return glLightModeli.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glLightModeli$handle() {
        return glLightModeli.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glLightModeli$address() {
        return glLightModeli.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeli(GLenum pname, GLint param)
     * }
     */
    public static void glLightModeli(int pname, int param) {
        var mh$ = glLightModeli.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeli", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModelfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLightModelfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glLightModelfv$descriptor() {
        return glLightModelfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glLightModelfv$handle() {
        return glLightModelfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glLightModelfv$address() {
        return glLightModelfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModelfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glLightModelfv(int pname, MemorySegment params) {
        var mh$ = glLightModelfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModelfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLightModeliv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLightModeliv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glLightModeliv$descriptor() {
        return glLightModeliv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glLightModeliv$handle() {
        return glLightModeliv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glLightModeliv$address() {
        return glLightModeliv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLightModeliv(GLenum pname, const GLint *params)
     * }
     */
    public static void glLightModeliv(int pname, MemorySegment params) {
        var mh$ = glLightModeliv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLightModeliv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMaterialf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glMaterialf$descriptor() {
        return glMaterialf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glMaterialf$handle() {
        return glMaterialf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glMaterialf$address() {
        return glMaterialf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialf(GLenum face, GLenum pname, GLfloat param)
     * }
     */
    public static void glMaterialf(int face, int pname, float param) {
        var mh$ = glMaterialf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialf", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMateriali {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMateriali");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glMateriali$descriptor() {
        return glMateriali.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glMateriali$handle() {
        return glMateriali.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glMateriali$address() {
        return glMateriali.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMateriali(GLenum face, GLenum pname, GLint param)
     * }
     */
    public static void glMateriali(int face, int pname, int param) {
        var mh$ = glMateriali.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMateriali", face, pname, param);
            }
            mh$.invokeExact(face, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glMaterialfv$descriptor() {
        return glMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glMaterialfv$handle() {
        return glMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glMaterialfv$address() {
        return glMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glMaterialiv$descriptor() {
        return glMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glMaterialiv$handle() {
        return glMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glMaterialiv$address() {
        return glMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMaterialiv(GLenum face, GLenum pname, const GLint *params)
     * }
     */
    public static void glMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetMaterialfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialfv$descriptor() {
        return glGetMaterialfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMaterialfv$handle() {
        return glGetMaterialfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMaterialfv$address() {
        return glGetMaterialfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMaterialfv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialfv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMaterialiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetMaterialiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMaterialiv$descriptor() {
        return glGetMaterialiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMaterialiv$handle() {
        return glGetMaterialiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMaterialiv$address() {
        return glGetMaterialiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMaterialiv(int face, int pname, MemorySegment params) {
        var mh$ = glGetMaterialiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMaterialiv", face, pname, params);
            }
            mh$.invokeExact(face, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorMaterial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColorMaterial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static FunctionDescriptor glColorMaterial$descriptor() {
        return glColorMaterial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MethodHandle glColorMaterial$handle() {
        return glColorMaterial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static MemorySegment glColorMaterial$address() {
        return glColorMaterial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorMaterial(GLenum face, GLenum mode)
     * }
     */
    public static void glColorMaterial(int face, int mode) {
        var mh$ = glColorMaterial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorMaterial", face, mode);
            }
            mh$.invokeExact(face, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelZoom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPixelZoom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static FunctionDescriptor glPixelZoom$descriptor() {
        return glPixelZoom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MethodHandle glPixelZoom$handle() {
        return glPixelZoom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static MemorySegment glPixelZoom$address() {
        return glPixelZoom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelZoom(GLfloat xfactor, GLfloat yfactor)
     * }
     */
    public static void glPixelZoom(float xfactor, float yfactor) {
        var mh$ = glPixelZoom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelZoom", xfactor, yfactor);
            }
            mh$.invokeExact(xfactor, yfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStoref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPixelStoref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelStoref$descriptor() {
        return glPixelStoref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelStoref$handle() {
        return glPixelStoref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelStoref$address() {
        return glPixelStoref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStoref(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelStoref(int pname, float param) {
        var mh$ = glPixelStoref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStoref", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelStorei {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPixelStorei");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelStorei$descriptor() {
        return glPixelStorei.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelStorei$handle() {
        return glPixelStorei.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelStorei$address() {
        return glPixelStorei.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelStorei(GLenum pname, GLint param)
     * }
     */
    public static void glPixelStorei(int pname, int param) {
        var mh$ = glPixelStorei.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelStorei", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPixelTransferf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glPixelTransferf$descriptor() {
        return glPixelTransferf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glPixelTransferf$handle() {
        return glPixelTransferf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glPixelTransferf$address() {
        return glPixelTransferf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferf(GLenum pname, GLfloat param)
     * }
     */
    public static void glPixelTransferf(int pname, float param) {
        var mh$ = glPixelTransferf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelTransferi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPixelTransferi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glPixelTransferi$descriptor() {
        return glPixelTransferi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glPixelTransferi$handle() {
        return glPixelTransferi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glPixelTransferi$address() {
        return glPixelTransferi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelTransferi(GLenum pname, GLint param)
     * }
     */
    public static void glPixelTransferi(int pname, int param) {
        var mh$ = glPixelTransferi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelTransferi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static FunctionDescriptor glPixelMapfv$descriptor() {
        return glPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MethodHandle glPixelMapfv$handle() {
        return glPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static MemorySegment glPixelMapfv$address() {
        return glPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
     * }
     */
    public static void glPixelMapfv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapfv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static FunctionDescriptor glPixelMapuiv$descriptor() {
        return glPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MethodHandle glPixelMapuiv$handle() {
        return glPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static MemorySegment glPixelMapuiv$address() {
        return glPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
     * }
     */
    public static void glPixelMapuiv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapuiv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static FunctionDescriptor glPixelMapusv$descriptor() {
        return glPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MethodHandle glPixelMapusv$handle() {
        return glPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static MemorySegment glPixelMapusv$address() {
        return glPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
     * }
     */
    public static void glPixelMapusv(int map, int mapsize, MemorySegment values) {
        var mh$ = glPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPixelMapusv", map, mapsize, values);
            }
            mh$.invokeExact(map, mapsize, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetPixelMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapfv$descriptor() {
        return glGetPixelMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MethodHandle glGetPixelMapfv$handle() {
        return glGetPixelMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static MemorySegment glGetPixelMapfv$address() {
        return glGetPixelMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapfv(GLenum map, GLfloat *values)
     * }
     */
    public static void glGetPixelMapfv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapfv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapuiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetPixelMapuiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapuiv$descriptor() {
        return glGetPixelMapuiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MethodHandle glGetPixelMapuiv$handle() {
        return glGetPixelMapuiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static MemorySegment glGetPixelMapuiv$address() {
        return glGetPixelMapuiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapuiv(GLenum map, GLuint *values)
     * }
     */
    public static void glGetPixelMapuiv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapuiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapuiv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetPixelMapusv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetPixelMapusv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static FunctionDescriptor glGetPixelMapusv$descriptor() {
        return glGetPixelMapusv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MethodHandle glGetPixelMapusv$handle() {
        return glGetPixelMapusv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static MemorySegment glGetPixelMapusv$address() {
        return glGetPixelMapusv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetPixelMapusv(GLenum map, GLushort *values)
     * }
     */
    public static void glGetPixelMapusv(int map, MemorySegment values) {
        var mh$ = glGetPixelMapusv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetPixelMapusv", map, values);
            }
            mh$.invokeExact(map, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glBitmap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static FunctionDescriptor glBitmap$descriptor() {
        return glBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MethodHandle glBitmap$handle() {
        return glBitmap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static MemorySegment glBitmap$address() {
        return glBitmap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
     * }
     */
    public static void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, MemorySegment bitmap) {
        var mh$ = glBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBitmap", width, height, xorig, yorig, xmove, ymove, bitmap);
            }
            mh$.invokeExact(width, height, xorig, yorig, xmove, ymove, bitmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glReadPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glReadPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glReadPixels$descriptor() {
        return glReadPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glReadPixels$handle() {
        return glReadPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glReadPixels$address() {
        return glReadPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glReadPixels(int x, int y, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glReadPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glReadPixels", x, y, width, height, format, type, pixels);
            }
            mh$.invokeExact(x, y, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDrawPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glDrawPixels$descriptor() {
        return glDrawPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glDrawPixels$handle() {
        return glDrawPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glDrawPixels$address() {
        return glDrawPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glDrawPixels(int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glDrawPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawPixels", width, height, format, type, pixels);
            }
            mh$.invokeExact(width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyPixels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyPixels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static FunctionDescriptor glCopyPixels$descriptor() {
        return glCopyPixels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MethodHandle glCopyPixels$handle() {
        return glCopyPixels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static MemorySegment glCopyPixels$address() {
        return glCopyPixels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
     * }
     */
    public static void glCopyPixels(int x, int y, int width, int height, int type) {
        var mh$ = glCopyPixels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyPixels", x, y, width, height, type);
            }
            mh$.invokeExact(x, y, width, height, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilFunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glStencilFunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilFunc$descriptor() {
        return glStencilFunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MethodHandle glStencilFunc$handle() {
        return glStencilFunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static MemorySegment glStencilFunc$address() {
        return glStencilFunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilFunc(GLenum func, GLint ref, GLuint mask)
     * }
     */
    public static void glStencilFunc(int func, int ref, int mask) {
        var mh$ = glStencilFunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilFunc", func, ref, mask);
            }
            mh$.invokeExact(func, ref, mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glStencilMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static FunctionDescriptor glStencilMask$descriptor() {
        return glStencilMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MethodHandle glStencilMask$handle() {
        return glStencilMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static MemorySegment glStencilMask$address() {
        return glStencilMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilMask(GLuint mask)
     * }
     */
    public static void glStencilMask(int mask) {
        var mh$ = glStencilMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilMask", mask);
            }
            mh$.invokeExact(mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glStencilOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glStencilOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static FunctionDescriptor glStencilOp$descriptor() {
        return glStencilOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MethodHandle glStencilOp$handle() {
        return glStencilOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static MemorySegment glStencilOp$address() {
        return glStencilOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
     * }
     */
    public static void glStencilOp(int fail, int zfail, int zpass) {
        var mh$ = glStencilOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glStencilOp", fail, zfail, zpass);
            }
            mh$.invokeExact(fail, zfail, zpass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClearStencil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glClearStencil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static FunctionDescriptor glClearStencil$descriptor() {
        return glClearStencil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MethodHandle glClearStencil$handle() {
        return glClearStencil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static MemorySegment glClearStencil$address() {
        return glClearStencil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClearStencil(GLint s)
     * }
     */
    public static void glClearStencil(int s) {
        var mh$ = glClearStencil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClearStencil", s);
            }
            mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexGend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static FunctionDescriptor glTexGend$descriptor() {
        return glTexGend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MethodHandle glTexGend$handle() {
        return glTexGend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static MemorySegment glTexGend$address() {
        return glTexGend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGend(GLenum coord, GLenum pname, GLdouble param)
     * }
     */
    public static void glTexGend(int coord, int pname, double param) {
        var mh$ = glTexGend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGend", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexGenf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexGenf$descriptor() {
        return glTexGenf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexGenf$handle() {
        return glTexGenf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexGenf$address() {
        return glTexGenf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenf(GLenum coord, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexGenf(int coord, int pname, float param) {
        var mh$ = glTexGenf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenf", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeni {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexGeni");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexGeni$descriptor() {
        return glTexGeni.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexGeni$handle() {
        return glTexGeni.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexGeni$address() {
        return glTexGeni.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeni(GLenum coord, GLenum pname, GLint param)
     * }
     */
    public static void glTexGeni(int coord, int pname, int param) {
        var mh$ = glTexGeni.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeni", coord, pname, param);
            }
            mh$.invokeExact(coord, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static FunctionDescriptor glTexGendv$descriptor() {
        return glTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MethodHandle glTexGendv$handle() {
        return glTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static MemorySegment glTexGendv$address() {
        return glTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
     * }
     */
    public static void glTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexGenfv$descriptor() {
        return glTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexGenfv$handle() {
        return glTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexGenfv$address() {
        return glTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexGeniv$descriptor() {
        return glTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexGeniv$handle() {
        return glTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexGeniv$address() {
        return glTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGendv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexGendv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static FunctionDescriptor glGetTexGendv$descriptor() {
        return glGetTexGendv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MethodHandle glGetTexGendv$handle() {
        return glGetTexGendv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static MemorySegment glGetTexGendv$address() {
        return glGetTexGendv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
     * }
     */
    public static void glGetTexGendv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGendv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGendv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGenfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexGenfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexGenfv$descriptor() {
        return glGetTexGenfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexGenfv$handle() {
        return glGetTexGenfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexGenfv$address() {
        return glGetTexGenfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexGenfv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGenfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGenfv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexGeniv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexGeniv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexGeniv$descriptor() {
        return glGetTexGeniv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexGeniv$handle() {
        return glGetTexGeniv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexGeniv$address() {
        return glGetTexGeniv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexGeniv(int coord, int pname, MemorySegment params) {
        var mh$ = glGetTexGeniv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexGeniv", coord, pname, params);
            }
            mh$.invokeExact(coord, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexEnvf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexEnvf$descriptor() {
        return glTexEnvf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexEnvf$handle() {
        return glTexEnvf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexEnvf$address() {
        return glTexEnvf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexEnvf(int target, int pname, float param) {
        var mh$ = glTexEnvf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexEnvi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexEnvi$descriptor() {
        return glTexEnvi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexEnvi$handle() {
        return glTexEnvi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexEnvi$address() {
        return glTexEnvi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvi(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexEnvi(int target, int pname, int param) {
        var mh$ = glTexEnvi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvi", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexEnvfv$descriptor() {
        return glTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexEnvfv$handle() {
        return glTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexEnvfv$address() {
        return glTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexEnviv$descriptor() {
        return glTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexEnviv$handle() {
        return glTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexEnviv$address() {
        return glTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexEnviv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnvfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexEnvfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnvfv$descriptor() {
        return glGetTexEnvfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexEnvfv$handle() {
        return glGetTexEnvfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexEnvfv$address() {
        return glGetTexEnvfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexEnvfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnvfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnvfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexEnviv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexEnviv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexEnviv$descriptor() {
        return glGetTexEnviv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexEnviv$handle() {
        return glGetTexEnviv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexEnviv$address() {
        return glGetTexEnviv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexEnviv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexEnviv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexEnviv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glTexParameterf$descriptor() {
        return glTexParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glTexParameterf$handle() {
        return glTexParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glTexParameterf$address() {
        return glTexParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterf(GLenum target, GLenum pname, GLfloat param)
     * }
     */
    public static void glTexParameterf(int target, int pname, float param) {
        var mh$ = glTexParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterf", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glTexParameteri$descriptor() {
        return glTexParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glTexParameteri$handle() {
        return glTexParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glTexParameteri$address() {
        return glTexParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteri(GLenum target, GLenum pname, GLint param)
     * }
     */
    public static void glTexParameteri(int target, int pname, int param) {
        var mh$ = glTexParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteri", target, pname, param);
            }
            mh$.invokeExact(target, pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glTexParameterfv$descriptor() {
        return glTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glTexParameterfv$handle() {
        return glTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glTexParameterfv$address() {
        return glTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glTexParameteriv$descriptor() {
        return glTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glTexParameteriv$handle() {
        return glTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glTexParameteriv$address() {
        return glTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameterfv$descriptor() {
        return glGetTexParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexParameterfv$handle() {
        return glGetTexParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexParameterfv$address() {
        return glGetTexParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexParameteriv$descriptor() {
        return glGetTexParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexParameteriv$handle() {
        return glGetTexParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexParameteriv$address() {
        return glGetTexParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetTexParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexLevelParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameterfv$descriptor() {
        return glGetTexLevelParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameterfv$handle() {
        return glGetTexLevelParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameterfv$address() {
        return glGetTexLevelParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetTexLevelParameterfv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameterfv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexLevelParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexLevelParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetTexLevelParameteriv$descriptor() {
        return glGetTexLevelParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetTexLevelParameteriv$handle() {
        return glGetTexLevelParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetTexLevelParameteriv$address() {
        return glGetTexLevelParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
     * }
     */
    public static void glGetTexLevelParameteriv(int target, int level, int pname, MemorySegment params) {
        var mh$ = glGetTexLevelParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexLevelParameteriv", target, level, pname, params);
            }
            mh$.invokeExact(target, level, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage1D$descriptor() {
        return glTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage1D$handle() {
        return glTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage1D$address() {
        return glTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage1D(int target, int level, int internalFormat, int width, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage1D", target, level, internalFormat, width, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalFormat, width, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage2D$descriptor() {
        return glTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage2D$handle() {
        return glTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage2D$address() {
        return glTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage2D", target, level, internalFormat, width, height, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalFormat, width, height, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glGetTexImage$descriptor() {
        return glGetTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MethodHandle glGetTexImage$handle() {
        return glGetTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static MemorySegment glGetTexImage$address() {
        return glGetTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
     * }
     */
    public static void glGetTexImage(int target, int level, int format, int type, MemorySegment pixels) {
        var mh$ = glGetTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetTexImage", target, level, format, type, pixels);
            }
            mh$.invokeExact(target, level, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGenTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGenTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static FunctionDescriptor glGenTextures$descriptor() {
        return glGenTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MethodHandle glGenTextures$handle() {
        return glGenTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static MemorySegment glGenTextures$address() {
        return glGenTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGenTextures(GLsizei n, GLuint *textures)
     * }
     */
    public static void glGenTextures(int n, MemorySegment textures) {
        var mh$ = glGenTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGenTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDeleteTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDeleteTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static FunctionDescriptor glDeleteTextures$descriptor() {
        return glDeleteTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MethodHandle glDeleteTextures$handle() {
        return glDeleteTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static MemorySegment glDeleteTextures$address() {
        return glDeleteTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDeleteTextures(GLsizei n, const GLuint *textures)
     * }
     */
    public static void glDeleteTextures(int n, MemorySegment textures) {
        var mh$ = glDeleteTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDeleteTextures", n, textures);
            }
            mh$.invokeExact(n, textures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBindTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glBindTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static FunctionDescriptor glBindTexture$descriptor() {
        return glBindTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MethodHandle glBindTexture$handle() {
        return glBindTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static MemorySegment glBindTexture$address() {
        return glBindTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBindTexture(GLenum target, GLuint texture)
     * }
     */
    public static void glBindTexture(int target, int texture) {
        var mh$ = glBindTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBindTexture", target, texture);
            }
            mh$.invokeExact(target, texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPrioritizeTextures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPrioritizeTextures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static FunctionDescriptor glPrioritizeTextures$descriptor() {
        return glPrioritizeTextures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MethodHandle glPrioritizeTextures$handle() {
        return glPrioritizeTextures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static MemorySegment glPrioritizeTextures$address() {
        return glPrioritizeTextures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
     * }
     */
    public static void glPrioritizeTextures(int n, MemorySegment textures, MemorySegment priorities) {
        var mh$ = glPrioritizeTextures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPrioritizeTextures", n, textures, priorities);
            }
            mh$.invokeExact(n, textures, priorities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glAreTexturesResident {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_CHAR,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glAreTexturesResident");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static FunctionDescriptor glAreTexturesResident$descriptor() {
        return glAreTexturesResident.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MethodHandle glAreTexturesResident$handle() {
        return glAreTexturesResident.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static MemorySegment glAreTexturesResident$address() {
        return glAreTexturesResident.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
     * }
     */
    public static byte glAreTexturesResident(int n, MemorySegment textures, MemorySegment residences) {
        var mh$ = glAreTexturesResident.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glAreTexturesResident", n, textures, residences);
            }
            return (byte)mh$.invokeExact(n, textures, residences);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glIsTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_CHAR,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glIsTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static FunctionDescriptor glIsTexture$descriptor() {
        return glIsTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MethodHandle glIsTexture$handle() {
        return glIsTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static MemorySegment glIsTexture$address() {
        return glIsTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLboolean glIsTexture(GLuint texture)
     * }
     */
    public static byte glIsTexture(int texture) {
        var mh$ = glIsTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glIsTexture", texture);
            }
            return (byte)mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage1D$descriptor() {
        return glTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage1D$handle() {
        return glTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage1D$address() {
        return glTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage1D", target, level, xoffset, width, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, width, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage2D$descriptor() {
        return glTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage2D$handle() {
        return glTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage2D$address() {
        return glTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage2D", target, level, xoffset, yoffset, width, height, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage1D$descriptor() {
        return glCopyTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage1D$handle() {
        return glCopyTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage1D$address() {
        return glCopyTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
     * }
     */
    public static void glCopyTexImage1D(int target, int level, int internalformat, int x, int y, int width, int border) {
        var mh$ = glCopyTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage1D", target, level, internalformat, x, y, width, border);
            }
            mh$.invokeExact(target, level, internalformat, x, y, width, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static FunctionDescriptor glCopyTexImage2D$descriptor() {
        return glCopyTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MethodHandle glCopyTexImage2D$handle() {
        return glCopyTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static MemorySegment glCopyTexImage2D$address() {
        return glCopyTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
     * }
     */
    public static void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
        var mh$ = glCopyTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexImage2D", target, level, internalformat, x, y, width, height, border);
            }
            mh$.invokeExact(target, level, internalformat, x, y, width, height, border);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage1D$descriptor() {
        return glCopyTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyTexSubImage1D$handle() {
        return glCopyTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyTexSubImage1D$address() {
        return glCopyTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width) {
        var mh$ = glCopyTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage1D", target, level, xoffset, x, y, width);
            }
            mh$.invokeExact(target, level, xoffset, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage2D$descriptor() {
        return glCopyTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage2D$handle() {
        return glCopyTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage2D$address() {
        return glCopyTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage2D", target, level, xoffset, yoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMap1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap1d$descriptor() {
        return glMap1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap1d$handle() {
        return glMap1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap1d$address() {
        return glMap1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
     * }
     */
    public static void glMap1d(int target, double u1, double u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1d", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMap1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap1f$descriptor() {
        return glMap1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap1f$handle() {
        return glMap1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap1f$address() {
        return glMap1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
     * }
     */
    public static void glMap1f(int target, float u1, float u2, int stride, int order, MemorySegment points) {
        var mh$ = glMap1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap1f", target, u1, u2, stride, order, points);
            }
            mh$.invokeExact(target, u1, u2, stride, order, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMap2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static FunctionDescriptor glMap2d$descriptor() {
        return glMap2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MethodHandle glMap2d$handle() {
        return glMap2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static MemorySegment glMap2d$address() {
        return glMap2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
     * }
     */
    public static void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2d", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMap2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMap2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static FunctionDescriptor glMap2f$descriptor() {
        return glMap2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MethodHandle glMap2f$handle() {
        return glMap2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static MemorySegment glMap2f$address() {
        return glMap2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
     * }
     */
    public static void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, MemorySegment points) {
        var mh$ = glMap2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMap2f", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
            }
            mh$.invokeExact(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapdv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetMapdv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static FunctionDescriptor glGetMapdv$descriptor() {
        return glGetMapdv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MethodHandle glGetMapdv$handle() {
        return glGetMapdv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static MemorySegment glGetMapdv$address() {
        return glGetMapdv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapdv(GLenum target, GLenum query, GLdouble *v)
     * }
     */
    public static void glGetMapdv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapdv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapdv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetMapfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static FunctionDescriptor glGetMapfv$descriptor() {
        return glGetMapfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MethodHandle glGetMapfv$handle() {
        return glGetMapfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static MemorySegment glGetMapfv$address() {
        return glGetMapfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapfv(GLenum target, GLenum query, GLfloat *v)
     * }
     */
    public static void glGetMapfv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapfv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMapiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetMapiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static FunctionDescriptor glGetMapiv$descriptor() {
        return glGetMapiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MethodHandle glGetMapiv$handle() {
        return glGetMapiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static MemorySegment glGetMapiv$address() {
        return glGetMapiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMapiv(GLenum target, GLenum query, GLint *v)
     * }
     */
    public static void glGetMapiv(int target, int query, MemorySegment v) {
        var mh$ = glGetMapiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMapiv", target, query, v);
            }
            mh$.invokeExact(target, query, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1d$descriptor() {
        return glEvalCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MethodHandle glEvalCoord1d$handle() {
        return glEvalCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static MemorySegment glEvalCoord1d$address() {
        return glEvalCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1d(GLdouble u)
     * }
     */
    public static void glEvalCoord1d(double u) {
        var mh$ = glEvalCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1d", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1f$descriptor() {
        return glEvalCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MethodHandle glEvalCoord1f$handle() {
        return glEvalCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static MemorySegment glEvalCoord1f$address() {
        return glEvalCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1f(GLfloat u)
     * }
     */
    public static void glEvalCoord1f(float u) {
        var mh$ = glEvalCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1f", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1dv$descriptor() {
        return glEvalCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord1dv$handle() {
        return glEvalCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord1dv$address() {
        return glEvalCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord1dv(MemorySegment u) {
        var mh$ = glEvalCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord1fv$descriptor() {
        return glEvalCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord1fv$handle() {
        return glEvalCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord1fv$address() {
        return glEvalCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord1fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord1fv(MemorySegment u) {
        var mh$ = glEvalCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord1fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2d$descriptor() {
        return glEvalCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MethodHandle glEvalCoord2d$handle() {
        return glEvalCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static MemorySegment glEvalCoord2d$address() {
        return glEvalCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2d(GLdouble u, GLdouble v)
     * }
     */
    public static void glEvalCoord2d(double u, double v) {
        var mh$ = glEvalCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2d", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static FunctionDescriptor glEvalCoord2f$descriptor() {
        return glEvalCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MethodHandle glEvalCoord2f$handle() {
        return glEvalCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static MemorySegment glEvalCoord2f$address() {
        return glEvalCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2f(GLfloat u, GLfloat v)
     * }
     */
    public static void glEvalCoord2f(float u, float v) {
        var mh$ = glEvalCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2f", u, v);
            }
            mh$.invokeExact(u, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2dv$descriptor() {
        return glEvalCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MethodHandle glEvalCoord2dv$handle() {
        return glEvalCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static MemorySegment glEvalCoord2dv$address() {
        return glEvalCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2dv(const GLdouble *u)
     * }
     */
    public static void glEvalCoord2dv(MemorySegment u) {
        var mh$ = glEvalCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2dv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static FunctionDescriptor glEvalCoord2fv$descriptor() {
        return glEvalCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MethodHandle glEvalCoord2fv$handle() {
        return glEvalCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static MemorySegment glEvalCoord2fv$address() {
        return glEvalCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalCoord2fv(const GLfloat *u)
     * }
     */
    public static void glEvalCoord2fv(MemorySegment u) {
        var mh$ = glEvalCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalCoord2fv", u);
            }
            mh$.invokeExact(u);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMapGrid1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1d$descriptor() {
        return glMapGrid1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MethodHandle glMapGrid1d$handle() {
        return glMapGrid1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static MemorySegment glMapGrid1d$address() {
        return glMapGrid1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
     * }
     */
    public static void glMapGrid1d(int un, double u1, double u2) {
        var mh$ = glMapGrid1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1d", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMapGrid1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static FunctionDescriptor glMapGrid1f$descriptor() {
        return glMapGrid1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MethodHandle glMapGrid1f$handle() {
        return glMapGrid1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static MemorySegment glMapGrid1f$address() {
        return glMapGrid1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
     * }
     */
    public static void glMapGrid1f(int un, float u1, float u2) {
        var mh$ = glMapGrid1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid1f", un, u1, u2);
            }
            mh$.invokeExact(un, u1, u2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMapGrid2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2d$descriptor() {
        return glMapGrid2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MethodHandle glMapGrid2d$handle() {
        return glMapGrid2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static MemorySegment glMapGrid2d$address() {
        return glMapGrid2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
     * }
     */
    public static void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) {
        var mh$ = glMapGrid2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2d", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMapGrid2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMapGrid2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static FunctionDescriptor glMapGrid2f$descriptor() {
        return glMapGrid2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MethodHandle glMapGrid2f$handle() {
        return glMapGrid2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static MemorySegment glMapGrid2f$address() {
        return glMapGrid2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
     * }
     */
    public static void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) {
        var mh$ = glMapGrid2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMapGrid2f", un, u1, u2, vn, v1, v2);
            }
            mh$.invokeExact(un, u1, u2, vn, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalPoint1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static FunctionDescriptor glEvalPoint1$descriptor() {
        return glEvalPoint1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MethodHandle glEvalPoint1$handle() {
        return glEvalPoint1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static MemorySegment glEvalPoint1$address() {
        return glEvalPoint1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint1(GLint i)
     * }
     */
    public static void glEvalPoint1(int i) {
        var mh$ = glEvalPoint1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint1", i);
            }
            mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalPoint2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalPoint2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static FunctionDescriptor glEvalPoint2$descriptor() {
        return glEvalPoint2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MethodHandle glEvalPoint2$handle() {
        return glEvalPoint2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static MemorySegment glEvalPoint2$address() {
        return glEvalPoint2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalPoint2(GLint i, GLint j)
     * }
     */
    public static void glEvalPoint2(int i, int j) {
        var mh$ = glEvalPoint2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalPoint2", i, j);
            }
            mh$.invokeExact(i, j);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalMesh1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static FunctionDescriptor glEvalMesh1$descriptor() {
        return glEvalMesh1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MethodHandle glEvalMesh1$handle() {
        return glEvalMesh1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static MemorySegment glEvalMesh1$address() {
        return glEvalMesh1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh1(GLenum mode, GLint i1, GLint i2)
     * }
     */
    public static void glEvalMesh1(int mode, int i1, int i2) {
        var mh$ = glEvalMesh1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh1", mode, i1, i2);
            }
            mh$.invokeExact(mode, i1, i2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glEvalMesh2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glEvalMesh2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static FunctionDescriptor glEvalMesh2$descriptor() {
        return glEvalMesh2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MethodHandle glEvalMesh2$handle() {
        return glEvalMesh2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static MemorySegment glEvalMesh2$address() {
        return glEvalMesh2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
     * }
     */
    public static void glEvalMesh2(int mode, int i1, int i2, int j1, int j2) {
        var mh$ = glEvalMesh2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glEvalMesh2", mode, i1, i2, j1, j2);
            }
            mh$.invokeExact(mode, i1, i2, j1, j2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glFogf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static FunctionDescriptor glFogf$descriptor() {
        return glFogf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MethodHandle glFogf$handle() {
        return glFogf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static MemorySegment glFogf$address() {
        return glFogf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogf(GLenum pname, GLfloat param)
     * }
     */
    public static void glFogf(int pname, float param) {
        var mh$ = glFogf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogf", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glFogi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static FunctionDescriptor glFogi$descriptor() {
        return glFogi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MethodHandle glFogi$handle() {
        return glFogi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static MemorySegment glFogi$address() {
        return glFogi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogi(GLenum pname, GLint param)
     * }
     */
    public static void glFogi(int pname, int param) {
        var mh$ = glFogi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogi", pname, param);
            }
            mh$.invokeExact(pname, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glFogfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glFogfv$descriptor() {
        return glFogfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glFogfv$handle() {
        return glFogfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glFogfv$address() {
        return glFogfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogfv(GLenum pname, const GLfloat *params)
     * }
     */
    public static void glFogfv(int pname, MemorySegment params) {
        var mh$ = glFogfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogfv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFogiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glFogiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glFogiv$descriptor() {
        return glFogiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glFogiv$handle() {
        return glFogiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glFogiv$address() {
        return glFogiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFogiv(GLenum pname, const GLint *params)
     * }
     */
    public static void glFogiv(int pname, MemorySegment params) {
        var mh$ = glFogiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFogiv", pname, params);
            }
            mh$.invokeExact(pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glFeedbackBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glFeedbackBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static FunctionDescriptor glFeedbackBuffer$descriptor() {
        return glFeedbackBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MethodHandle glFeedbackBuffer$handle() {
        return glFeedbackBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static MemorySegment glFeedbackBuffer$address() {
        return glFeedbackBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
     * }
     */
    public static void glFeedbackBuffer(int size, int type, MemorySegment buffer) {
        var mh$ = glFeedbackBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glFeedbackBuffer", size, type, buffer);
            }
            mh$.invokeExact(size, type, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPassThrough {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPassThrough");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static FunctionDescriptor glPassThrough$descriptor() {
        return glPassThrough.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MethodHandle glPassThrough$handle() {
        return glPassThrough.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static MemorySegment glPassThrough$address() {
        return glPassThrough.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPassThrough(GLfloat token)
     * }
     */
    public static void glPassThrough(float token) {
        var mh$ = glPassThrough.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPassThrough", token);
            }
            mh$.invokeExact(token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSelectBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glSelectBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static FunctionDescriptor glSelectBuffer$descriptor() {
        return glSelectBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MethodHandle glSelectBuffer$handle() {
        return glSelectBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static MemorySegment glSelectBuffer$address() {
        return glSelectBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSelectBuffer(GLsizei size, GLuint *buffer)
     * }
     */
    public static void glSelectBuffer(int size, MemorySegment buffer) {
        var mh$ = glSelectBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSelectBuffer", size, buffer);
            }
            mh$.invokeExact(size, buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glInitNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glInitNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static FunctionDescriptor glInitNames$descriptor() {
        return glInitNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MethodHandle glInitNames$handle() {
        return glInitNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static MemorySegment glInitNames$address() {
        return glInitNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glInitNames()
     * }
     */
    public static void glInitNames() {
        var mh$ = glInitNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glInitNames");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLoadName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static FunctionDescriptor glLoadName$descriptor() {
        return glLoadName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MethodHandle glLoadName$handle() {
        return glLoadName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static MemorySegment glLoadName$address() {
        return glLoadName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadName(GLuint name)
     * }
     */
    public static void glLoadName(int name) {
        var mh$ = glLoadName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPushName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPushName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static FunctionDescriptor glPushName$descriptor() {
        return glPushName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MethodHandle glPushName$handle() {
        return glPushName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static MemorySegment glPushName$address() {
        return glPushName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPushName(GLuint name)
     * }
     */
    public static void glPushName(int name) {
        var mh$ = glPushName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPushName", name);
            }
            mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glPopName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glPopName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static FunctionDescriptor glPopName$descriptor() {
        return glPopName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MethodHandle glPopName$handle() {
        return glPopName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static MemorySegment glPopName$address() {
        return glPopName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glPopName()
     * }
     */
    public static void glPopName() {
        var mh$ = glPopName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glPopName");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glDrawRangeElements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glDrawRangeElements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static FunctionDescriptor glDrawRangeElements$descriptor() {
        return glDrawRangeElements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MethodHandle glDrawRangeElements$handle() {
        return glDrawRangeElements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static MemorySegment glDrawRangeElements$address() {
        return glDrawRangeElements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
     * }
     */
    public static void glDrawRangeElements(int mode, int start, int end, int count, int type, MemorySegment indices) {
        var mh$ = glDrawRangeElements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glDrawRangeElements", mode, start, end, count, type, indices);
            }
            mh$.invokeExact(mode, start, end, count, type, indices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexImage3D$descriptor() {
        return glTexImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexImage3D$handle() {
        return glTexImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexImage3D$address() {
        return glTexImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexImage3D(int target, int level, int internalFormat, int width, int height, int depth, int border, int format, int type, MemorySegment pixels) {
        var mh$ = glTexImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexImage3D", target, level, internalFormat, width, height, depth, border, format, type, pixels);
            }
            mh$.invokeExact(target, level, internalFormat, width, height, depth, border, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static FunctionDescriptor glTexSubImage3D$descriptor() {
        return glTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MethodHandle glTexSubImage3D$handle() {
        return glTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static MemorySegment glTexSubImage3D$address() {
        return glTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
     * }
     */
    public static void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, MemorySegment pixels) {
        var mh$ = glTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glTexSubImage3D", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyTexSubImage3D$descriptor() {
        return glCopyTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyTexSubImage3D$handle() {
        return glCopyTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyTexSubImage3D$address() {
        return glCopyTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
        var mh$ = glCopyTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyTexSubImage3D", target, level, xoffset, yoffset, zoffset, x, y, width, height);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static FunctionDescriptor glColorTable$descriptor() {
        return glColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static MethodHandle glColorTable$handle() {
        return glColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static MemorySegment glColorTable$address() {
        return glColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
     * }
     */
    public static void glColorTable(int target, int internalformat, int width, int format, int type, MemorySegment table) {
        var mh$ = glColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTable", target, internalformat, width, format, type, table);
            }
            mh$.invokeExact(target, internalformat, width, format, type, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorSubTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColorSubTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glColorSubTable$descriptor() {
        return glColorSubTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static MethodHandle glColorSubTable$handle() {
        return glColorSubTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static MemorySegment glColorSubTable$address() {
        return glColorSubTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
     * }
     */
    public static void glColorSubTable(int target, int start, int count, int format, int type, MemorySegment data) {
        var mh$ = glColorSubTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorSubTable", target, start, count, format, type, data);
            }
            mh$.invokeExact(target, start, count, format, type, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTableParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColorTableParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glColorTableParameteriv$descriptor() {
        return glColorTableParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glColorTableParameteriv$handle() {
        return glColorTableParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glColorTableParameteriv$address() {
        return glColorTableParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glColorTableParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glColorTableParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTableParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glColorTableParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glColorTableParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glColorTableParameterfv$descriptor() {
        return glColorTableParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glColorTableParameterfv$handle() {
        return glColorTableParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glColorTableParameterfv$address() {
        return glColorTableParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glColorTableParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glColorTableParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glColorTableParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyColorSubTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyColorSubTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyColorSubTable$descriptor() {
        return glCopyColorSubTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyColorSubTable$handle() {
        return glCopyColorSubTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyColorSubTable$address() {
        return glCopyColorSubTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyColorSubTable(int target, int start, int x, int y, int width) {
        var mh$ = glCopyColorSubTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyColorSubTable", target, start, x, y, width);
            }
            mh$.invokeExact(target, start, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyColorTable$descriptor() {
        return glCopyColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyColorTable$handle() {
        return glCopyColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyColorTable$address() {
        return glCopyColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyColorTable(int target, int internalformat, int x, int y, int width) {
        var mh$ = glCopyColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyColorTable", target, internalformat, x, y, width);
            }
            mh$.invokeExact(target, internalformat, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetColorTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static FunctionDescriptor glGetColorTable$descriptor() {
        return glGetColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static MethodHandle glGetColorTable$handle() {
        return glGetColorTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static MemorySegment glGetColorTable$address() {
        return glGetColorTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
     * }
     */
    public static void glGetColorTable(int target, int format, int type, MemorySegment table) {
        var mh$ = glGetColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTable", target, format, type, table);
            }
            mh$.invokeExact(target, format, type, table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTableParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetColorTableParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetColorTableParameterfv$descriptor() {
        return glGetColorTableParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetColorTableParameterfv$handle() {
        return glGetColorTableParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetColorTableParameterfv$address() {
        return glGetColorTableParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetColorTableParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetColorTableParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTableParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetColorTableParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetColorTableParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetColorTableParameteriv$descriptor() {
        return glGetColorTableParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetColorTableParameteriv$handle() {
        return glGetColorTableParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetColorTableParameteriv$address() {
        return glGetColorTableParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetColorTableParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetColorTableParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetColorTableParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendEquation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glBlendEquation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static FunctionDescriptor glBlendEquation$descriptor() {
        return glBlendEquation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static MethodHandle glBlendEquation$handle() {
        return glBlendEquation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static MemorySegment glBlendEquation$address() {
        return glBlendEquation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendEquation(GLenum mode)
     * }
     */
    public static void glBlendEquation(int mode) {
        var mh$ = glBlendEquation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquation", mode);
            }
            mh$.invokeExact(mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glBlendColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glBlendColor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static FunctionDescriptor glBlendColor$descriptor() {
        return glBlendColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MethodHandle glBlendColor$handle() {
        return glBlendColor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static MemorySegment glBlendColor$address() {
        return glBlendColor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
     * }
     */
    public static void glBlendColor(float red, float green, float blue, float alpha) {
        var mh$ = glBlendColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendColor", red, green, blue, alpha);
            }
            mh$.invokeExact(red, green, blue, alpha);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static FunctionDescriptor glHistogram$descriptor() {
        return glHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MethodHandle glHistogram$handle() {
        return glHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MemorySegment glHistogram$address() {
        return glHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
     * }
     */
    public static void glHistogram(int target, int width, int internalformat, byte sink) {
        var mh$ = glHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glHistogram", target, width, internalformat, sink);
            }
            mh$.invokeExact(target, width, internalformat, sink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glResetHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glResetHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static FunctionDescriptor glResetHistogram$descriptor() {
        return glResetHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static MethodHandle glResetHistogram$handle() {
        return glResetHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static MemorySegment glResetHistogram$address() {
        return glResetHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glResetHistogram(GLenum target)
     * }
     */
    public static void glResetHistogram(int target) {
        var mh$ = glResetHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glResetHistogram", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_CHAR,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetHistogram");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static FunctionDescriptor glGetHistogram$descriptor() {
        return glGetHistogram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MethodHandle glGetHistogram$handle() {
        return glGetHistogram.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static MemorySegment glGetHistogram$address() {
        return glGetHistogram.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
     * }
     */
    public static void glGetHistogram(int target, byte reset, int format, int type, MemorySegment values) {
        var mh$ = glGetHistogram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogram", target, reset, format, type, values);
            }
            mh$.invokeExact(target, reset, format, type, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogramParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetHistogramParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetHistogramParameterfv$descriptor() {
        return glGetHistogramParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetHistogramParameterfv$handle() {
        return glGetHistogramParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetHistogramParameterfv$address() {
        return glGetHistogramParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetHistogramParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetHistogramParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogramParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetHistogramParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetHistogramParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetHistogramParameteriv$descriptor() {
        return glGetHistogramParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetHistogramParameteriv$handle() {
        return glGetHistogramParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetHistogramParameteriv$address() {
        return glGetHistogramParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetHistogramParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetHistogramParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetHistogramParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static FunctionDescriptor glMinmax$descriptor() {
        return glMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MethodHandle glMinmax$handle() {
        return glMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static MemorySegment glMinmax$address() {
        return glMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
     * }
     */
    public static void glMinmax(int target, int internalformat, byte sink) {
        var mh$ = glMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMinmax", target, internalformat, sink);
            }
            mh$.invokeExact(target, internalformat, sink);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glResetMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glResetMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static FunctionDescriptor glResetMinmax$descriptor() {
        return glResetMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static MethodHandle glResetMinmax$handle() {
        return glResetMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static MemorySegment glResetMinmax$address() {
        return glResetMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glResetMinmax(GLenum target)
     * }
     */
    public static void glResetMinmax(int target) {
        var mh$ = glResetMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glResetMinmax", target);
            }
            mh$.invokeExact(target);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_CHAR,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetMinmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static FunctionDescriptor glGetMinmax$descriptor() {
        return glGetMinmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static MethodHandle glGetMinmax$handle() {
        return glGetMinmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static MemorySegment glGetMinmax$address() {
        return glGetMinmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
     * }
     */
    public static void glGetMinmax(int target, byte reset, int format, int types, MemorySegment values) {
        var mh$ = glGetMinmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmax", target, reset, format, types, values);
            }
            mh$.invokeExact(target, reset, format, types, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmaxParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetMinmaxParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetMinmaxParameterfv$descriptor() {
        return glGetMinmaxParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetMinmaxParameterfv$handle() {
        return glGetMinmaxParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetMinmaxParameterfv$address() {
        return glGetMinmaxParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetMinmaxParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetMinmaxParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmaxParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetMinmaxParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetMinmaxParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetMinmaxParameteriv$descriptor() {
        return glGetMinmaxParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetMinmaxParameteriv$handle() {
        return glGetMinmaxParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetMinmaxParameteriv$address() {
        return glGetMinmaxParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetMinmaxParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetMinmaxParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetMinmaxParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionFilter1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glConvolutionFilter1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static FunctionDescriptor glConvolutionFilter1D$descriptor() {
        return glConvolutionFilter1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MethodHandle glConvolutionFilter1D$handle() {
        return glConvolutionFilter1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MemorySegment glConvolutionFilter1D$address() {
        return glConvolutionFilter1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, MemorySegment image) {
        var mh$ = glConvolutionFilter1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionFilter1D", target, internalformat, width, format, type, image);
            }
            mh$.invokeExact(target, internalformat, width, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glConvolutionFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static FunctionDescriptor glConvolutionFilter2D$descriptor() {
        return glConvolutionFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MethodHandle glConvolutionFilter2D$handle() {
        return glConvolutionFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static MemorySegment glConvolutionFilter2D$address() {
        return glConvolutionFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
     * }
     */
    public static void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, MemorySegment image) {
        var mh$ = glConvolutionFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionFilter2D", target, internalformat, width, height, format, type, image);
            }
            mh$.invokeExact(target, internalformat, width, height, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glConvolutionParameterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameterf$descriptor() {
        return glConvolutionParameterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static MethodHandle glConvolutionParameterf$handle() {
        return glConvolutionParameterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static MemorySegment glConvolutionParameterf$address() {
        return glConvolutionParameterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
     * }
     */
    public static void glConvolutionParameterf(int target, int pname, float params) {
        var mh$ = glConvolutionParameterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameterf", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glConvolutionParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameterfv$descriptor() {
        return glConvolutionParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MethodHandle glConvolutionParameterfv$handle() {
        return glConvolutionParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static MemorySegment glConvolutionParameterfv$address() {
        return glConvolutionParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
     * }
     */
    public static void glConvolutionParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glConvolutionParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameteri {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glConvolutionParameteri");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameteri$descriptor() {
        return glConvolutionParameteri.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static MethodHandle glConvolutionParameteri$handle() {
        return glConvolutionParameteri.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static MemorySegment glConvolutionParameteri$address() {
        return glConvolutionParameteri.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
     * }
     */
    public static void glConvolutionParameteri(int target, int pname, int params) {
        var mh$ = glConvolutionParameteri.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameteri", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glConvolutionParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glConvolutionParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static FunctionDescriptor glConvolutionParameteriv$descriptor() {
        return glConvolutionParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MethodHandle glConvolutionParameteriv$handle() {
        return glConvolutionParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static MemorySegment glConvolutionParameteriv$address() {
        return glConvolutionParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
     * }
     */
    public static void glConvolutionParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glConvolutionParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glConvolutionParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyConvolutionFilter1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyConvolutionFilter1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static FunctionDescriptor glCopyConvolutionFilter1D$descriptor() {
        return glCopyConvolutionFilter1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MethodHandle glCopyConvolutionFilter1D$handle() {
        return glCopyConvolutionFilter1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static MemorySegment glCopyConvolutionFilter1D$address() {
        return glCopyConvolutionFilter1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
     * }
     */
    public static void glCopyConvolutionFilter1D(int target, int internalformat, int x, int y, int width) {
        var mh$ = glCopyConvolutionFilter1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyConvolutionFilter1D", target, internalformat, x, y, width);
            }
            mh$.invokeExact(target, internalformat, x, y, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCopyConvolutionFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCopyConvolutionFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static FunctionDescriptor glCopyConvolutionFilter2D$descriptor() {
        return glCopyConvolutionFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MethodHandle glCopyConvolutionFilter2D$handle() {
        return glCopyConvolutionFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static MemorySegment glCopyConvolutionFilter2D$address() {
        return glCopyConvolutionFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
     * }
     */
    public static void glCopyConvolutionFilter2D(int target, int internalformat, int x, int y, int width, int height) {
        var mh$ = glCopyConvolutionFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCopyConvolutionFilter2D", target, internalformat, x, y, width, height);
            }
            mh$.invokeExact(target, internalformat, x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetConvolutionFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static FunctionDescriptor glGetConvolutionFilter$descriptor() {
        return glGetConvolutionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static MethodHandle glGetConvolutionFilter$handle() {
        return glGetConvolutionFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static MemorySegment glGetConvolutionFilter$address() {
        return glGetConvolutionFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
     * }
     */
    public static void glGetConvolutionFilter(int target, int format, int type, MemorySegment image) {
        var mh$ = glGetConvolutionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionFilter", target, format, type, image);
            }
            mh$.invokeExact(target, format, type, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionParameterfv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetConvolutionParameterfv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static FunctionDescriptor glGetConvolutionParameterfv$descriptor() {
        return glGetConvolutionParameterfv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MethodHandle glGetConvolutionParameterfv$handle() {
        return glGetConvolutionParameterfv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static MemorySegment glGetConvolutionParameterfv$address() {
        return glGetConvolutionParameterfv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
     * }
     */
    public static void glGetConvolutionParameterfv(int target, int pname, MemorySegment params) {
        var mh$ = glGetConvolutionParameterfv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionParameterfv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetConvolutionParameteriv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetConvolutionParameteriv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static FunctionDescriptor glGetConvolutionParameteriv$descriptor() {
        return glGetConvolutionParameteriv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MethodHandle glGetConvolutionParameteriv$handle() {
        return glGetConvolutionParameteriv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static MemorySegment glGetConvolutionParameteriv$address() {
        return glGetConvolutionParameteriv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
     * }
     */
    public static void glGetConvolutionParameteriv(int target, int pname, MemorySegment params) {
        var mh$ = glGetConvolutionParameteriv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetConvolutionParameteriv", target, pname, params);
            }
            mh$.invokeExact(target, pname, params);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSeparableFilter2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glSeparableFilter2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static FunctionDescriptor glSeparableFilter2D$descriptor() {
        return glSeparableFilter2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static MethodHandle glSeparableFilter2D$handle() {
        return glSeparableFilter2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static MemorySegment glSeparableFilter2D$address() {
        return glSeparableFilter2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
     * }
     */
    public static void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, MemorySegment row, MemorySegment column) {
        var mh$ = glSeparableFilter2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSeparableFilter2D", target, internalformat, width, height, format, type, row, column);
            }
            mh$.invokeExact(target, internalformat, width, height, format, type, row, column);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetSeparableFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetSeparableFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static FunctionDescriptor glGetSeparableFilter$descriptor() {
        return glGetSeparableFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static MethodHandle glGetSeparableFilter$handle() {
        return glGetSeparableFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static MemorySegment glGetSeparableFilter$address() {
        return glGetSeparableFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
     * }
     */
    public static void glGetSeparableFilter(int target, int format, int type, MemorySegment row, MemorySegment column, MemorySegment span) {
        var mh$ = glGetSeparableFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetSeparableFilter", target, format, type, row, column, span);
            }
            mh$.invokeExact(target, format, type, row, column, span);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glActiveTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glActiveTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static FunctionDescriptor glActiveTexture$descriptor() {
        return glActiveTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static MethodHandle glActiveTexture$handle() {
        return glActiveTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static MemorySegment glActiveTexture$address() {
        return glActiveTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glActiveTexture(GLenum texture)
     * }
     */
    public static void glActiveTexture(int texture) {
        var mh$ = glActiveTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glActiveTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClientActiveTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glClientActiveTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static FunctionDescriptor glClientActiveTexture$descriptor() {
        return glClientActiveTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static MethodHandle glClientActiveTexture$handle() {
        return glClientActiveTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static MemorySegment glClientActiveTexture$address() {
        return glClientActiveTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClientActiveTexture(GLenum texture)
     * }
     */
    public static void glClientActiveTexture(int texture) {
        var mh$ = glClientActiveTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClientActiveTexture", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCompressedTexImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage1D$descriptor() {
        return glCompressedTexImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage1D$handle() {
        return glCompressedTexImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage1D$address() {
        return glCompressedTexImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage1D", target, level, internalformat, width, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCompressedTexImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage2D$descriptor() {
        return glCompressedTexImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage2D$handle() {
        return glCompressedTexImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage2D$address() {
        return glCompressedTexImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage2D", target, level, internalformat, width, height, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCompressedTexImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexImage3D$descriptor() {
        return glCompressedTexImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexImage3D$handle() {
        return glCompressedTexImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexImage3D$address() {
        return glCompressedTexImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexImage3D", target, level, internalformat, width, height, depth, border, imageSize, data);
            }
            mh$.invokeExact(target, level, internalformat, width, height, depth, border, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage1D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCompressedTexSubImage1D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage1D$descriptor() {
        return glCompressedTexSubImage1D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage1D$handle() {
        return glCompressedTexSubImage1D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage1D$address() {
        return glCompressedTexSubImage1D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage1D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage1D", target, level, xoffset, width, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, width, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCompressedTexSubImage2D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage2D$descriptor() {
        return glCompressedTexSubImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage2D$handle() {
        return glCompressedTexSubImage2D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage2D$address() {
        return glCompressedTexSubImage2D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage2D", target, level, xoffset, yoffset, width, height, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glCompressedTexSubImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glCompressedTexSubImage3D");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static FunctionDescriptor glCompressedTexSubImage3D$descriptor() {
        return glCompressedTexSubImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MethodHandle glCompressedTexSubImage3D$handle() {
        return glCompressedTexSubImage3D.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static MemorySegment glCompressedTexSubImage3D$address() {
        return glCompressedTexSubImage3D.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
     * }
     */
    public static void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, MemorySegment data) {
        var mh$ = glCompressedTexSubImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glCompressedTexSubImage3D", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
            }
            mh$.invokeExact(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glGetCompressedTexImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glGetCompressedTexImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static FunctionDescriptor glGetCompressedTexImage$descriptor() {
        return glGetCompressedTexImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static MethodHandle glGetCompressedTexImage$handle() {
        return glGetCompressedTexImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static MemorySegment glGetCompressedTexImage$address() {
        return glGetCompressedTexImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
     * }
     */
    public static void glGetCompressedTexImage(int target, int lod, MemorySegment img) {
        var mh$ = glGetCompressedTexImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glGetCompressedTexImage", target, lod, img);
            }
            mh$.invokeExact(target, lod, img);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1d$descriptor() {
        return glMultiTexCoord1d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static MethodHandle glMultiTexCoord1d$handle() {
        return glMultiTexCoord1d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static MemorySegment glMultiTexCoord1d$address() {
        return glMultiTexCoord1d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1d(GLenum target, GLdouble s)
     * }
     */
    public static void glMultiTexCoord1d(int target, double s) {
        var mh$ = glMultiTexCoord1d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1d", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dv$descriptor() {
        return glMultiTexCoord1dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1dv$handle() {
        return glMultiTexCoord1dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1dv$address() {
        return glMultiTexCoord1dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord1dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1f$descriptor() {
        return glMultiTexCoord1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static MethodHandle glMultiTexCoord1f$handle() {
        return glMultiTexCoord1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static MemorySegment glMultiTexCoord1f$address() {
        return glMultiTexCoord1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1f(GLenum target, GLfloat s)
     * }
     */
    public static void glMultiTexCoord1f(int target, float s) {
        var mh$ = glMultiTexCoord1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1f", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fv$descriptor() {
        return glMultiTexCoord1fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1fv$handle() {
        return glMultiTexCoord1fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1fv$address() {
        return glMultiTexCoord1fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord1fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1i$descriptor() {
        return glMultiTexCoord1i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static MethodHandle glMultiTexCoord1i$handle() {
        return glMultiTexCoord1i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static MemorySegment glMultiTexCoord1i$address() {
        return glMultiTexCoord1i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1i(GLenum target, GLint s)
     * }
     */
    public static void glMultiTexCoord1i(int target, int s) {
        var mh$ = glMultiTexCoord1i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1i", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1iv$descriptor() {
        return glMultiTexCoord1iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1iv$handle() {
        return glMultiTexCoord1iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1iv$address() {
        return glMultiTexCoord1iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord1iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1s$descriptor() {
        return glMultiTexCoord1s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static MethodHandle glMultiTexCoord1s$handle() {
        return glMultiTexCoord1s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static MemorySegment glMultiTexCoord1s$address() {
        return glMultiTexCoord1s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1s(GLenum target, GLshort s)
     * }
     */
    public static void glMultiTexCoord1s(int target, short s) {
        var mh$ = glMultiTexCoord1s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1s", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1sv$descriptor() {
        return glMultiTexCoord1sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1sv$handle() {
        return glMultiTexCoord1sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1sv$address() {
        return glMultiTexCoord1sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord1sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2d$descriptor() {
        return glMultiTexCoord2d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glMultiTexCoord2d$handle() {
        return glMultiTexCoord2d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glMultiTexCoord2d$address() {
        return glMultiTexCoord2d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static void glMultiTexCoord2d(int target, double s, double t) {
        var mh$ = glMultiTexCoord2d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2d", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dv$descriptor() {
        return glMultiTexCoord2dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2dv$handle() {
        return glMultiTexCoord2dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2dv$address() {
        return glMultiTexCoord2dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord2dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2f$descriptor() {
        return glMultiTexCoord2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glMultiTexCoord2f$handle() {
        return glMultiTexCoord2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glMultiTexCoord2f$address() {
        return glMultiTexCoord2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static void glMultiTexCoord2f(int target, float s, float t) {
        var mh$ = glMultiTexCoord2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2f", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fv$descriptor() {
        return glMultiTexCoord2fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2fv$handle() {
        return glMultiTexCoord2fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2fv$address() {
        return glMultiTexCoord2fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord2fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2i$descriptor() {
        return glMultiTexCoord2i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static MethodHandle glMultiTexCoord2i$handle() {
        return glMultiTexCoord2i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static MemorySegment glMultiTexCoord2i$address() {
        return glMultiTexCoord2i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2i(GLenum target, GLint s, GLint t)
     * }
     */
    public static void glMultiTexCoord2i(int target, int s, int t) {
        var mh$ = glMultiTexCoord2i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2i", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2iv$descriptor() {
        return glMultiTexCoord2iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2iv$handle() {
        return glMultiTexCoord2iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2iv$address() {
        return glMultiTexCoord2iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord2iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2s$descriptor() {
        return glMultiTexCoord2s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glMultiTexCoord2s$handle() {
        return glMultiTexCoord2s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glMultiTexCoord2s$address() {
        return glMultiTexCoord2s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static void glMultiTexCoord2s(int target, short s, short t) {
        var mh$ = glMultiTexCoord2s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2s", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2sv$descriptor() {
        return glMultiTexCoord2sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2sv$handle() {
        return glMultiTexCoord2sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2sv$address() {
        return glMultiTexCoord2sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord2sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3d$descriptor() {
        return glMultiTexCoord3d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glMultiTexCoord3d$handle() {
        return glMultiTexCoord3d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glMultiTexCoord3d$address() {
        return glMultiTexCoord3d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glMultiTexCoord3d(int target, double s, double t, double r) {
        var mh$ = glMultiTexCoord3d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3d", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dv$descriptor() {
        return glMultiTexCoord3dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3dv$handle() {
        return glMultiTexCoord3dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3dv$address() {
        return glMultiTexCoord3dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord3dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3f$descriptor() {
        return glMultiTexCoord3f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glMultiTexCoord3f$handle() {
        return glMultiTexCoord3f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glMultiTexCoord3f$address() {
        return glMultiTexCoord3f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glMultiTexCoord3f(int target, float s, float t, float r) {
        var mh$ = glMultiTexCoord3f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3f", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fv$descriptor() {
        return glMultiTexCoord3fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3fv$handle() {
        return glMultiTexCoord3fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3fv$address() {
        return glMultiTexCoord3fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord3fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3i$descriptor() {
        return glMultiTexCoord3i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glMultiTexCoord3i$handle() {
        return glMultiTexCoord3i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glMultiTexCoord3i$address() {
        return glMultiTexCoord3i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static void glMultiTexCoord3i(int target, int s, int t, int r) {
        var mh$ = glMultiTexCoord3i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3i", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3iv$descriptor() {
        return glMultiTexCoord3iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3iv$handle() {
        return glMultiTexCoord3iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3iv$address() {
        return glMultiTexCoord3iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord3iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3s$descriptor() {
        return glMultiTexCoord3s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glMultiTexCoord3s$handle() {
        return glMultiTexCoord3s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glMultiTexCoord3s$address() {
        return glMultiTexCoord3s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glMultiTexCoord3s(int target, short s, short t, short r) {
        var mh$ = glMultiTexCoord3s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3s", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3sv$descriptor() {
        return glMultiTexCoord3sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3sv$handle() {
        return glMultiTexCoord3sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3sv$address() {
        return glMultiTexCoord3sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord3sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4d$descriptor() {
        return glMultiTexCoord4d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glMultiTexCoord4d$handle() {
        return glMultiTexCoord4d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glMultiTexCoord4d$address() {
        return glMultiTexCoord4d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glMultiTexCoord4d(int target, double s, double t, double r, double q) {
        var mh$ = glMultiTexCoord4d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4d", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4dv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dv$descriptor() {
        return glMultiTexCoord4dv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4dv$handle() {
        return glMultiTexCoord4dv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4dv$address() {
        return glMultiTexCoord4dv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4dv(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord4dv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4dv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4f$descriptor() {
        return glMultiTexCoord4f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glMultiTexCoord4f$handle() {
        return glMultiTexCoord4f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glMultiTexCoord4f$address() {
        return glMultiTexCoord4f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glMultiTexCoord4f(int target, float s, float t, float r, float q) {
        var mh$ = glMultiTexCoord4f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4f", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4fv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fv$descriptor() {
        return glMultiTexCoord4fv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4fv$handle() {
        return glMultiTexCoord4fv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4fv$address() {
        return glMultiTexCoord4fv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4fv(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord4fv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4fv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4i {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4i");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4i$descriptor() {
        return glMultiTexCoord4i.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glMultiTexCoord4i$handle() {
        return glMultiTexCoord4i.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glMultiTexCoord4i$address() {
        return glMultiTexCoord4i.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glMultiTexCoord4i(int target, int s, int t, int r, int q) {
        var mh$ = glMultiTexCoord4i.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4i", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4iv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4iv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4iv$descriptor() {
        return glMultiTexCoord4iv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4iv$handle() {
        return glMultiTexCoord4iv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4iv$address() {
        return glMultiTexCoord4iv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4iv(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord4iv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4iv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4iv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4s$descriptor() {
        return glMultiTexCoord4s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glMultiTexCoord4s$handle() {
        return glMultiTexCoord4s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glMultiTexCoord4s$address() {
        return glMultiTexCoord4s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glMultiTexCoord4s(int target, short s, short t, short r, short q) {
        var mh$ = glMultiTexCoord4s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4s", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4sv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4sv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4sv$descriptor() {
        return glMultiTexCoord4sv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4sv$handle() {
        return glMultiTexCoord4sv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4sv$address() {
        return glMultiTexCoord4sv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4sv(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord4sv(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4sv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4sv", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLoadTransposeMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixd$descriptor() {
        return glLoadTransposeMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MethodHandle glLoadTransposeMatrixd$handle() {
        return glLoadTransposeMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MemorySegment glLoadTransposeMatrixd$address() {
        return glLoadTransposeMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static void glLoadTransposeMatrixd(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glLoadTransposeMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glLoadTransposeMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static FunctionDescriptor glLoadTransposeMatrixf$descriptor() {
        return glLoadTransposeMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MethodHandle glLoadTransposeMatrixf$handle() {
        return glLoadTransposeMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MemorySegment glLoadTransposeMatrixf$address() {
        return glLoadTransposeMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glLoadTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static void glLoadTransposeMatrixf(MemorySegment m) {
        var mh$ = glLoadTransposeMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glLoadTransposeMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultTransposeMatrixd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixd$descriptor() {
        return glMultTransposeMatrixd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MethodHandle glMultTransposeMatrixd$handle() {
        return glMultTransposeMatrixd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static MemorySegment glMultTransposeMatrixd$address() {
        return glMultTransposeMatrixd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultTransposeMatrixd(const GLdouble m[16])
     * }
     */
    public static void glMultTransposeMatrixd(MemorySegment m) {
        var mh$ = glMultTransposeMatrixd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixd", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultTransposeMatrixf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultTransposeMatrixf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static FunctionDescriptor glMultTransposeMatrixf$descriptor() {
        return glMultTransposeMatrixf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MethodHandle glMultTransposeMatrixf$handle() {
        return glMultTransposeMatrixf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static MemorySegment glMultTransposeMatrixf$address() {
        return glMultTransposeMatrixf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultTransposeMatrixf(const GLfloat m[16])
     * }
     */
    public static void glMultTransposeMatrixf(MemorySegment m) {
        var mh$ = glMultTransposeMatrixf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultTransposeMatrixf", m);
            }
            mh$.invokeExact(m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glSampleCoverage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_FLOAT,
            glfw3_h.C_CHAR
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glSampleCoverage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static FunctionDescriptor glSampleCoverage$descriptor() {
        return glSampleCoverage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static MethodHandle glSampleCoverage$handle() {
        return glSampleCoverage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static MemorySegment glSampleCoverage$address() {
        return glSampleCoverage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glSampleCoverage(GLclampf value, GLboolean invert)
     * }
     */
    public static void glSampleCoverage(float value, byte invert) {
        var mh$ = glSampleCoverage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glSampleCoverage", value, invert);
            }
            mh$.invokeExact(value, invert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glActiveTextureARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glActiveTextureARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static FunctionDescriptor glActiveTextureARB$descriptor() {
        return glActiveTextureARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static MethodHandle glActiveTextureARB$handle() {
        return glActiveTextureARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static MemorySegment glActiveTextureARB$address() {
        return glActiveTextureARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glActiveTextureARB(GLenum texture)
     * }
     */
    public static void glActiveTextureARB(int texture) {
        var mh$ = glActiveTextureARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glActiveTextureARB", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glClientActiveTextureARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glClientActiveTextureARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static FunctionDescriptor glClientActiveTextureARB$descriptor() {
        return glClientActiveTextureARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static MethodHandle glClientActiveTextureARB$handle() {
        return glClientActiveTextureARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static MemorySegment glClientActiveTextureARB$address() {
        return glClientActiveTextureARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glClientActiveTextureARB(GLenum texture)
     * }
     */
    public static void glClientActiveTextureARB(int texture) {
        var mh$ = glClientActiveTextureARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glClientActiveTextureARB", texture);
            }
            mh$.invokeExact(texture);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dARB$descriptor() {
        return glMultiTexCoord1dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static MethodHandle glMultiTexCoord1dARB$handle() {
        return glMultiTexCoord1dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static MemorySegment glMultiTexCoord1dARB$address() {
        return glMultiTexCoord1dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1dARB(GLenum target, GLdouble s)
     * }
     */
    public static void glMultiTexCoord1dARB(int target, double s) {
        var mh$ = glMultiTexCoord1dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1dvARB$descriptor() {
        return glMultiTexCoord1dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1dvARB$handle() {
        return glMultiTexCoord1dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1dvARB$address() {
        return glMultiTexCoord1dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord1dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fARB$descriptor() {
        return glMultiTexCoord1fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static MethodHandle glMultiTexCoord1fARB$handle() {
        return glMultiTexCoord1fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static MemorySegment glMultiTexCoord1fARB$address() {
        return glMultiTexCoord1fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1fARB(GLenum target, GLfloat s)
     * }
     */
    public static void glMultiTexCoord1fARB(int target, float s) {
        var mh$ = glMultiTexCoord1fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1fvARB$descriptor() {
        return glMultiTexCoord1fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1fvARB$handle() {
        return glMultiTexCoord1fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1fvARB$address() {
        return glMultiTexCoord1fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord1fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1iARB$descriptor() {
        return glMultiTexCoord1iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static MethodHandle glMultiTexCoord1iARB$handle() {
        return glMultiTexCoord1iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static MemorySegment glMultiTexCoord1iARB$address() {
        return glMultiTexCoord1iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1iARB(GLenum target, GLint s)
     * }
     */
    public static void glMultiTexCoord1iARB(int target, int s) {
        var mh$ = glMultiTexCoord1iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1iARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1ivARB$descriptor() {
        return glMultiTexCoord1ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1ivARB$handle() {
        return glMultiTexCoord1ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1ivARB$address() {
        return glMultiTexCoord1ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord1ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1sARB$descriptor() {
        return glMultiTexCoord1sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static MethodHandle glMultiTexCoord1sARB$handle() {
        return glMultiTexCoord1sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static MemorySegment glMultiTexCoord1sARB$address() {
        return glMultiTexCoord1sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1sARB(GLenum target, GLshort s)
     * }
     */
    public static void glMultiTexCoord1sARB(int target, short s) {
        var mh$ = glMultiTexCoord1sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1sARB", target, s);
            }
            mh$.invokeExact(target, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord1svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord1svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord1svARB$descriptor() {
        return glMultiTexCoord1svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord1svARB$handle() {
        return glMultiTexCoord1svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord1svARB$address() {
        return glMultiTexCoord1svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord1svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord1svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord1svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord1svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dARB$descriptor() {
        return glMultiTexCoord2dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MethodHandle glMultiTexCoord2dARB$handle() {
        return glMultiTexCoord2dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static MemorySegment glMultiTexCoord2dARB$address() {
        return glMultiTexCoord2dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
     * }
     */
    public static void glMultiTexCoord2dARB(int target, double s, double t) {
        var mh$ = glMultiTexCoord2dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2dvARB$descriptor() {
        return glMultiTexCoord2dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2dvARB$handle() {
        return glMultiTexCoord2dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2dvARB$address() {
        return glMultiTexCoord2dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord2dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fARB$descriptor() {
        return glMultiTexCoord2fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MethodHandle glMultiTexCoord2fARB$handle() {
        return glMultiTexCoord2fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static MemorySegment glMultiTexCoord2fARB$address() {
        return glMultiTexCoord2fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
     * }
     */
    public static void glMultiTexCoord2fARB(int target, float s, float t) {
        var mh$ = glMultiTexCoord2fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2fvARB$descriptor() {
        return glMultiTexCoord2fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2fvARB$handle() {
        return glMultiTexCoord2fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2fvARB$address() {
        return glMultiTexCoord2fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord2fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2iARB$descriptor() {
        return glMultiTexCoord2iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static MethodHandle glMultiTexCoord2iARB$handle() {
        return glMultiTexCoord2iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static MemorySegment glMultiTexCoord2iARB$address() {
        return glMultiTexCoord2iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
     * }
     */
    public static void glMultiTexCoord2iARB(int target, int s, int t) {
        var mh$ = glMultiTexCoord2iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2iARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2ivARB$descriptor() {
        return glMultiTexCoord2ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2ivARB$handle() {
        return glMultiTexCoord2ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2ivARB$address() {
        return glMultiTexCoord2ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord2ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2sARB$descriptor() {
        return glMultiTexCoord2sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MethodHandle glMultiTexCoord2sARB$handle() {
        return glMultiTexCoord2sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static MemorySegment glMultiTexCoord2sARB$address() {
        return glMultiTexCoord2sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
     * }
     */
    public static void glMultiTexCoord2sARB(int target, short s, short t) {
        var mh$ = glMultiTexCoord2sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2sARB", target, s, t);
            }
            mh$.invokeExact(target, s, t);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord2svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord2svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord2svARB$descriptor() {
        return glMultiTexCoord2svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord2svARB$handle() {
        return glMultiTexCoord2svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord2svARB$address() {
        return glMultiTexCoord2svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord2svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord2svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord2svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord2svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dARB$descriptor() {
        return glMultiTexCoord3dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MethodHandle glMultiTexCoord3dARB$handle() {
        return glMultiTexCoord3dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static MemorySegment glMultiTexCoord3dARB$address() {
        return glMultiTexCoord3dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
     * }
     */
    public static void glMultiTexCoord3dARB(int target, double s, double t, double r) {
        var mh$ = glMultiTexCoord3dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3dvARB$descriptor() {
        return glMultiTexCoord3dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3dvARB$handle() {
        return glMultiTexCoord3dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3dvARB$address() {
        return glMultiTexCoord3dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord3dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fARB$descriptor() {
        return glMultiTexCoord3fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MethodHandle glMultiTexCoord3fARB$handle() {
        return glMultiTexCoord3fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static MemorySegment glMultiTexCoord3fARB$address() {
        return glMultiTexCoord3fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
     * }
     */
    public static void glMultiTexCoord3fARB(int target, float s, float t, float r) {
        var mh$ = glMultiTexCoord3fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3fvARB$descriptor() {
        return glMultiTexCoord3fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3fvARB$handle() {
        return glMultiTexCoord3fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3fvARB$address() {
        return glMultiTexCoord3fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord3fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3iARB$descriptor() {
        return glMultiTexCoord3iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MethodHandle glMultiTexCoord3iARB$handle() {
        return glMultiTexCoord3iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static MemorySegment glMultiTexCoord3iARB$address() {
        return glMultiTexCoord3iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
     * }
     */
    public static void glMultiTexCoord3iARB(int target, int s, int t, int r) {
        var mh$ = glMultiTexCoord3iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3iARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3ivARB$descriptor() {
        return glMultiTexCoord3ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3ivARB$handle() {
        return glMultiTexCoord3ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3ivARB$address() {
        return glMultiTexCoord3ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord3ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3sARB$descriptor() {
        return glMultiTexCoord3sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MethodHandle glMultiTexCoord3sARB$handle() {
        return glMultiTexCoord3sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static MemorySegment glMultiTexCoord3sARB$address() {
        return glMultiTexCoord3sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
     * }
     */
    public static void glMultiTexCoord3sARB(int target, short s, short t, short r) {
        var mh$ = glMultiTexCoord3sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3sARB", target, s, t, r);
            }
            mh$.invokeExact(target, s, t, r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord3svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord3svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord3svARB$descriptor() {
        return glMultiTexCoord3svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord3svARB$handle() {
        return glMultiTexCoord3svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord3svARB$address() {
        return glMultiTexCoord3svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord3svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord3svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord3svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord3svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4dARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dARB$descriptor() {
        return glMultiTexCoord4dARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MethodHandle glMultiTexCoord4dARB$handle() {
        return glMultiTexCoord4dARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static MemorySegment glMultiTexCoord4dARB$address() {
        return glMultiTexCoord4dARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
     * }
     */
    public static void glMultiTexCoord4dARB(int target, double s, double t, double r, double q) {
        var mh$ = glMultiTexCoord4dARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4dvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4dvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4dvARB$descriptor() {
        return glMultiTexCoord4dvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4dvARB$handle() {
        return glMultiTexCoord4dvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4dvARB$address() {
        return glMultiTexCoord4dvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
     * }
     */
    public static void glMultiTexCoord4dvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4dvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4dvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4fARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fARB$descriptor() {
        return glMultiTexCoord4fARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MethodHandle glMultiTexCoord4fARB$handle() {
        return glMultiTexCoord4fARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static MemorySegment glMultiTexCoord4fARB$address() {
        return glMultiTexCoord4fARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
     * }
     */
    public static void glMultiTexCoord4fARB(int target, float s, float t, float r, float q) {
        var mh$ = glMultiTexCoord4fARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4fvARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4fvARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4fvARB$descriptor() {
        return glMultiTexCoord4fvARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4fvARB$handle() {
        return glMultiTexCoord4fvARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4fvARB$address() {
        return glMultiTexCoord4fvARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
     * }
     */
    public static void glMultiTexCoord4fvARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4fvARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4fvARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4iARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4iARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4iARB$descriptor() {
        return glMultiTexCoord4iARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MethodHandle glMultiTexCoord4iARB$handle() {
        return glMultiTexCoord4iARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static MemorySegment glMultiTexCoord4iARB$address() {
        return glMultiTexCoord4iARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
     * }
     */
    public static void glMultiTexCoord4iARB(int target, int s, int t, int r, int q) {
        var mh$ = glMultiTexCoord4iARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4iARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4ivARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4ivARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4ivARB$descriptor() {
        return glMultiTexCoord4ivARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4ivARB$handle() {
        return glMultiTexCoord4ivARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4ivARB$address() {
        return glMultiTexCoord4ivARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4ivARB(GLenum target, const GLint *v)
     * }
     */
    public static void glMultiTexCoord4ivARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4ivARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4ivARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4sARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT,
            glfw3_h.C_SHORT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4sARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4sARB$descriptor() {
        return glMultiTexCoord4sARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MethodHandle glMultiTexCoord4sARB$handle() {
        return glMultiTexCoord4sARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static MemorySegment glMultiTexCoord4sARB$address() {
        return glMultiTexCoord4sARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
     * }
     */
    public static void glMultiTexCoord4sARB(int target, short s, short t, short r, short q) {
        var mh$ = glMultiTexCoord4sARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4sARB", target, s, t, r, q);
            }
            mh$.invokeExact(target, s, t, r, q);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glMultiTexCoord4svARB {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glMultiTexCoord4svARB");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static FunctionDescriptor glMultiTexCoord4svARB$descriptor() {
        return glMultiTexCoord4svARB.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MethodHandle glMultiTexCoord4svARB$handle() {
        return glMultiTexCoord4svARB.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static MemorySegment glMultiTexCoord4svARB$address() {
        return glMultiTexCoord4svARB.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glMultiTexCoord4svARB(GLenum target, const GLshort *v)
     * }
     */
    public static void glMultiTexCoord4svARB(int target, MemorySegment v) {
        var mh$ = glMultiTexCoord4svARB.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glMultiTexCoord4svARB", target, v);
            }
            mh$.invokeExact(target, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int32_t khronos_int32_t
     * }
     */
    public static final OfInt khronos_int32_t = glfw3_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t khronos_uint32_t
     * }
     */
    public static final OfInt khronos_uint32_t = glfw3_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t khronos_int64_t
     * }
     */
    public static final OfLong khronos_int64_t = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint64_t khronos_uint64_t
     * }
     */
    public static final OfLong khronos_uint64_t = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char khronos_int8_t
     * }
     */
    public static final OfByte khronos_int8_t = glfw3_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char khronos_uint8_t
     * }
     */
    public static final OfByte khronos_uint8_t = glfw3_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short khronos_int16_t
     * }
     */
    public static final OfShort khronos_int16_t = glfw3_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short khronos_uint16_t
     * }
     */
    public static final OfShort khronos_uint16_t = glfw3_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long khronos_intptr_t
     * }
     */
    public static final OfLong khronos_intptr_t = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long khronos_uintptr_t
     * }
     */
    public static final OfLong khronos_uintptr_t = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long khronos_ssize_t
     * }
     */
    public static final OfLong khronos_ssize_t = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long khronos_usize_t
     * }
     */
    public static final OfLong khronos_usize_t = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef float khronos_float_t
     * }
     */
    public static final OfFloat khronos_float_t = glfw3_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint64_t khronos_utime_nanoseconds_t
     * }
     */
    public static final OfLong khronos_utime_nanoseconds_t = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_int64_t khronos_stime_nanoseconds_t
     * }
     */
    public static final OfLong khronos_stime_nanoseconds_t = glfw3_h.C_LONG;
    private static final int KHRONOS_FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KHRONOS_FALSE = 0
     * }
     */
    public static int KHRONOS_FALSE() {
        return KHRONOS_FALSE;
    }
    private static final int KHRONOS_TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KHRONOS_TRUE = 1
     * }
     */
    public static int KHRONOS_TRUE() {
        return KHRONOS_TRUE;
    }
    private static final int KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.KHRONOS_BOOLEAN_ENUM_FORCE_SIZE = 2147483647
     * }
     */
    public static int KHRONOS_BOOLEAN_ENUM_FORCE_SIZE() {
        return KHRONOS_BOOLEAN_ENUM_FORCE_SIZE;
    }
    /**
     * {@snippet lang=c :
     * typedef khronos_ssize_t GLsizeiptr
     * }
     */
    public static final OfLong GLsizeiptr = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_intptr_t GLintptr
     * }
     */
    public static final OfLong GLintptr = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char GLchar
     * }
     */
    public static final OfByte GLchar = glfw3_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint16_t GLhalf
     * }
     */
    public static final OfShort GLhalf = glfw3_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct __GLsync *GLsync
     * }
     */
    public static final AddressLayout GLsync = glfw3_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint64_t GLuint64
     * }
     */
    public static final OfLong GLuint64 = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_int64_t GLint64
     * }
     */
    public static final OfLong GLint64 = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint64_t GLuint64EXT
     * }
     */
    public static final OfLong GLuint64EXT = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_uint16_t GLhalfARB
     * }
     */
    public static final OfShort GLhalfARB = glfw3_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int GLhandleARB
     * }
     */
    public static final OfInt GLhandleARB = glfw3_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef char GLcharARB
     * }
     */
    public static final OfByte GLcharARB = glfw3_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef khronos_ssize_t GLsizeiptrARB
     * }
     */
    public static final OfLong GLsizeiptrARB = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_intptr_t GLintptrARB
     * }
     */
    public static final OfLong GLintptrARB = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef khronos_int32_t GLfixed
     * }
     */
    public static final OfInt GLfixed = glfw3_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef khronos_int64_t GLint64EXT
     * }
     */
    public static final OfLong GLint64EXT = glfw3_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *GLeglImageOES
     * }
     */
    public static final AddressLayout GLeglImageOES = glfw3_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *GLeglClientBufferEXT
     * }
     */
    public static final AddressLayout GLeglClientBufferEXT = glfw3_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned short GLhalfNV
     * }
     */
    public static final OfShort GLhalfNV = glfw3_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef GLintptr GLvdpauSurfaceNV
     * }
     */
    public static final OfLong GLvdpauSurfaceNV = glfw3_h.C_LONG;

    private static class glBlendEquationSeparateATI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glBlendEquationSeparateATI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static FunctionDescriptor glBlendEquationSeparateATI$descriptor() {
        return glBlendEquationSeparateATI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static MethodHandle glBlendEquationSeparateATI$handle() {
        return glBlendEquationSeparateATI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static MemorySegment glBlendEquationSeparateATI$address() {
        return glBlendEquationSeparateATI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glBlendEquationSeparateATI(GLenum modeRGB, GLenum modeA)
     * }
     */
    public static void glBlendEquationSeparateATI(int modeRGB, int modeA) {
        var mh$ = glBlendEquationSeparateATI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glBlendEquationSeparateATI", modeRGB, modeA);
            }
            mh$.invokeExact(modeRGB, modeA);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwInit()
     * }
     */
    public static FunctionDescriptor glfwInit$descriptor() {
        return glfwInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwInit()
     * }
     */
    public static MethodHandle glfwInit$handle() {
        return glfwInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwInit()
     * }
     */
    public static MemorySegment glfwInit$address() {
        return glfwInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwInit()
     * }
     */
    public static int glfwInit() {
        var mh$ = glfwInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwInit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwTerminate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwTerminate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwTerminate()
     * }
     */
    public static FunctionDescriptor glfwTerminate$descriptor() {
        return glfwTerminate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwTerminate()
     * }
     */
    public static MethodHandle glfwTerminate$handle() {
        return glfwTerminate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwTerminate()
     * }
     */
    public static MemorySegment glfwTerminate$address() {
        return glfwTerminate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwTerminate()
     * }
     */
    public static void glfwTerminate() {
        var mh$ = glfwTerminate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwTerminate");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwInitHint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwInitHint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwInitHint(int hint, int value)
     * }
     */
    public static FunctionDescriptor glfwInitHint$descriptor() {
        return glfwInitHint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwInitHint(int hint, int value)
     * }
     */
    public static MethodHandle glfwInitHint$handle() {
        return glfwInitHint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwInitHint(int hint, int value)
     * }
     */
    public static MemorySegment glfwInitHint$address() {
        return glfwInitHint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwInitHint(int hint, int value)
     * }
     */
    public static void glfwInitHint(int hint, int value) {
        var mh$ = glfwInitHint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwInitHint", hint, value);
            }
            mh$.invokeExact(hint, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwInitAllocator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwInitAllocator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwInitAllocator(const GLFWallocator *allocator)
     * }
     */
    public static FunctionDescriptor glfwInitAllocator$descriptor() {
        return glfwInitAllocator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwInitAllocator(const GLFWallocator *allocator)
     * }
     */
    public static MethodHandle glfwInitAllocator$handle() {
        return glfwInitAllocator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwInitAllocator(const GLFWallocator *allocator)
     * }
     */
    public static MemorySegment glfwInitAllocator$address() {
        return glfwInitAllocator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwInitAllocator(const GLFWallocator *allocator)
     * }
     */
    public static void glfwInitAllocator(MemorySegment allocator) {
        var mh$ = glfwInitAllocator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwInitAllocator", allocator);
            }
            mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwInitVulkanLoader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwInitVulkanLoader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwInitVulkanLoader(PFN_vkGetInstanceProcAddr loader)
     * }
     */
    public static FunctionDescriptor glfwInitVulkanLoader$descriptor() {
        return glfwInitVulkanLoader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwInitVulkanLoader(PFN_vkGetInstanceProcAddr loader)
     * }
     */
    public static MethodHandle glfwInitVulkanLoader$handle() {
        return glfwInitVulkanLoader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwInitVulkanLoader(PFN_vkGetInstanceProcAddr loader)
     * }
     */
    public static MemorySegment glfwInitVulkanLoader$address() {
        return glfwInitVulkanLoader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwInitVulkanLoader(PFN_vkGetInstanceProcAddr loader)
     * }
     */
    public static void glfwInitVulkanLoader(MemorySegment loader) {
        var mh$ = glfwInitVulkanLoader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwInitVulkanLoader", loader);
            }
            mh$.invokeExact(loader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetVersion(int *major, int *minor, int *rev)
     * }
     */
    public static FunctionDescriptor glfwGetVersion$descriptor() {
        return glfwGetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetVersion(int *major, int *minor, int *rev)
     * }
     */
    public static MethodHandle glfwGetVersion$handle() {
        return glfwGetVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetVersion(int *major, int *minor, int *rev)
     * }
     */
    public static MemorySegment glfwGetVersion$address() {
        return glfwGetVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetVersion(int *major, int *minor, int *rev)
     * }
     */
    public static void glfwGetVersion(MemorySegment major, MemorySegment minor, MemorySegment rev) {
        var mh$ = glfwGetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetVersion", major, minor, rev);
            }
            mh$.invokeExact(major, minor, rev);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetVersionString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetVersionString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *glfwGetVersionString()
     * }
     */
    public static FunctionDescriptor glfwGetVersionString$descriptor() {
        return glfwGetVersionString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *glfwGetVersionString()
     * }
     */
    public static MethodHandle glfwGetVersionString$handle() {
        return glfwGetVersionString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *glfwGetVersionString()
     * }
     */
    public static MemorySegment glfwGetVersionString$address() {
        return glfwGetVersionString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *glfwGetVersionString()
     * }
     */
    public static MemorySegment glfwGetVersionString() {
        var mh$ = glfwGetVersionString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetVersionString");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwGetError(const char **description)
     * }
     */
    public static FunctionDescriptor glfwGetError$descriptor() {
        return glfwGetError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwGetError(const char **description)
     * }
     */
    public static MethodHandle glfwGetError$handle() {
        return glfwGetError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwGetError(const char **description)
     * }
     */
    public static MemorySegment glfwGetError$address() {
        return glfwGetError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwGetError(const char **description)
     * }
     */
    public static int glfwGetError(MemorySegment description) {
        var mh$ = glfwGetError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetError", description);
            }
            return (int)mh$.invokeExact(description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetErrorCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetErrorCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetErrorCallback$descriptor() {
        return glfwSetErrorCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback)
     * }
     */
    public static MethodHandle glfwSetErrorCallback$handle() {
        return glfwSetErrorCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback)
     * }
     */
    public static MemorySegment glfwSetErrorCallback$address() {
        return glfwSetErrorCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback)
     * }
     */
    public static MemorySegment glfwSetErrorCallback(MemorySegment callback) {
        var mh$ = glfwSetErrorCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetErrorCallback", callback);
            }
            return (MemorySegment)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetPlatform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetPlatform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwGetPlatform()
     * }
     */
    public static FunctionDescriptor glfwGetPlatform$descriptor() {
        return glfwGetPlatform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwGetPlatform()
     * }
     */
    public static MethodHandle glfwGetPlatform$handle() {
        return glfwGetPlatform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwGetPlatform()
     * }
     */
    public static MemorySegment glfwGetPlatform$address() {
        return glfwGetPlatform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwGetPlatform()
     * }
     */
    public static int glfwGetPlatform() {
        var mh$ = glfwGetPlatform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetPlatform");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwPlatformSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwPlatformSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwPlatformSupported(int platform)
     * }
     */
    public static FunctionDescriptor glfwPlatformSupported$descriptor() {
        return glfwPlatformSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwPlatformSupported(int platform)
     * }
     */
    public static MethodHandle glfwPlatformSupported$handle() {
        return glfwPlatformSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwPlatformSupported(int platform)
     * }
     */
    public static MemorySegment glfwPlatformSupported$address() {
        return glfwPlatformSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwPlatformSupported(int platform)
     * }
     */
    public static int glfwPlatformSupported(int platform) {
        var mh$ = glfwPlatformSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwPlatformSupported", platform);
            }
            return (int)mh$.invokeExact(platform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetMonitors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetMonitors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWmonitor **glfwGetMonitors(int *count)
     * }
     */
    public static FunctionDescriptor glfwGetMonitors$descriptor() {
        return glfwGetMonitors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWmonitor **glfwGetMonitors(int *count)
     * }
     */
    public static MethodHandle glfwGetMonitors$handle() {
        return glfwGetMonitors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWmonitor **glfwGetMonitors(int *count)
     * }
     */
    public static MemorySegment glfwGetMonitors$address() {
        return glfwGetMonitors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWmonitor **glfwGetMonitors(int *count)
     * }
     */
    public static MemorySegment glfwGetMonitors(MemorySegment count) {
        var mh$ = glfwGetMonitors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetMonitors", count);
            }
            return (MemorySegment)mh$.invokeExact(count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetPrimaryMonitor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetPrimaryMonitor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWmonitor *glfwGetPrimaryMonitor()
     * }
     */
    public static FunctionDescriptor glfwGetPrimaryMonitor$descriptor() {
        return glfwGetPrimaryMonitor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWmonitor *glfwGetPrimaryMonitor()
     * }
     */
    public static MethodHandle glfwGetPrimaryMonitor$handle() {
        return glfwGetPrimaryMonitor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWmonitor *glfwGetPrimaryMonitor()
     * }
     */
    public static MemorySegment glfwGetPrimaryMonitor$address() {
        return glfwGetPrimaryMonitor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWmonitor *glfwGetPrimaryMonitor()
     * }
     */
    public static MemorySegment glfwGetPrimaryMonitor() {
        var mh$ = glfwGetPrimaryMonitor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetPrimaryMonitor");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetMonitorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetMonitorPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetMonitorPos(GLFWmonitor *monitor, int *xpos, int *ypos)
     * }
     */
    public static FunctionDescriptor glfwGetMonitorPos$descriptor() {
        return glfwGetMonitorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetMonitorPos(GLFWmonitor *monitor, int *xpos, int *ypos)
     * }
     */
    public static MethodHandle glfwGetMonitorPos$handle() {
        return glfwGetMonitorPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetMonitorPos(GLFWmonitor *monitor, int *xpos, int *ypos)
     * }
     */
    public static MemorySegment glfwGetMonitorPos$address() {
        return glfwGetMonitorPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetMonitorPos(GLFWmonitor *monitor, int *xpos, int *ypos)
     * }
     */
    public static void glfwGetMonitorPos(MemorySegment monitor, MemorySegment xpos, MemorySegment ypos) {
        var mh$ = glfwGetMonitorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetMonitorPos", monitor, xpos, ypos);
            }
            mh$.invokeExact(monitor, xpos, ypos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetMonitorWorkarea {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetMonitorWorkarea");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetMonitorWorkarea(GLFWmonitor *monitor, int *xpos, int *ypos, int *width, int *height)
     * }
     */
    public static FunctionDescriptor glfwGetMonitorWorkarea$descriptor() {
        return glfwGetMonitorWorkarea.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetMonitorWorkarea(GLFWmonitor *monitor, int *xpos, int *ypos, int *width, int *height)
     * }
     */
    public static MethodHandle glfwGetMonitorWorkarea$handle() {
        return glfwGetMonitorWorkarea.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetMonitorWorkarea(GLFWmonitor *monitor, int *xpos, int *ypos, int *width, int *height)
     * }
     */
    public static MemorySegment glfwGetMonitorWorkarea$address() {
        return glfwGetMonitorWorkarea.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetMonitorWorkarea(GLFWmonitor *monitor, int *xpos, int *ypos, int *width, int *height)
     * }
     */
    public static void glfwGetMonitorWorkarea(MemorySegment monitor, MemorySegment xpos, MemorySegment ypos, MemorySegment width, MemorySegment height) {
        var mh$ = glfwGetMonitorWorkarea.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetMonitorWorkarea", monitor, xpos, ypos, width, height);
            }
            mh$.invokeExact(monitor, xpos, ypos, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetMonitorPhysicalSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetMonitorPhysicalSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetMonitorPhysicalSize(GLFWmonitor *monitor, int *widthMM, int *heightMM)
     * }
     */
    public static FunctionDescriptor glfwGetMonitorPhysicalSize$descriptor() {
        return glfwGetMonitorPhysicalSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetMonitorPhysicalSize(GLFWmonitor *monitor, int *widthMM, int *heightMM)
     * }
     */
    public static MethodHandle glfwGetMonitorPhysicalSize$handle() {
        return glfwGetMonitorPhysicalSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetMonitorPhysicalSize(GLFWmonitor *monitor, int *widthMM, int *heightMM)
     * }
     */
    public static MemorySegment glfwGetMonitorPhysicalSize$address() {
        return glfwGetMonitorPhysicalSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetMonitorPhysicalSize(GLFWmonitor *monitor, int *widthMM, int *heightMM)
     * }
     */
    public static void glfwGetMonitorPhysicalSize(MemorySegment monitor, MemorySegment widthMM, MemorySegment heightMM) {
        var mh$ = glfwGetMonitorPhysicalSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetMonitorPhysicalSize", monitor, widthMM, heightMM);
            }
            mh$.invokeExact(monitor, widthMM, heightMM);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetMonitorContentScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetMonitorContentScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetMonitorContentScale(GLFWmonitor *monitor, float *xscale, float *yscale)
     * }
     */
    public static FunctionDescriptor glfwGetMonitorContentScale$descriptor() {
        return glfwGetMonitorContentScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetMonitorContentScale(GLFWmonitor *monitor, float *xscale, float *yscale)
     * }
     */
    public static MethodHandle glfwGetMonitorContentScale$handle() {
        return glfwGetMonitorContentScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetMonitorContentScale(GLFWmonitor *monitor, float *xscale, float *yscale)
     * }
     */
    public static MemorySegment glfwGetMonitorContentScale$address() {
        return glfwGetMonitorContentScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetMonitorContentScale(GLFWmonitor *monitor, float *xscale, float *yscale)
     * }
     */
    public static void glfwGetMonitorContentScale(MemorySegment monitor, MemorySegment xscale, MemorySegment yscale) {
        var mh$ = glfwGetMonitorContentScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetMonitorContentScale", monitor, xscale, yscale);
            }
            mh$.invokeExact(monitor, xscale, yscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetMonitorName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetMonitorName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *glfwGetMonitorName(GLFWmonitor *monitor)
     * }
     */
    public static FunctionDescriptor glfwGetMonitorName$descriptor() {
        return glfwGetMonitorName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *glfwGetMonitorName(GLFWmonitor *monitor)
     * }
     */
    public static MethodHandle glfwGetMonitorName$handle() {
        return glfwGetMonitorName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *glfwGetMonitorName(GLFWmonitor *monitor)
     * }
     */
    public static MemorySegment glfwGetMonitorName$address() {
        return glfwGetMonitorName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *glfwGetMonitorName(GLFWmonitor *monitor)
     * }
     */
    public static MemorySegment glfwGetMonitorName(MemorySegment monitor) {
        var mh$ = glfwGetMonitorName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetMonitorName", monitor);
            }
            return (MemorySegment)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetMonitorUserPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetMonitorUserPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetMonitorUserPointer(GLFWmonitor *monitor, void *pointer)
     * }
     */
    public static FunctionDescriptor glfwSetMonitorUserPointer$descriptor() {
        return glfwSetMonitorUserPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetMonitorUserPointer(GLFWmonitor *monitor, void *pointer)
     * }
     */
    public static MethodHandle glfwSetMonitorUserPointer$handle() {
        return glfwSetMonitorUserPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetMonitorUserPointer(GLFWmonitor *monitor, void *pointer)
     * }
     */
    public static MemorySegment glfwSetMonitorUserPointer$address() {
        return glfwSetMonitorUserPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetMonitorUserPointer(GLFWmonitor *monitor, void *pointer)
     * }
     */
    public static void glfwSetMonitorUserPointer(MemorySegment monitor, MemorySegment pointer) {
        var mh$ = glfwSetMonitorUserPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetMonitorUserPointer", monitor, pointer);
            }
            mh$.invokeExact(monitor, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetMonitorUserPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetMonitorUserPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *glfwGetMonitorUserPointer(GLFWmonitor *monitor)
     * }
     */
    public static FunctionDescriptor glfwGetMonitorUserPointer$descriptor() {
        return glfwGetMonitorUserPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *glfwGetMonitorUserPointer(GLFWmonitor *monitor)
     * }
     */
    public static MethodHandle glfwGetMonitorUserPointer$handle() {
        return glfwGetMonitorUserPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *glfwGetMonitorUserPointer(GLFWmonitor *monitor)
     * }
     */
    public static MemorySegment glfwGetMonitorUserPointer$address() {
        return glfwGetMonitorUserPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *glfwGetMonitorUserPointer(GLFWmonitor *monitor)
     * }
     */
    public static MemorySegment glfwGetMonitorUserPointer(MemorySegment monitor) {
        var mh$ = glfwGetMonitorUserPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetMonitorUserPointer", monitor);
            }
            return (MemorySegment)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetMonitorCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetMonitorCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetMonitorCallback$descriptor() {
        return glfwSetMonitorCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun callback)
     * }
     */
    public static MethodHandle glfwSetMonitorCallback$handle() {
        return glfwSetMonitorCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun callback)
     * }
     */
    public static MemorySegment glfwSetMonitorCallback$address() {
        return glfwSetMonitorCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun callback)
     * }
     */
    public static MemorySegment glfwSetMonitorCallback(MemorySegment callback) {
        var mh$ = glfwSetMonitorCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetMonitorCallback", callback);
            }
            return (MemorySegment)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetVideoModes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetVideoModes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLFWvidmode *glfwGetVideoModes(GLFWmonitor *monitor, int *count)
     * }
     */
    public static FunctionDescriptor glfwGetVideoModes$descriptor() {
        return glfwGetVideoModes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLFWvidmode *glfwGetVideoModes(GLFWmonitor *monitor, int *count)
     * }
     */
    public static MethodHandle glfwGetVideoModes$handle() {
        return glfwGetVideoModes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLFWvidmode *glfwGetVideoModes(GLFWmonitor *monitor, int *count)
     * }
     */
    public static MemorySegment glfwGetVideoModes$address() {
        return glfwGetVideoModes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLFWvidmode *glfwGetVideoModes(GLFWmonitor *monitor, int *count)
     * }
     */
    public static MemorySegment glfwGetVideoModes(MemorySegment monitor, MemorySegment count) {
        var mh$ = glfwGetVideoModes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetVideoModes", monitor, count);
            }
            return (MemorySegment)mh$.invokeExact(monitor, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetVideoMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetVideoMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLFWvidmode *glfwGetVideoMode(GLFWmonitor *monitor)
     * }
     */
    public static FunctionDescriptor glfwGetVideoMode$descriptor() {
        return glfwGetVideoMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLFWvidmode *glfwGetVideoMode(GLFWmonitor *monitor)
     * }
     */
    public static MethodHandle glfwGetVideoMode$handle() {
        return glfwGetVideoMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLFWvidmode *glfwGetVideoMode(GLFWmonitor *monitor)
     * }
     */
    public static MemorySegment glfwGetVideoMode$address() {
        return glfwGetVideoMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLFWvidmode *glfwGetVideoMode(GLFWmonitor *monitor)
     * }
     */
    public static MemorySegment glfwGetVideoMode(MemorySegment monitor) {
        var mh$ = glfwGetVideoMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetVideoMode", monitor);
            }
            return (MemorySegment)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetGamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetGamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetGamma(GLFWmonitor *monitor, float gamma)
     * }
     */
    public static FunctionDescriptor glfwSetGamma$descriptor() {
        return glfwSetGamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetGamma(GLFWmonitor *monitor, float gamma)
     * }
     */
    public static MethodHandle glfwSetGamma$handle() {
        return glfwSetGamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetGamma(GLFWmonitor *monitor, float gamma)
     * }
     */
    public static MemorySegment glfwSetGamma$address() {
        return glfwSetGamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetGamma(GLFWmonitor *monitor, float gamma)
     * }
     */
    public static void glfwSetGamma(MemorySegment monitor, float gamma) {
        var mh$ = glfwSetGamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetGamma", monitor, gamma);
            }
            mh$.invokeExact(monitor, gamma);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetGammaRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const GLFWgammaramp *glfwGetGammaRamp(GLFWmonitor *monitor)
     * }
     */
    public static FunctionDescriptor glfwGetGammaRamp$descriptor() {
        return glfwGetGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const GLFWgammaramp *glfwGetGammaRamp(GLFWmonitor *monitor)
     * }
     */
    public static MethodHandle glfwGetGammaRamp$handle() {
        return glfwGetGammaRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const GLFWgammaramp *glfwGetGammaRamp(GLFWmonitor *monitor)
     * }
     */
    public static MemorySegment glfwGetGammaRamp$address() {
        return glfwGetGammaRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const GLFWgammaramp *glfwGetGammaRamp(GLFWmonitor *monitor)
     * }
     */
    public static MemorySegment glfwGetGammaRamp(MemorySegment monitor) {
        var mh$ = glfwGetGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetGammaRamp", monitor);
            }
            return (MemorySegment)mh$.invokeExact(monitor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetGammaRamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetGammaRamp(GLFWmonitor *monitor, const GLFWgammaramp *ramp)
     * }
     */
    public static FunctionDescriptor glfwSetGammaRamp$descriptor() {
        return glfwSetGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetGammaRamp(GLFWmonitor *monitor, const GLFWgammaramp *ramp)
     * }
     */
    public static MethodHandle glfwSetGammaRamp$handle() {
        return glfwSetGammaRamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetGammaRamp(GLFWmonitor *monitor, const GLFWgammaramp *ramp)
     * }
     */
    public static MemorySegment glfwSetGammaRamp$address() {
        return glfwSetGammaRamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetGammaRamp(GLFWmonitor *monitor, const GLFWgammaramp *ramp)
     * }
     */
    public static void glfwSetGammaRamp(MemorySegment monitor, MemorySegment ramp) {
        var mh$ = glfwSetGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetGammaRamp", monitor, ramp);
            }
            mh$.invokeExact(monitor, ramp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwDefaultWindowHints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwDefaultWindowHints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwDefaultWindowHints()
     * }
     */
    public static FunctionDescriptor glfwDefaultWindowHints$descriptor() {
        return glfwDefaultWindowHints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwDefaultWindowHints()
     * }
     */
    public static MethodHandle glfwDefaultWindowHints$handle() {
        return glfwDefaultWindowHints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwDefaultWindowHints()
     * }
     */
    public static MemorySegment glfwDefaultWindowHints$address() {
        return glfwDefaultWindowHints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwDefaultWindowHints()
     * }
     */
    public static void glfwDefaultWindowHints() {
        var mh$ = glfwDefaultWindowHints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwDefaultWindowHints");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwWindowHint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwWindowHint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwWindowHint(int hint, int value)
     * }
     */
    public static FunctionDescriptor glfwWindowHint$descriptor() {
        return glfwWindowHint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwWindowHint(int hint, int value)
     * }
     */
    public static MethodHandle glfwWindowHint$handle() {
        return glfwWindowHint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwWindowHint(int hint, int value)
     * }
     */
    public static MemorySegment glfwWindowHint$address() {
        return glfwWindowHint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwWindowHint(int hint, int value)
     * }
     */
    public static void glfwWindowHint(int hint, int value) {
        var mh$ = glfwWindowHint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwWindowHint", hint, value);
            }
            mh$.invokeExact(hint, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwWindowHintString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwWindowHintString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwWindowHintString(int hint, const char *value)
     * }
     */
    public static FunctionDescriptor glfwWindowHintString$descriptor() {
        return glfwWindowHintString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwWindowHintString(int hint, const char *value)
     * }
     */
    public static MethodHandle glfwWindowHintString$handle() {
        return glfwWindowHintString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwWindowHintString(int hint, const char *value)
     * }
     */
    public static MemorySegment glfwWindowHintString$address() {
        return glfwWindowHintString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwWindowHintString(int hint, const char *value)
     * }
     */
    public static void glfwWindowHintString(int hint, MemorySegment value) {
        var mh$ = glfwWindowHintString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwWindowHintString", hint, value);
            }
            mh$.invokeExact(hint, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwCreateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwCreateWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)
     * }
     */
    public static FunctionDescriptor glfwCreateWindow$descriptor() {
        return glfwCreateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)
     * }
     */
    public static MethodHandle glfwCreateWindow$handle() {
        return glfwCreateWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)
     * }
     */
    public static MemorySegment glfwCreateWindow$address() {
        return glfwCreateWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindow *glfwCreateWindow(int width, int height, const char *title, GLFWmonitor *monitor, GLFWwindow *share)
     * }
     */
    public static MemorySegment glfwCreateWindow(int width, int height, MemorySegment title, MemorySegment monitor, MemorySegment share) {
        var mh$ = glfwCreateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwCreateWindow", width, height, title, monitor, share);
            }
            return (MemorySegment)mh$.invokeExact(width, height, title, monitor, share);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwDestroyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwDestroyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwDestroyWindow(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwDestroyWindow$descriptor() {
        return glfwDestroyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwDestroyWindow(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwDestroyWindow$handle() {
        return glfwDestroyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwDestroyWindow(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwDestroyWindow$address() {
        return glfwDestroyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwDestroyWindow(GLFWwindow *window)
     * }
     */
    public static void glfwDestroyWindow(MemorySegment window) {
        var mh$ = glfwDestroyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwDestroyWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwWindowShouldClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwWindowShouldClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwWindowShouldClose(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwWindowShouldClose$descriptor() {
        return glfwWindowShouldClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwWindowShouldClose(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwWindowShouldClose$handle() {
        return glfwWindowShouldClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwWindowShouldClose(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwWindowShouldClose$address() {
        return glfwWindowShouldClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwWindowShouldClose(GLFWwindow *window)
     * }
     */
    public static int glfwWindowShouldClose(MemorySegment window) {
        var mh$ = glfwWindowShouldClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwWindowShouldClose", window);
            }
            return (int)mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowShouldClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowShouldClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowShouldClose(GLFWwindow *window, int value)
     * }
     */
    public static FunctionDescriptor glfwSetWindowShouldClose$descriptor() {
        return glfwSetWindowShouldClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowShouldClose(GLFWwindow *window, int value)
     * }
     */
    public static MethodHandle glfwSetWindowShouldClose$handle() {
        return glfwSetWindowShouldClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowShouldClose(GLFWwindow *window, int value)
     * }
     */
    public static MemorySegment glfwSetWindowShouldClose$address() {
        return glfwSetWindowShouldClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowShouldClose(GLFWwindow *window, int value)
     * }
     */
    public static void glfwSetWindowShouldClose(MemorySegment window, int value) {
        var mh$ = glfwSetWindowShouldClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowShouldClose", window, value);
            }
            mh$.invokeExact(window, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetWindowTitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetWindowTitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *glfwGetWindowTitle(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwGetWindowTitle$descriptor() {
        return glfwGetWindowTitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *glfwGetWindowTitle(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwGetWindowTitle$handle() {
        return glfwGetWindowTitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *glfwGetWindowTitle(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwGetWindowTitle$address() {
        return glfwGetWindowTitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *glfwGetWindowTitle(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwGetWindowTitle(MemorySegment window) {
        var mh$ = glfwGetWindowTitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetWindowTitle", window);
            }
            return (MemorySegment)mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowTitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowTitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowTitle(GLFWwindow *window, const char *title)
     * }
     */
    public static FunctionDescriptor glfwSetWindowTitle$descriptor() {
        return glfwSetWindowTitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowTitle(GLFWwindow *window, const char *title)
     * }
     */
    public static MethodHandle glfwSetWindowTitle$handle() {
        return glfwSetWindowTitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowTitle(GLFWwindow *window, const char *title)
     * }
     */
    public static MemorySegment glfwSetWindowTitle$address() {
        return glfwSetWindowTitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowTitle(GLFWwindow *window, const char *title)
     * }
     */
    public static void glfwSetWindowTitle(MemorySegment window, MemorySegment title) {
        var mh$ = glfwSetWindowTitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowTitle", window, title);
            }
            mh$.invokeExact(window, title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowIcon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowIcon(GLFWwindow *window, int count, const GLFWimage *images)
     * }
     */
    public static FunctionDescriptor glfwSetWindowIcon$descriptor() {
        return glfwSetWindowIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowIcon(GLFWwindow *window, int count, const GLFWimage *images)
     * }
     */
    public static MethodHandle glfwSetWindowIcon$handle() {
        return glfwSetWindowIcon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowIcon(GLFWwindow *window, int count, const GLFWimage *images)
     * }
     */
    public static MemorySegment glfwSetWindowIcon$address() {
        return glfwSetWindowIcon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowIcon(GLFWwindow *window, int count, const GLFWimage *images)
     * }
     */
    public static void glfwSetWindowIcon(MemorySegment window, int count, MemorySegment images) {
        var mh$ = glfwSetWindowIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowIcon", window, count, images);
            }
            mh$.invokeExact(window, count, images);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetWindowPos(GLFWwindow *window, int *xpos, int *ypos)
     * }
     */
    public static FunctionDescriptor glfwGetWindowPos$descriptor() {
        return glfwGetWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetWindowPos(GLFWwindow *window, int *xpos, int *ypos)
     * }
     */
    public static MethodHandle glfwGetWindowPos$handle() {
        return glfwGetWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetWindowPos(GLFWwindow *window, int *xpos, int *ypos)
     * }
     */
    public static MemorySegment glfwGetWindowPos$address() {
        return glfwGetWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetWindowPos(GLFWwindow *window, int *xpos, int *ypos)
     * }
     */
    public static void glfwGetWindowPos(MemorySegment window, MemorySegment xpos, MemorySegment ypos) {
        var mh$ = glfwGetWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetWindowPos", window, xpos, ypos);
            }
            mh$.invokeExact(window, xpos, ypos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowPos(GLFWwindow *window, int xpos, int ypos)
     * }
     */
    public static FunctionDescriptor glfwSetWindowPos$descriptor() {
        return glfwSetWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowPos(GLFWwindow *window, int xpos, int ypos)
     * }
     */
    public static MethodHandle glfwSetWindowPos$handle() {
        return glfwSetWindowPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowPos(GLFWwindow *window, int xpos, int ypos)
     * }
     */
    public static MemorySegment glfwSetWindowPos$address() {
        return glfwSetWindowPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowPos(GLFWwindow *window, int xpos, int ypos)
     * }
     */
    public static void glfwSetWindowPos(MemorySegment window, int xpos, int ypos) {
        var mh$ = glfwSetWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowPos", window, xpos, ypos);
            }
            mh$.invokeExact(window, xpos, ypos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetWindowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetWindowSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetWindowSize(GLFWwindow *window, int *width, int *height)
     * }
     */
    public static FunctionDescriptor glfwGetWindowSize$descriptor() {
        return glfwGetWindowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetWindowSize(GLFWwindow *window, int *width, int *height)
     * }
     */
    public static MethodHandle glfwGetWindowSize$handle() {
        return glfwGetWindowSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetWindowSize(GLFWwindow *window, int *width, int *height)
     * }
     */
    public static MemorySegment glfwGetWindowSize$address() {
        return glfwGetWindowSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetWindowSize(GLFWwindow *window, int *width, int *height)
     * }
     */
    public static void glfwGetWindowSize(MemorySegment window, MemorySegment width, MemorySegment height) {
        var mh$ = glfwGetWindowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetWindowSize", window, width, height);
            }
            mh$.invokeExact(window, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowSizeLimits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowSizeLimits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowSizeLimits(GLFWwindow *window, int minwidth, int minheight, int maxwidth, int maxheight)
     * }
     */
    public static FunctionDescriptor glfwSetWindowSizeLimits$descriptor() {
        return glfwSetWindowSizeLimits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowSizeLimits(GLFWwindow *window, int minwidth, int minheight, int maxwidth, int maxheight)
     * }
     */
    public static MethodHandle glfwSetWindowSizeLimits$handle() {
        return glfwSetWindowSizeLimits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowSizeLimits(GLFWwindow *window, int minwidth, int minheight, int maxwidth, int maxheight)
     * }
     */
    public static MemorySegment glfwSetWindowSizeLimits$address() {
        return glfwSetWindowSizeLimits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowSizeLimits(GLFWwindow *window, int minwidth, int minheight, int maxwidth, int maxheight)
     * }
     */
    public static void glfwSetWindowSizeLimits(MemorySegment window, int minwidth, int minheight, int maxwidth, int maxheight) {
        var mh$ = glfwSetWindowSizeLimits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowSizeLimits", window, minwidth, minheight, maxwidth, maxheight);
            }
            mh$.invokeExact(window, minwidth, minheight, maxwidth, maxheight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowAspectRatio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowAspectRatio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowAspectRatio(GLFWwindow *window, int numer, int denom)
     * }
     */
    public static FunctionDescriptor glfwSetWindowAspectRatio$descriptor() {
        return glfwSetWindowAspectRatio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowAspectRatio(GLFWwindow *window, int numer, int denom)
     * }
     */
    public static MethodHandle glfwSetWindowAspectRatio$handle() {
        return glfwSetWindowAspectRatio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowAspectRatio(GLFWwindow *window, int numer, int denom)
     * }
     */
    public static MemorySegment glfwSetWindowAspectRatio$address() {
        return glfwSetWindowAspectRatio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowAspectRatio(GLFWwindow *window, int numer, int denom)
     * }
     */
    public static void glfwSetWindowAspectRatio(MemorySegment window, int numer, int denom) {
        var mh$ = glfwSetWindowAspectRatio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowAspectRatio", window, numer, denom);
            }
            mh$.invokeExact(window, numer, denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowSize(GLFWwindow *window, int width, int height)
     * }
     */
    public static FunctionDescriptor glfwSetWindowSize$descriptor() {
        return glfwSetWindowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowSize(GLFWwindow *window, int width, int height)
     * }
     */
    public static MethodHandle glfwSetWindowSize$handle() {
        return glfwSetWindowSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowSize(GLFWwindow *window, int width, int height)
     * }
     */
    public static MemorySegment glfwSetWindowSize$address() {
        return glfwSetWindowSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowSize(GLFWwindow *window, int width, int height)
     * }
     */
    public static void glfwSetWindowSize(MemorySegment window, int width, int height) {
        var mh$ = glfwSetWindowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowSize", window, width, height);
            }
            mh$.invokeExact(window, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetFramebufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetFramebufferSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetFramebufferSize(GLFWwindow *window, int *width, int *height)
     * }
     */
    public static FunctionDescriptor glfwGetFramebufferSize$descriptor() {
        return glfwGetFramebufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetFramebufferSize(GLFWwindow *window, int *width, int *height)
     * }
     */
    public static MethodHandle glfwGetFramebufferSize$handle() {
        return glfwGetFramebufferSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetFramebufferSize(GLFWwindow *window, int *width, int *height)
     * }
     */
    public static MemorySegment glfwGetFramebufferSize$address() {
        return glfwGetFramebufferSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetFramebufferSize(GLFWwindow *window, int *width, int *height)
     * }
     */
    public static void glfwGetFramebufferSize(MemorySegment window, MemorySegment width, MemorySegment height) {
        var mh$ = glfwGetFramebufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetFramebufferSize", window, width, height);
            }
            mh$.invokeExact(window, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetWindowFrameSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetWindowFrameSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetWindowFrameSize(GLFWwindow *window, int *left, int *top, int *right, int *bottom)
     * }
     */
    public static FunctionDescriptor glfwGetWindowFrameSize$descriptor() {
        return glfwGetWindowFrameSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetWindowFrameSize(GLFWwindow *window, int *left, int *top, int *right, int *bottom)
     * }
     */
    public static MethodHandle glfwGetWindowFrameSize$handle() {
        return glfwGetWindowFrameSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetWindowFrameSize(GLFWwindow *window, int *left, int *top, int *right, int *bottom)
     * }
     */
    public static MemorySegment glfwGetWindowFrameSize$address() {
        return glfwGetWindowFrameSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetWindowFrameSize(GLFWwindow *window, int *left, int *top, int *right, int *bottom)
     * }
     */
    public static void glfwGetWindowFrameSize(MemorySegment window, MemorySegment left, MemorySegment top, MemorySegment right, MemorySegment bottom) {
        var mh$ = glfwGetWindowFrameSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetWindowFrameSize", window, left, top, right, bottom);
            }
            mh$.invokeExact(window, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetWindowContentScale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetWindowContentScale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetWindowContentScale(GLFWwindow *window, float *xscale, float *yscale)
     * }
     */
    public static FunctionDescriptor glfwGetWindowContentScale$descriptor() {
        return glfwGetWindowContentScale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetWindowContentScale(GLFWwindow *window, float *xscale, float *yscale)
     * }
     */
    public static MethodHandle glfwGetWindowContentScale$handle() {
        return glfwGetWindowContentScale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetWindowContentScale(GLFWwindow *window, float *xscale, float *yscale)
     * }
     */
    public static MemorySegment glfwGetWindowContentScale$address() {
        return glfwGetWindowContentScale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetWindowContentScale(GLFWwindow *window, float *xscale, float *yscale)
     * }
     */
    public static void glfwGetWindowContentScale(MemorySegment window, MemorySegment xscale, MemorySegment yscale) {
        var mh$ = glfwGetWindowContentScale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetWindowContentScale", window, xscale, yscale);
            }
            mh$.invokeExact(window, xscale, yscale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetWindowOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_FLOAT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetWindowOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float glfwGetWindowOpacity(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwGetWindowOpacity$descriptor() {
        return glfwGetWindowOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float glfwGetWindowOpacity(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwGetWindowOpacity$handle() {
        return glfwGetWindowOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float glfwGetWindowOpacity(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwGetWindowOpacity$address() {
        return glfwGetWindowOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float glfwGetWindowOpacity(GLFWwindow *window)
     * }
     */
    public static float glfwGetWindowOpacity(MemorySegment window) {
        var mh$ = glfwGetWindowOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetWindowOpacity", window);
            }
            return (float)mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowOpacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_FLOAT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowOpacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowOpacity(GLFWwindow *window, float opacity)
     * }
     */
    public static FunctionDescriptor glfwSetWindowOpacity$descriptor() {
        return glfwSetWindowOpacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowOpacity(GLFWwindow *window, float opacity)
     * }
     */
    public static MethodHandle glfwSetWindowOpacity$handle() {
        return glfwSetWindowOpacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowOpacity(GLFWwindow *window, float opacity)
     * }
     */
    public static MemorySegment glfwSetWindowOpacity$address() {
        return glfwSetWindowOpacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowOpacity(GLFWwindow *window, float opacity)
     * }
     */
    public static void glfwSetWindowOpacity(MemorySegment window, float opacity) {
        var mh$ = glfwSetWindowOpacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowOpacity", window, opacity);
            }
            mh$.invokeExact(window, opacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwIconifyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwIconifyWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwIconifyWindow(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwIconifyWindow$descriptor() {
        return glfwIconifyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwIconifyWindow(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwIconifyWindow$handle() {
        return glfwIconifyWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwIconifyWindow(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwIconifyWindow$address() {
        return glfwIconifyWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwIconifyWindow(GLFWwindow *window)
     * }
     */
    public static void glfwIconifyWindow(MemorySegment window) {
        var mh$ = glfwIconifyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwIconifyWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwRestoreWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwRestoreWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwRestoreWindow(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwRestoreWindow$descriptor() {
        return glfwRestoreWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwRestoreWindow(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwRestoreWindow$handle() {
        return glfwRestoreWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwRestoreWindow(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwRestoreWindow$address() {
        return glfwRestoreWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwRestoreWindow(GLFWwindow *window)
     * }
     */
    public static void glfwRestoreWindow(MemorySegment window) {
        var mh$ = glfwRestoreWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwRestoreWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwMaximizeWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwMaximizeWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwMaximizeWindow(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwMaximizeWindow$descriptor() {
        return glfwMaximizeWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwMaximizeWindow(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwMaximizeWindow$handle() {
        return glfwMaximizeWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwMaximizeWindow(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwMaximizeWindow$address() {
        return glfwMaximizeWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwMaximizeWindow(GLFWwindow *window)
     * }
     */
    public static void glfwMaximizeWindow(MemorySegment window) {
        var mh$ = glfwMaximizeWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwMaximizeWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwShowWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwShowWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwShowWindow(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwShowWindow$descriptor() {
        return glfwShowWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwShowWindow(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwShowWindow$handle() {
        return glfwShowWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwShowWindow(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwShowWindow$address() {
        return glfwShowWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwShowWindow(GLFWwindow *window)
     * }
     */
    public static void glfwShowWindow(MemorySegment window) {
        var mh$ = glfwShowWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwShowWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwHideWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwHideWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwHideWindow(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwHideWindow$descriptor() {
        return glfwHideWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwHideWindow(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwHideWindow$handle() {
        return glfwHideWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwHideWindow(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwHideWindow$address() {
        return glfwHideWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwHideWindow(GLFWwindow *window)
     * }
     */
    public static void glfwHideWindow(MemorySegment window) {
        var mh$ = glfwHideWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwHideWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwFocusWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwFocusWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwFocusWindow(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwFocusWindow$descriptor() {
        return glfwFocusWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwFocusWindow(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwFocusWindow$handle() {
        return glfwFocusWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwFocusWindow(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwFocusWindow$address() {
        return glfwFocusWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwFocusWindow(GLFWwindow *window)
     * }
     */
    public static void glfwFocusWindow(MemorySegment window) {
        var mh$ = glfwFocusWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwFocusWindow", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwRequestWindowAttention {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwRequestWindowAttention");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwRequestWindowAttention(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwRequestWindowAttention$descriptor() {
        return glfwRequestWindowAttention.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwRequestWindowAttention(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwRequestWindowAttention$handle() {
        return glfwRequestWindowAttention.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwRequestWindowAttention(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwRequestWindowAttention$address() {
        return glfwRequestWindowAttention.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwRequestWindowAttention(GLFWwindow *window)
     * }
     */
    public static void glfwRequestWindowAttention(MemorySegment window) {
        var mh$ = glfwRequestWindowAttention.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwRequestWindowAttention", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetWindowMonitor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetWindowMonitor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWmonitor *glfwGetWindowMonitor(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwGetWindowMonitor$descriptor() {
        return glfwGetWindowMonitor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWmonitor *glfwGetWindowMonitor(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwGetWindowMonitor$handle() {
        return glfwGetWindowMonitor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWmonitor *glfwGetWindowMonitor(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwGetWindowMonitor$address() {
        return glfwGetWindowMonitor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWmonitor *glfwGetWindowMonitor(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwGetWindowMonitor(MemorySegment window) {
        var mh$ = glfwGetWindowMonitor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetWindowMonitor", window);
            }
            return (MemorySegment)mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowMonitor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowMonitor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowMonitor(GLFWwindow *window, GLFWmonitor *monitor, int xpos, int ypos, int width, int height, int refreshRate)
     * }
     */
    public static FunctionDescriptor glfwSetWindowMonitor$descriptor() {
        return glfwSetWindowMonitor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowMonitor(GLFWwindow *window, GLFWmonitor *monitor, int xpos, int ypos, int width, int height, int refreshRate)
     * }
     */
    public static MethodHandle glfwSetWindowMonitor$handle() {
        return glfwSetWindowMonitor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowMonitor(GLFWwindow *window, GLFWmonitor *monitor, int xpos, int ypos, int width, int height, int refreshRate)
     * }
     */
    public static MemorySegment glfwSetWindowMonitor$address() {
        return glfwSetWindowMonitor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowMonitor(GLFWwindow *window, GLFWmonitor *monitor, int xpos, int ypos, int width, int height, int refreshRate)
     * }
     */
    public static void glfwSetWindowMonitor(MemorySegment window, MemorySegment monitor, int xpos, int ypos, int width, int height, int refreshRate) {
        var mh$ = glfwSetWindowMonitor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowMonitor", window, monitor, xpos, ypos, width, height, refreshRate);
            }
            mh$.invokeExact(window, monitor, xpos, ypos, width, height, refreshRate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetWindowAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetWindowAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwGetWindowAttrib(GLFWwindow *window, int attrib)
     * }
     */
    public static FunctionDescriptor glfwGetWindowAttrib$descriptor() {
        return glfwGetWindowAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwGetWindowAttrib(GLFWwindow *window, int attrib)
     * }
     */
    public static MethodHandle glfwGetWindowAttrib$handle() {
        return glfwGetWindowAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwGetWindowAttrib(GLFWwindow *window, int attrib)
     * }
     */
    public static MemorySegment glfwGetWindowAttrib$address() {
        return glfwGetWindowAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwGetWindowAttrib(GLFWwindow *window, int attrib)
     * }
     */
    public static int glfwGetWindowAttrib(MemorySegment window, int attrib) {
        var mh$ = glfwGetWindowAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetWindowAttrib", window, attrib);
            }
            return (int)mh$.invokeExact(window, attrib);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowAttrib {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowAttrib");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowAttrib(GLFWwindow *window, int attrib, int value)
     * }
     */
    public static FunctionDescriptor glfwSetWindowAttrib$descriptor() {
        return glfwSetWindowAttrib.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowAttrib(GLFWwindow *window, int attrib, int value)
     * }
     */
    public static MethodHandle glfwSetWindowAttrib$handle() {
        return glfwSetWindowAttrib.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowAttrib(GLFWwindow *window, int attrib, int value)
     * }
     */
    public static MemorySegment glfwSetWindowAttrib$address() {
        return glfwSetWindowAttrib.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowAttrib(GLFWwindow *window, int attrib, int value)
     * }
     */
    public static void glfwSetWindowAttrib(MemorySegment window, int attrib, int value) {
        var mh$ = glfwSetWindowAttrib.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowAttrib", window, attrib, value);
            }
            mh$.invokeExact(window, attrib, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowUserPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowUserPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetWindowUserPointer(GLFWwindow *window, void *pointer)
     * }
     */
    public static FunctionDescriptor glfwSetWindowUserPointer$descriptor() {
        return glfwSetWindowUserPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetWindowUserPointer(GLFWwindow *window, void *pointer)
     * }
     */
    public static MethodHandle glfwSetWindowUserPointer$handle() {
        return glfwSetWindowUserPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetWindowUserPointer(GLFWwindow *window, void *pointer)
     * }
     */
    public static MemorySegment glfwSetWindowUserPointer$address() {
        return glfwSetWindowUserPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetWindowUserPointer(GLFWwindow *window, void *pointer)
     * }
     */
    public static void glfwSetWindowUserPointer(MemorySegment window, MemorySegment pointer) {
        var mh$ = glfwSetWindowUserPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowUserPointer", window, pointer);
            }
            mh$.invokeExact(window, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetWindowUserPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetWindowUserPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *glfwGetWindowUserPointer(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwGetWindowUserPointer$descriptor() {
        return glfwGetWindowUserPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *glfwGetWindowUserPointer(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwGetWindowUserPointer$handle() {
        return glfwGetWindowUserPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *glfwGetWindowUserPointer(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwGetWindowUserPointer$address() {
        return glfwGetWindowUserPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *glfwGetWindowUserPointer(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwGetWindowUserPointer(MemorySegment window) {
        var mh$ = glfwGetWindowUserPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetWindowUserPointer", window);
            }
            return (MemorySegment)mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowPosCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowPosCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow *window, GLFWwindowposfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetWindowPosCallback$descriptor() {
        return glfwSetWindowPosCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow *window, GLFWwindowposfun callback)
     * }
     */
    public static MethodHandle glfwSetWindowPosCallback$handle() {
        return glfwSetWindowPosCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow *window, GLFWwindowposfun callback)
     * }
     */
    public static MemorySegment glfwSetWindowPosCallback$address() {
        return glfwSetWindowPosCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow *window, GLFWwindowposfun callback)
     * }
     */
    public static MemorySegment glfwSetWindowPosCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetWindowPosCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowPosCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowSizeCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowSizeCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow *window, GLFWwindowsizefun callback)
     * }
     */
    public static FunctionDescriptor glfwSetWindowSizeCallback$descriptor() {
        return glfwSetWindowSizeCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow *window, GLFWwindowsizefun callback)
     * }
     */
    public static MethodHandle glfwSetWindowSizeCallback$handle() {
        return glfwSetWindowSizeCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow *window, GLFWwindowsizefun callback)
     * }
     */
    public static MemorySegment glfwSetWindowSizeCallback$address() {
        return glfwSetWindowSizeCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow *window, GLFWwindowsizefun callback)
     * }
     */
    public static MemorySegment glfwSetWindowSizeCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetWindowSizeCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowSizeCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowCloseCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowCloseCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow *window, GLFWwindowclosefun callback)
     * }
     */
    public static FunctionDescriptor glfwSetWindowCloseCallback$descriptor() {
        return glfwSetWindowCloseCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow *window, GLFWwindowclosefun callback)
     * }
     */
    public static MethodHandle glfwSetWindowCloseCallback$handle() {
        return glfwSetWindowCloseCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow *window, GLFWwindowclosefun callback)
     * }
     */
    public static MemorySegment glfwSetWindowCloseCallback$address() {
        return glfwSetWindowCloseCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow *window, GLFWwindowclosefun callback)
     * }
     */
    public static MemorySegment glfwSetWindowCloseCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetWindowCloseCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowCloseCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowRefreshCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowRefreshCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow *window, GLFWwindowrefreshfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetWindowRefreshCallback$descriptor() {
        return glfwSetWindowRefreshCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow *window, GLFWwindowrefreshfun callback)
     * }
     */
    public static MethodHandle glfwSetWindowRefreshCallback$handle() {
        return glfwSetWindowRefreshCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow *window, GLFWwindowrefreshfun callback)
     * }
     */
    public static MemorySegment glfwSetWindowRefreshCallback$address() {
        return glfwSetWindowRefreshCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow *window, GLFWwindowrefreshfun callback)
     * }
     */
    public static MemorySegment glfwSetWindowRefreshCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetWindowRefreshCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowRefreshCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowFocusCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowFocusCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow *window, GLFWwindowfocusfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetWindowFocusCallback$descriptor() {
        return glfwSetWindowFocusCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow *window, GLFWwindowfocusfun callback)
     * }
     */
    public static MethodHandle glfwSetWindowFocusCallback$handle() {
        return glfwSetWindowFocusCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow *window, GLFWwindowfocusfun callback)
     * }
     */
    public static MemorySegment glfwSetWindowFocusCallback$address() {
        return glfwSetWindowFocusCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow *window, GLFWwindowfocusfun callback)
     * }
     */
    public static MemorySegment glfwSetWindowFocusCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetWindowFocusCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowFocusCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowIconifyCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowIconifyCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow *window, GLFWwindowiconifyfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetWindowIconifyCallback$descriptor() {
        return glfwSetWindowIconifyCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow *window, GLFWwindowiconifyfun callback)
     * }
     */
    public static MethodHandle glfwSetWindowIconifyCallback$handle() {
        return glfwSetWindowIconifyCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow *window, GLFWwindowiconifyfun callback)
     * }
     */
    public static MemorySegment glfwSetWindowIconifyCallback$address() {
        return glfwSetWindowIconifyCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow *window, GLFWwindowiconifyfun callback)
     * }
     */
    public static MemorySegment glfwSetWindowIconifyCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetWindowIconifyCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowIconifyCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowMaximizeCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowMaximizeCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(GLFWwindow *window, GLFWwindowmaximizefun callback)
     * }
     */
    public static FunctionDescriptor glfwSetWindowMaximizeCallback$descriptor() {
        return glfwSetWindowMaximizeCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(GLFWwindow *window, GLFWwindowmaximizefun callback)
     * }
     */
    public static MethodHandle glfwSetWindowMaximizeCallback$handle() {
        return glfwSetWindowMaximizeCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(GLFWwindow *window, GLFWwindowmaximizefun callback)
     * }
     */
    public static MemorySegment glfwSetWindowMaximizeCallback$address() {
        return glfwSetWindowMaximizeCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(GLFWwindow *window, GLFWwindowmaximizefun callback)
     * }
     */
    public static MemorySegment glfwSetWindowMaximizeCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetWindowMaximizeCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowMaximizeCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetFramebufferSizeCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetFramebufferSizeCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow *window, GLFWframebuffersizefun callback)
     * }
     */
    public static FunctionDescriptor glfwSetFramebufferSizeCallback$descriptor() {
        return glfwSetFramebufferSizeCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow *window, GLFWframebuffersizefun callback)
     * }
     */
    public static MethodHandle glfwSetFramebufferSizeCallback$handle() {
        return glfwSetFramebufferSizeCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow *window, GLFWframebuffersizefun callback)
     * }
     */
    public static MemorySegment glfwSetFramebufferSizeCallback$address() {
        return glfwSetFramebufferSizeCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow *window, GLFWframebuffersizefun callback)
     * }
     */
    public static MemorySegment glfwSetFramebufferSizeCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetFramebufferSizeCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetFramebufferSizeCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetWindowContentScaleCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetWindowContentScaleCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow *window, GLFWwindowcontentscalefun callback)
     * }
     */
    public static FunctionDescriptor glfwSetWindowContentScaleCallback$descriptor() {
        return glfwSetWindowContentScaleCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow *window, GLFWwindowcontentscalefun callback)
     * }
     */
    public static MethodHandle glfwSetWindowContentScaleCallback$handle() {
        return glfwSetWindowContentScaleCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow *window, GLFWwindowcontentscalefun callback)
     * }
     */
    public static MemorySegment glfwSetWindowContentScaleCallback$address() {
        return glfwSetWindowContentScaleCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow *window, GLFWwindowcontentscalefun callback)
     * }
     */
    public static MemorySegment glfwSetWindowContentScaleCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetWindowContentScaleCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetWindowContentScaleCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwPollEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwPollEvents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwPollEvents()
     * }
     */
    public static FunctionDescriptor glfwPollEvents$descriptor() {
        return glfwPollEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwPollEvents()
     * }
     */
    public static MethodHandle glfwPollEvents$handle() {
        return glfwPollEvents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwPollEvents()
     * }
     */
    public static MemorySegment glfwPollEvents$address() {
        return glfwPollEvents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwPollEvents()
     * }
     */
    public static void glfwPollEvents() {
        var mh$ = glfwPollEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwPollEvents");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwWaitEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwWaitEvents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwWaitEvents()
     * }
     */
    public static FunctionDescriptor glfwWaitEvents$descriptor() {
        return glfwWaitEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwWaitEvents()
     * }
     */
    public static MethodHandle glfwWaitEvents$handle() {
        return glfwWaitEvents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwWaitEvents()
     * }
     */
    public static MemorySegment glfwWaitEvents$address() {
        return glfwWaitEvents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwWaitEvents()
     * }
     */
    public static void glfwWaitEvents() {
        var mh$ = glfwWaitEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwWaitEvents");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwWaitEventsTimeout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwWaitEventsTimeout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwWaitEventsTimeout(double timeout)
     * }
     */
    public static FunctionDescriptor glfwWaitEventsTimeout$descriptor() {
        return glfwWaitEventsTimeout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwWaitEventsTimeout(double timeout)
     * }
     */
    public static MethodHandle glfwWaitEventsTimeout$handle() {
        return glfwWaitEventsTimeout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwWaitEventsTimeout(double timeout)
     * }
     */
    public static MemorySegment glfwWaitEventsTimeout$address() {
        return glfwWaitEventsTimeout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwWaitEventsTimeout(double timeout)
     * }
     */
    public static void glfwWaitEventsTimeout(double timeout) {
        var mh$ = glfwWaitEventsTimeout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwWaitEventsTimeout", timeout);
            }
            mh$.invokeExact(timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwPostEmptyEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwPostEmptyEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwPostEmptyEvent()
     * }
     */
    public static FunctionDescriptor glfwPostEmptyEvent$descriptor() {
        return glfwPostEmptyEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwPostEmptyEvent()
     * }
     */
    public static MethodHandle glfwPostEmptyEvent$handle() {
        return glfwPostEmptyEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwPostEmptyEvent()
     * }
     */
    public static MemorySegment glfwPostEmptyEvent$address() {
        return glfwPostEmptyEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwPostEmptyEvent()
     * }
     */
    public static void glfwPostEmptyEvent() {
        var mh$ = glfwPostEmptyEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwPostEmptyEvent");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetInputMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetInputMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwGetInputMode(GLFWwindow *window, int mode)
     * }
     */
    public static FunctionDescriptor glfwGetInputMode$descriptor() {
        return glfwGetInputMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwGetInputMode(GLFWwindow *window, int mode)
     * }
     */
    public static MethodHandle glfwGetInputMode$handle() {
        return glfwGetInputMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwGetInputMode(GLFWwindow *window, int mode)
     * }
     */
    public static MemorySegment glfwGetInputMode$address() {
        return glfwGetInputMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwGetInputMode(GLFWwindow *window, int mode)
     * }
     */
    public static int glfwGetInputMode(MemorySegment window, int mode) {
        var mh$ = glfwGetInputMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetInputMode", window, mode);
            }
            return (int)mh$.invokeExact(window, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetInputMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetInputMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetInputMode(GLFWwindow *window, int mode, int value)
     * }
     */
    public static FunctionDescriptor glfwSetInputMode$descriptor() {
        return glfwSetInputMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetInputMode(GLFWwindow *window, int mode, int value)
     * }
     */
    public static MethodHandle glfwSetInputMode$handle() {
        return glfwSetInputMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetInputMode(GLFWwindow *window, int mode, int value)
     * }
     */
    public static MemorySegment glfwSetInputMode$address() {
        return glfwSetInputMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetInputMode(GLFWwindow *window, int mode, int value)
     * }
     */
    public static void glfwSetInputMode(MemorySegment window, int mode, int value) {
        var mh$ = glfwSetInputMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetInputMode", window, mode, value);
            }
            mh$.invokeExact(window, mode, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwRawMouseMotionSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwRawMouseMotionSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwRawMouseMotionSupported()
     * }
     */
    public static FunctionDescriptor glfwRawMouseMotionSupported$descriptor() {
        return glfwRawMouseMotionSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwRawMouseMotionSupported()
     * }
     */
    public static MethodHandle glfwRawMouseMotionSupported$handle() {
        return glfwRawMouseMotionSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwRawMouseMotionSupported()
     * }
     */
    public static MemorySegment glfwRawMouseMotionSupported$address() {
        return glfwRawMouseMotionSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwRawMouseMotionSupported()
     * }
     */
    public static int glfwRawMouseMotionSupported() {
        var mh$ = glfwRawMouseMotionSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwRawMouseMotionSupported");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetKeyName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetKeyName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *glfwGetKeyName(int key, int scancode)
     * }
     */
    public static FunctionDescriptor glfwGetKeyName$descriptor() {
        return glfwGetKeyName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *glfwGetKeyName(int key, int scancode)
     * }
     */
    public static MethodHandle glfwGetKeyName$handle() {
        return glfwGetKeyName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *glfwGetKeyName(int key, int scancode)
     * }
     */
    public static MemorySegment glfwGetKeyName$address() {
        return glfwGetKeyName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *glfwGetKeyName(int key, int scancode)
     * }
     */
    public static MemorySegment glfwGetKeyName(int key, int scancode) {
        var mh$ = glfwGetKeyName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetKeyName", key, scancode);
            }
            return (MemorySegment)mh$.invokeExact(key, scancode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetKeyScancode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetKeyScancode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwGetKeyScancode(int key)
     * }
     */
    public static FunctionDescriptor glfwGetKeyScancode$descriptor() {
        return glfwGetKeyScancode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwGetKeyScancode(int key)
     * }
     */
    public static MethodHandle glfwGetKeyScancode$handle() {
        return glfwGetKeyScancode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwGetKeyScancode(int key)
     * }
     */
    public static MemorySegment glfwGetKeyScancode$address() {
        return glfwGetKeyScancode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwGetKeyScancode(int key)
     * }
     */
    public static int glfwGetKeyScancode(int key) {
        var mh$ = glfwGetKeyScancode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetKeyScancode", key);
            }
            return (int)mh$.invokeExact(key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetKey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwGetKey(GLFWwindow *window, int key)
     * }
     */
    public static FunctionDescriptor glfwGetKey$descriptor() {
        return glfwGetKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwGetKey(GLFWwindow *window, int key)
     * }
     */
    public static MethodHandle glfwGetKey$handle() {
        return glfwGetKey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwGetKey(GLFWwindow *window, int key)
     * }
     */
    public static MemorySegment glfwGetKey$address() {
        return glfwGetKey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwGetKey(GLFWwindow *window, int key)
     * }
     */
    public static int glfwGetKey(MemorySegment window, int key) {
        var mh$ = glfwGetKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetKey", window, key);
            }
            return (int)mh$.invokeExact(window, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetMouseButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetMouseButton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwGetMouseButton(GLFWwindow *window, int button)
     * }
     */
    public static FunctionDescriptor glfwGetMouseButton$descriptor() {
        return glfwGetMouseButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwGetMouseButton(GLFWwindow *window, int button)
     * }
     */
    public static MethodHandle glfwGetMouseButton$handle() {
        return glfwGetMouseButton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwGetMouseButton(GLFWwindow *window, int button)
     * }
     */
    public static MemorySegment glfwGetMouseButton$address() {
        return glfwGetMouseButton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwGetMouseButton(GLFWwindow *window, int button)
     * }
     */
    public static int glfwGetMouseButton(MemorySegment window, int button) {
        var mh$ = glfwGetMouseButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetMouseButton", window, button);
            }
            return (int)mh$.invokeExact(window, button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetCursorPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwGetCursorPos(GLFWwindow *window, double *xpos, double *ypos)
     * }
     */
    public static FunctionDescriptor glfwGetCursorPos$descriptor() {
        return glfwGetCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwGetCursorPos(GLFWwindow *window, double *xpos, double *ypos)
     * }
     */
    public static MethodHandle glfwGetCursorPos$handle() {
        return glfwGetCursorPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwGetCursorPos(GLFWwindow *window, double *xpos, double *ypos)
     * }
     */
    public static MemorySegment glfwGetCursorPos$address() {
        return glfwGetCursorPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwGetCursorPos(GLFWwindow *window, double *xpos, double *ypos)
     * }
     */
    public static void glfwGetCursorPos(MemorySegment window, MemorySegment xpos, MemorySegment ypos) {
        var mh$ = glfwGetCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetCursorPos", window, xpos, ypos);
            }
            mh$.invokeExact(window, xpos, ypos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_DOUBLE,
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetCursorPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetCursorPos(GLFWwindow *window, double xpos, double ypos)
     * }
     */
    public static FunctionDescriptor glfwSetCursorPos$descriptor() {
        return glfwSetCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetCursorPos(GLFWwindow *window, double xpos, double ypos)
     * }
     */
    public static MethodHandle glfwSetCursorPos$handle() {
        return glfwSetCursorPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetCursorPos(GLFWwindow *window, double xpos, double ypos)
     * }
     */
    public static MemorySegment glfwSetCursorPos$address() {
        return glfwSetCursorPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetCursorPos(GLFWwindow *window, double xpos, double ypos)
     * }
     */
    public static void glfwSetCursorPos(MemorySegment window, double xpos, double ypos) {
        var mh$ = glfwSetCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetCursorPos", window, xpos, ypos);
            }
            mh$.invokeExact(window, xpos, ypos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwCreateCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwCreateCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWcursor *glfwCreateCursor(const GLFWimage *image, int xhot, int yhot)
     * }
     */
    public static FunctionDescriptor glfwCreateCursor$descriptor() {
        return glfwCreateCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWcursor *glfwCreateCursor(const GLFWimage *image, int xhot, int yhot)
     * }
     */
    public static MethodHandle glfwCreateCursor$handle() {
        return glfwCreateCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWcursor *glfwCreateCursor(const GLFWimage *image, int xhot, int yhot)
     * }
     */
    public static MemorySegment glfwCreateCursor$address() {
        return glfwCreateCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWcursor *glfwCreateCursor(const GLFWimage *image, int xhot, int yhot)
     * }
     */
    public static MemorySegment glfwCreateCursor(MemorySegment image, int xhot, int yhot) {
        var mh$ = glfwCreateCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwCreateCursor", image, xhot, yhot);
            }
            return (MemorySegment)mh$.invokeExact(image, xhot, yhot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwCreateStandardCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwCreateStandardCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWcursor *glfwCreateStandardCursor(int shape)
     * }
     */
    public static FunctionDescriptor glfwCreateStandardCursor$descriptor() {
        return glfwCreateStandardCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWcursor *glfwCreateStandardCursor(int shape)
     * }
     */
    public static MethodHandle glfwCreateStandardCursor$handle() {
        return glfwCreateStandardCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWcursor *glfwCreateStandardCursor(int shape)
     * }
     */
    public static MemorySegment glfwCreateStandardCursor$address() {
        return glfwCreateStandardCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWcursor *glfwCreateStandardCursor(int shape)
     * }
     */
    public static MemorySegment glfwCreateStandardCursor(int shape) {
        var mh$ = glfwCreateStandardCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwCreateStandardCursor", shape);
            }
            return (MemorySegment)mh$.invokeExact(shape);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwDestroyCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwDestroyCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwDestroyCursor(GLFWcursor *cursor)
     * }
     */
    public static FunctionDescriptor glfwDestroyCursor$descriptor() {
        return glfwDestroyCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwDestroyCursor(GLFWcursor *cursor)
     * }
     */
    public static MethodHandle glfwDestroyCursor$handle() {
        return glfwDestroyCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwDestroyCursor(GLFWcursor *cursor)
     * }
     */
    public static MemorySegment glfwDestroyCursor$address() {
        return glfwDestroyCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwDestroyCursor(GLFWcursor *cursor)
     * }
     */
    public static void glfwDestroyCursor(MemorySegment cursor) {
        var mh$ = glfwDestroyCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwDestroyCursor", cursor);
            }
            mh$.invokeExact(cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetCursor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetCursor(GLFWwindow *window, GLFWcursor *cursor)
     * }
     */
    public static FunctionDescriptor glfwSetCursor$descriptor() {
        return glfwSetCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetCursor(GLFWwindow *window, GLFWcursor *cursor)
     * }
     */
    public static MethodHandle glfwSetCursor$handle() {
        return glfwSetCursor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetCursor(GLFWwindow *window, GLFWcursor *cursor)
     * }
     */
    public static MemorySegment glfwSetCursor$address() {
        return glfwSetCursor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetCursor(GLFWwindow *window, GLFWcursor *cursor)
     * }
     */
    public static void glfwSetCursor(MemorySegment window, MemorySegment cursor) {
        var mh$ = glfwSetCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetCursor", window, cursor);
            }
            mh$.invokeExact(window, cursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetKeyCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetKeyCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWkeyfun glfwSetKeyCallback(GLFWwindow *window, GLFWkeyfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetKeyCallback$descriptor() {
        return glfwSetKeyCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWkeyfun glfwSetKeyCallback(GLFWwindow *window, GLFWkeyfun callback)
     * }
     */
    public static MethodHandle glfwSetKeyCallback$handle() {
        return glfwSetKeyCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWkeyfun glfwSetKeyCallback(GLFWwindow *window, GLFWkeyfun callback)
     * }
     */
    public static MemorySegment glfwSetKeyCallback$address() {
        return glfwSetKeyCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWkeyfun glfwSetKeyCallback(GLFWwindow *window, GLFWkeyfun callback)
     * }
     */
    public static MemorySegment glfwSetKeyCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetKeyCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetKeyCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetCharCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetCharCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWcharfun glfwSetCharCallback(GLFWwindow *window, GLFWcharfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetCharCallback$descriptor() {
        return glfwSetCharCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWcharfun glfwSetCharCallback(GLFWwindow *window, GLFWcharfun callback)
     * }
     */
    public static MethodHandle glfwSetCharCallback$handle() {
        return glfwSetCharCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWcharfun glfwSetCharCallback(GLFWwindow *window, GLFWcharfun callback)
     * }
     */
    public static MemorySegment glfwSetCharCallback$address() {
        return glfwSetCharCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWcharfun glfwSetCharCallback(GLFWwindow *window, GLFWcharfun callback)
     * }
     */
    public static MemorySegment glfwSetCharCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetCharCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetCharCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetCharModsCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetCharModsCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow *window, GLFWcharmodsfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetCharModsCallback$descriptor() {
        return glfwSetCharModsCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow *window, GLFWcharmodsfun callback)
     * }
     */
    public static MethodHandle glfwSetCharModsCallback$handle() {
        return glfwSetCharModsCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow *window, GLFWcharmodsfun callback)
     * }
     */
    public static MemorySegment glfwSetCharModsCallback$address() {
        return glfwSetCharModsCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow *window, GLFWcharmodsfun callback)
     * }
     */
    public static MemorySegment glfwSetCharModsCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetCharModsCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetCharModsCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetMouseButtonCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetMouseButtonCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow *window, GLFWmousebuttonfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetMouseButtonCallback$descriptor() {
        return glfwSetMouseButtonCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow *window, GLFWmousebuttonfun callback)
     * }
     */
    public static MethodHandle glfwSetMouseButtonCallback$handle() {
        return glfwSetMouseButtonCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow *window, GLFWmousebuttonfun callback)
     * }
     */
    public static MemorySegment glfwSetMouseButtonCallback$address() {
        return glfwSetMouseButtonCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow *window, GLFWmousebuttonfun callback)
     * }
     */
    public static MemorySegment glfwSetMouseButtonCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetMouseButtonCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetMouseButtonCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetCursorPosCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetCursorPosCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow *window, GLFWcursorposfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetCursorPosCallback$descriptor() {
        return glfwSetCursorPosCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow *window, GLFWcursorposfun callback)
     * }
     */
    public static MethodHandle glfwSetCursorPosCallback$handle() {
        return glfwSetCursorPosCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow *window, GLFWcursorposfun callback)
     * }
     */
    public static MemorySegment glfwSetCursorPosCallback$address() {
        return glfwSetCursorPosCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow *window, GLFWcursorposfun callback)
     * }
     */
    public static MemorySegment glfwSetCursorPosCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetCursorPosCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetCursorPosCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetCursorEnterCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetCursorEnterCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow *window, GLFWcursorenterfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetCursorEnterCallback$descriptor() {
        return glfwSetCursorEnterCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow *window, GLFWcursorenterfun callback)
     * }
     */
    public static MethodHandle glfwSetCursorEnterCallback$handle() {
        return glfwSetCursorEnterCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow *window, GLFWcursorenterfun callback)
     * }
     */
    public static MemorySegment glfwSetCursorEnterCallback$address() {
        return glfwSetCursorEnterCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow *window, GLFWcursorenterfun callback)
     * }
     */
    public static MemorySegment glfwSetCursorEnterCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetCursorEnterCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetCursorEnterCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetScrollCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetScrollCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWscrollfun glfwSetScrollCallback(GLFWwindow *window, GLFWscrollfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetScrollCallback$descriptor() {
        return glfwSetScrollCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWscrollfun glfwSetScrollCallback(GLFWwindow *window, GLFWscrollfun callback)
     * }
     */
    public static MethodHandle glfwSetScrollCallback$handle() {
        return glfwSetScrollCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWscrollfun glfwSetScrollCallback(GLFWwindow *window, GLFWscrollfun callback)
     * }
     */
    public static MemorySegment glfwSetScrollCallback$address() {
        return glfwSetScrollCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWscrollfun glfwSetScrollCallback(GLFWwindow *window, GLFWscrollfun callback)
     * }
     */
    public static MemorySegment glfwSetScrollCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetScrollCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetScrollCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetDropCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetDropCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWdropfun glfwSetDropCallback(GLFWwindow *window, GLFWdropfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetDropCallback$descriptor() {
        return glfwSetDropCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWdropfun glfwSetDropCallback(GLFWwindow *window, GLFWdropfun callback)
     * }
     */
    public static MethodHandle glfwSetDropCallback$handle() {
        return glfwSetDropCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWdropfun glfwSetDropCallback(GLFWwindow *window, GLFWdropfun callback)
     * }
     */
    public static MemorySegment glfwSetDropCallback$address() {
        return glfwSetDropCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWdropfun glfwSetDropCallback(GLFWwindow *window, GLFWdropfun callback)
     * }
     */
    public static MemorySegment glfwSetDropCallback(MemorySegment window, MemorySegment callback) {
        var mh$ = glfwSetDropCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetDropCallback", window, callback);
            }
            return (MemorySegment)mh$.invokeExact(window, callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwJoystickPresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwJoystickPresent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwJoystickPresent(int jid)
     * }
     */
    public static FunctionDescriptor glfwJoystickPresent$descriptor() {
        return glfwJoystickPresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwJoystickPresent(int jid)
     * }
     */
    public static MethodHandle glfwJoystickPresent$handle() {
        return glfwJoystickPresent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwJoystickPresent(int jid)
     * }
     */
    public static MemorySegment glfwJoystickPresent$address() {
        return glfwJoystickPresent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwJoystickPresent(int jid)
     * }
     */
    public static int glfwJoystickPresent(int jid) {
        var mh$ = glfwJoystickPresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwJoystickPresent", jid);
            }
            return (int)mh$.invokeExact(jid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetJoystickAxes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetJoystickAxes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const float *glfwGetJoystickAxes(int jid, int *count)
     * }
     */
    public static FunctionDescriptor glfwGetJoystickAxes$descriptor() {
        return glfwGetJoystickAxes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const float *glfwGetJoystickAxes(int jid, int *count)
     * }
     */
    public static MethodHandle glfwGetJoystickAxes$handle() {
        return glfwGetJoystickAxes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const float *glfwGetJoystickAxes(int jid, int *count)
     * }
     */
    public static MemorySegment glfwGetJoystickAxes$address() {
        return glfwGetJoystickAxes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const float *glfwGetJoystickAxes(int jid, int *count)
     * }
     */
    public static MemorySegment glfwGetJoystickAxes(int jid, MemorySegment count) {
        var mh$ = glfwGetJoystickAxes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetJoystickAxes", jid, count);
            }
            return (MemorySegment)mh$.invokeExact(jid, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetJoystickButtons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetJoystickButtons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const unsigned char *glfwGetJoystickButtons(int jid, int *count)
     * }
     */
    public static FunctionDescriptor glfwGetJoystickButtons$descriptor() {
        return glfwGetJoystickButtons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const unsigned char *glfwGetJoystickButtons(int jid, int *count)
     * }
     */
    public static MethodHandle glfwGetJoystickButtons$handle() {
        return glfwGetJoystickButtons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const unsigned char *glfwGetJoystickButtons(int jid, int *count)
     * }
     */
    public static MemorySegment glfwGetJoystickButtons$address() {
        return glfwGetJoystickButtons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const unsigned char *glfwGetJoystickButtons(int jid, int *count)
     * }
     */
    public static MemorySegment glfwGetJoystickButtons(int jid, MemorySegment count) {
        var mh$ = glfwGetJoystickButtons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetJoystickButtons", jid, count);
            }
            return (MemorySegment)mh$.invokeExact(jid, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetJoystickHats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetJoystickHats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const unsigned char *glfwGetJoystickHats(int jid, int *count)
     * }
     */
    public static FunctionDescriptor glfwGetJoystickHats$descriptor() {
        return glfwGetJoystickHats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const unsigned char *glfwGetJoystickHats(int jid, int *count)
     * }
     */
    public static MethodHandle glfwGetJoystickHats$handle() {
        return glfwGetJoystickHats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const unsigned char *glfwGetJoystickHats(int jid, int *count)
     * }
     */
    public static MemorySegment glfwGetJoystickHats$address() {
        return glfwGetJoystickHats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const unsigned char *glfwGetJoystickHats(int jid, int *count)
     * }
     */
    public static MemorySegment glfwGetJoystickHats(int jid, MemorySegment count) {
        var mh$ = glfwGetJoystickHats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetJoystickHats", jid, count);
            }
            return (MemorySegment)mh$.invokeExact(jid, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetJoystickName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetJoystickName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *glfwGetJoystickName(int jid)
     * }
     */
    public static FunctionDescriptor glfwGetJoystickName$descriptor() {
        return glfwGetJoystickName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *glfwGetJoystickName(int jid)
     * }
     */
    public static MethodHandle glfwGetJoystickName$handle() {
        return glfwGetJoystickName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *glfwGetJoystickName(int jid)
     * }
     */
    public static MemorySegment glfwGetJoystickName$address() {
        return glfwGetJoystickName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *glfwGetJoystickName(int jid)
     * }
     */
    public static MemorySegment glfwGetJoystickName(int jid) {
        var mh$ = glfwGetJoystickName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetJoystickName", jid);
            }
            return (MemorySegment)mh$.invokeExact(jid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetJoystickGUID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetJoystickGUID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *glfwGetJoystickGUID(int jid)
     * }
     */
    public static FunctionDescriptor glfwGetJoystickGUID$descriptor() {
        return glfwGetJoystickGUID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *glfwGetJoystickGUID(int jid)
     * }
     */
    public static MethodHandle glfwGetJoystickGUID$handle() {
        return glfwGetJoystickGUID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *glfwGetJoystickGUID(int jid)
     * }
     */
    public static MemorySegment glfwGetJoystickGUID$address() {
        return glfwGetJoystickGUID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *glfwGetJoystickGUID(int jid)
     * }
     */
    public static MemorySegment glfwGetJoystickGUID(int jid) {
        var mh$ = glfwGetJoystickGUID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetJoystickGUID", jid);
            }
            return (MemorySegment)mh$.invokeExact(jid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetJoystickUserPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetJoystickUserPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetJoystickUserPointer(int jid, void *pointer)
     * }
     */
    public static FunctionDescriptor glfwSetJoystickUserPointer$descriptor() {
        return glfwSetJoystickUserPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetJoystickUserPointer(int jid, void *pointer)
     * }
     */
    public static MethodHandle glfwSetJoystickUserPointer$handle() {
        return glfwSetJoystickUserPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetJoystickUserPointer(int jid, void *pointer)
     * }
     */
    public static MemorySegment glfwSetJoystickUserPointer$address() {
        return glfwSetJoystickUserPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetJoystickUserPointer(int jid, void *pointer)
     * }
     */
    public static void glfwSetJoystickUserPointer(int jid, MemorySegment pointer) {
        var mh$ = glfwSetJoystickUserPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetJoystickUserPointer", jid, pointer);
            }
            mh$.invokeExact(jid, pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetJoystickUserPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetJoystickUserPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *glfwGetJoystickUserPointer(int jid)
     * }
     */
    public static FunctionDescriptor glfwGetJoystickUserPointer$descriptor() {
        return glfwGetJoystickUserPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *glfwGetJoystickUserPointer(int jid)
     * }
     */
    public static MethodHandle glfwGetJoystickUserPointer$handle() {
        return glfwGetJoystickUserPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *glfwGetJoystickUserPointer(int jid)
     * }
     */
    public static MemorySegment glfwGetJoystickUserPointer$address() {
        return glfwGetJoystickUserPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *glfwGetJoystickUserPointer(int jid)
     * }
     */
    public static MemorySegment glfwGetJoystickUserPointer(int jid) {
        var mh$ = glfwGetJoystickUserPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetJoystickUserPointer", jid);
            }
            return (MemorySegment)mh$.invokeExact(jid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwJoystickIsGamepad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwJoystickIsGamepad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwJoystickIsGamepad(int jid)
     * }
     */
    public static FunctionDescriptor glfwJoystickIsGamepad$descriptor() {
        return glfwJoystickIsGamepad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwJoystickIsGamepad(int jid)
     * }
     */
    public static MethodHandle glfwJoystickIsGamepad$handle() {
        return glfwJoystickIsGamepad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwJoystickIsGamepad(int jid)
     * }
     */
    public static MemorySegment glfwJoystickIsGamepad$address() {
        return glfwJoystickIsGamepad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwJoystickIsGamepad(int jid)
     * }
     */
    public static int glfwJoystickIsGamepad(int jid) {
        var mh$ = glfwJoystickIsGamepad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwJoystickIsGamepad", jid);
            }
            return (int)mh$.invokeExact(jid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetJoystickCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetJoystickCallback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun callback)
     * }
     */
    public static FunctionDescriptor glfwSetJoystickCallback$descriptor() {
        return glfwSetJoystickCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun callback)
     * }
     */
    public static MethodHandle glfwSetJoystickCallback$handle() {
        return glfwSetJoystickCallback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun callback)
     * }
     */
    public static MemorySegment glfwSetJoystickCallback$address() {
        return glfwSetJoystickCallback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun callback)
     * }
     */
    public static MemorySegment glfwSetJoystickCallback(MemorySegment callback) {
        var mh$ = glfwSetJoystickCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetJoystickCallback", callback);
            }
            return (MemorySegment)mh$.invokeExact(callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwUpdateGamepadMappings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwUpdateGamepadMappings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwUpdateGamepadMappings(const char *string)
     * }
     */
    public static FunctionDescriptor glfwUpdateGamepadMappings$descriptor() {
        return glfwUpdateGamepadMappings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwUpdateGamepadMappings(const char *string)
     * }
     */
    public static MethodHandle glfwUpdateGamepadMappings$handle() {
        return glfwUpdateGamepadMappings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwUpdateGamepadMappings(const char *string)
     * }
     */
    public static MemorySegment glfwUpdateGamepadMappings$address() {
        return glfwUpdateGamepadMappings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwUpdateGamepadMappings(const char *string)
     * }
     */
    public static int glfwUpdateGamepadMappings(MemorySegment string) {
        var mh$ = glfwUpdateGamepadMappings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwUpdateGamepadMappings", string);
            }
            return (int)mh$.invokeExact(string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetGamepadName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetGamepadName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *glfwGetGamepadName(int jid)
     * }
     */
    public static FunctionDescriptor glfwGetGamepadName$descriptor() {
        return glfwGetGamepadName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *glfwGetGamepadName(int jid)
     * }
     */
    public static MethodHandle glfwGetGamepadName$handle() {
        return glfwGetGamepadName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *glfwGetGamepadName(int jid)
     * }
     */
    public static MemorySegment glfwGetGamepadName$address() {
        return glfwGetGamepadName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *glfwGetGamepadName(int jid)
     * }
     */
    public static MemorySegment glfwGetGamepadName(int jid) {
        var mh$ = glfwGetGamepadName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetGamepadName", jid);
            }
            return (MemorySegment)mh$.invokeExact(jid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetGamepadState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetGamepadState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwGetGamepadState(int jid, GLFWgamepadstate *state)
     * }
     */
    public static FunctionDescriptor glfwGetGamepadState$descriptor() {
        return glfwGetGamepadState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwGetGamepadState(int jid, GLFWgamepadstate *state)
     * }
     */
    public static MethodHandle glfwGetGamepadState$handle() {
        return glfwGetGamepadState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwGetGamepadState(int jid, GLFWgamepadstate *state)
     * }
     */
    public static MemorySegment glfwGetGamepadState$address() {
        return glfwGetGamepadState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwGetGamepadState(int jid, GLFWgamepadstate *state)
     * }
     */
    public static int glfwGetGamepadState(int jid, MemorySegment state) {
        var mh$ = glfwGetGamepadState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetGamepadState", jid, state);
            }
            return (int)mh$.invokeExact(jid, state);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetClipboardString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetClipboardString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetClipboardString(GLFWwindow *window, const char *string)
     * }
     */
    public static FunctionDescriptor glfwSetClipboardString$descriptor() {
        return glfwSetClipboardString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetClipboardString(GLFWwindow *window, const char *string)
     * }
     */
    public static MethodHandle glfwSetClipboardString$handle() {
        return glfwSetClipboardString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetClipboardString(GLFWwindow *window, const char *string)
     * }
     */
    public static MemorySegment glfwSetClipboardString$address() {
        return glfwSetClipboardString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetClipboardString(GLFWwindow *window, const char *string)
     * }
     */
    public static void glfwSetClipboardString(MemorySegment window, MemorySegment string) {
        var mh$ = glfwSetClipboardString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetClipboardString", window, string);
            }
            mh$.invokeExact(window, string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetClipboardString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetClipboardString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *glfwGetClipboardString(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwGetClipboardString$descriptor() {
        return glfwGetClipboardString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *glfwGetClipboardString(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwGetClipboardString$handle() {
        return glfwGetClipboardString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *glfwGetClipboardString(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwGetClipboardString$address() {
        return glfwGetClipboardString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *glfwGetClipboardString(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwGetClipboardString(MemorySegment window) {
        var mh$ = glfwGetClipboardString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetClipboardString", window);
            }
            return (MemorySegment)mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_DOUBLE    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double glfwGetTime()
     * }
     */
    public static FunctionDescriptor glfwGetTime$descriptor() {
        return glfwGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double glfwGetTime()
     * }
     */
    public static MethodHandle glfwGetTime$handle() {
        return glfwGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double glfwGetTime()
     * }
     */
    public static MemorySegment glfwGetTime$address() {
        return glfwGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double glfwGetTime()
     * }
     */
    public static double glfwGetTime() {
        var mh$ = glfwGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetTime");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSetTime(double time)
     * }
     */
    public static FunctionDescriptor glfwSetTime$descriptor() {
        return glfwSetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSetTime(double time)
     * }
     */
    public static MethodHandle glfwSetTime$handle() {
        return glfwSetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSetTime(double time)
     * }
     */
    public static MemorySegment glfwSetTime$address() {
        return glfwSetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSetTime(double time)
     * }
     */
    public static void glfwSetTime(double time) {
        var mh$ = glfwSetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSetTime", time);
            }
            mh$.invokeExact(time);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetTimerValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_LONG    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetTimerValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t glfwGetTimerValue()
     * }
     */
    public static FunctionDescriptor glfwGetTimerValue$descriptor() {
        return glfwGetTimerValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t glfwGetTimerValue()
     * }
     */
    public static MethodHandle glfwGetTimerValue$handle() {
        return glfwGetTimerValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t glfwGetTimerValue()
     * }
     */
    public static MemorySegment glfwGetTimerValue$address() {
        return glfwGetTimerValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t glfwGetTimerValue()
     * }
     */
    public static long glfwGetTimerValue() {
        var mh$ = glfwGetTimerValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetTimerValue");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetTimerFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_LONG    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetTimerFrequency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t glfwGetTimerFrequency()
     * }
     */
    public static FunctionDescriptor glfwGetTimerFrequency$descriptor() {
        return glfwGetTimerFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t glfwGetTimerFrequency()
     * }
     */
    public static MethodHandle glfwGetTimerFrequency$handle() {
        return glfwGetTimerFrequency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t glfwGetTimerFrequency()
     * }
     */
    public static MemorySegment glfwGetTimerFrequency$address() {
        return glfwGetTimerFrequency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t glfwGetTimerFrequency()
     * }
     */
    public static long glfwGetTimerFrequency() {
        var mh$ = glfwGetTimerFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetTimerFrequency");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwMakeContextCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwMakeContextCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwMakeContextCurrent(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwMakeContextCurrent$descriptor() {
        return glfwMakeContextCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwMakeContextCurrent(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwMakeContextCurrent$handle() {
        return glfwMakeContextCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwMakeContextCurrent(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwMakeContextCurrent$address() {
        return glfwMakeContextCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwMakeContextCurrent(GLFWwindow *window)
     * }
     */
    public static void glfwMakeContextCurrent(MemorySegment window) {
        var mh$ = glfwMakeContextCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwMakeContextCurrent", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetCurrentContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetCurrentContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWwindow *glfwGetCurrentContext()
     * }
     */
    public static FunctionDescriptor glfwGetCurrentContext$descriptor() {
        return glfwGetCurrentContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWwindow *glfwGetCurrentContext()
     * }
     */
    public static MethodHandle glfwGetCurrentContext$handle() {
        return glfwGetCurrentContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWwindow *glfwGetCurrentContext()
     * }
     */
    public static MemorySegment glfwGetCurrentContext$address() {
        return glfwGetCurrentContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWwindow *glfwGetCurrentContext()
     * }
     */
    public static MemorySegment glfwGetCurrentContext() {
        var mh$ = glfwGetCurrentContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetCurrentContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSwapBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSwapBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSwapBuffers(GLFWwindow *window)
     * }
     */
    public static FunctionDescriptor glfwSwapBuffers$descriptor() {
        return glfwSwapBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSwapBuffers(GLFWwindow *window)
     * }
     */
    public static MethodHandle glfwSwapBuffers$handle() {
        return glfwSwapBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSwapBuffers(GLFWwindow *window)
     * }
     */
    public static MemorySegment glfwSwapBuffers$address() {
        return glfwSwapBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSwapBuffers(GLFWwindow *window)
     * }
     */
    public static void glfwSwapBuffers(MemorySegment window) {
        var mh$ = glfwSwapBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSwapBuffers", window);
            }
            mh$.invokeExact(window);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwSwapInterval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwSwapInterval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void glfwSwapInterval(int interval)
     * }
     */
    public static FunctionDescriptor glfwSwapInterval$descriptor() {
        return glfwSwapInterval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void glfwSwapInterval(int interval)
     * }
     */
    public static MethodHandle glfwSwapInterval$handle() {
        return glfwSwapInterval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void glfwSwapInterval(int interval)
     * }
     */
    public static MemorySegment glfwSwapInterval$address() {
        return glfwSwapInterval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void glfwSwapInterval(int interval)
     * }
     */
    public static void glfwSwapInterval(int interval) {
        var mh$ = glfwSwapInterval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwSwapInterval", interval);
            }
            mh$.invokeExact(interval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwExtensionSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwExtensionSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwExtensionSupported(const char *extension)
     * }
     */
    public static FunctionDescriptor glfwExtensionSupported$descriptor() {
        return glfwExtensionSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwExtensionSupported(const char *extension)
     * }
     */
    public static MethodHandle glfwExtensionSupported$handle() {
        return glfwExtensionSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwExtensionSupported(const char *extension)
     * }
     */
    public static MemorySegment glfwExtensionSupported$address() {
        return glfwExtensionSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwExtensionSupported(const char *extension)
     * }
     */
    public static int glfwExtensionSupported(MemorySegment extension) {
        var mh$ = glfwExtensionSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwExtensionSupported", extension);
            }
            return (int)mh$.invokeExact(extension);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWglproc glfwGetProcAddress(const char *procname)
     * }
     */
    public static FunctionDescriptor glfwGetProcAddress$descriptor() {
        return glfwGetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWglproc glfwGetProcAddress(const char *procname)
     * }
     */
    public static MethodHandle glfwGetProcAddress$handle() {
        return glfwGetProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWglproc glfwGetProcAddress(const char *procname)
     * }
     */
    public static MemorySegment glfwGetProcAddress$address() {
        return glfwGetProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWglproc glfwGetProcAddress(const char *procname)
     * }
     */
    public static MemorySegment glfwGetProcAddress(MemorySegment procname) {
        var mh$ = glfwGetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetProcAddress", procname);
            }
            return (MemorySegment)mh$.invokeExact(procname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwVulkanSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT    );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwVulkanSupported");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwVulkanSupported()
     * }
     */
    public static FunctionDescriptor glfwVulkanSupported$descriptor() {
        return glfwVulkanSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwVulkanSupported()
     * }
     */
    public static MethodHandle glfwVulkanSupported$handle() {
        return glfwVulkanSupported.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwVulkanSupported()
     * }
     */
    public static MemorySegment glfwVulkanSupported$address() {
        return glfwVulkanSupported.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwVulkanSupported()
     * }
     */
    public static int glfwVulkanSupported() {
        var mh$ = glfwVulkanSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwVulkanSupported");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetRequiredInstanceExtensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetRequiredInstanceExtensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char **glfwGetRequiredInstanceExtensions(uint32_t *count)
     * }
     */
    public static FunctionDescriptor glfwGetRequiredInstanceExtensions$descriptor() {
        return glfwGetRequiredInstanceExtensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char **glfwGetRequiredInstanceExtensions(uint32_t *count)
     * }
     */
    public static MethodHandle glfwGetRequiredInstanceExtensions$handle() {
        return glfwGetRequiredInstanceExtensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char **glfwGetRequiredInstanceExtensions(uint32_t *count)
     * }
     */
    public static MemorySegment glfwGetRequiredInstanceExtensions$address() {
        return glfwGetRequiredInstanceExtensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char **glfwGetRequiredInstanceExtensions(uint32_t *count)
     * }
     */
    public static MemorySegment glfwGetRequiredInstanceExtensions(MemorySegment count) {
        var mh$ = glfwGetRequiredInstanceExtensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetRequiredInstanceExtensions", count);
            }
            return (MemorySegment)mh$.invokeExact(count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetInstanceProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetInstanceProcAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GLFWvkproc glfwGetInstanceProcAddress(VkInstance instance, const char *procname)
     * }
     */
    public static FunctionDescriptor glfwGetInstanceProcAddress$descriptor() {
        return glfwGetInstanceProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GLFWvkproc glfwGetInstanceProcAddress(VkInstance instance, const char *procname)
     * }
     */
    public static MethodHandle glfwGetInstanceProcAddress$handle() {
        return glfwGetInstanceProcAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * GLFWvkproc glfwGetInstanceProcAddress(VkInstance instance, const char *procname)
     * }
     */
    public static MemorySegment glfwGetInstanceProcAddress$address() {
        return glfwGetInstanceProcAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * GLFWvkproc glfwGetInstanceProcAddress(VkInstance instance, const char *procname)
     * }
     */
    public static MemorySegment glfwGetInstanceProcAddress(MemorySegment instance, MemorySegment procname) {
        var mh$ = glfwGetInstanceProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetInstanceProcAddress", instance, procname);
            }
            return (MemorySegment)mh$.invokeExact(instance, procname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwGetPhysicalDevicePresentationSupport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_INT
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwGetPhysicalDevicePresentationSupport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int glfwGetPhysicalDevicePresentationSupport(VkInstance instance, VkPhysicalDevice device, uint32_t queuefamily)
     * }
     */
    public static FunctionDescriptor glfwGetPhysicalDevicePresentationSupport$descriptor() {
        return glfwGetPhysicalDevicePresentationSupport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int glfwGetPhysicalDevicePresentationSupport(VkInstance instance, VkPhysicalDevice device, uint32_t queuefamily)
     * }
     */
    public static MethodHandle glfwGetPhysicalDevicePresentationSupport$handle() {
        return glfwGetPhysicalDevicePresentationSupport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int glfwGetPhysicalDevicePresentationSupport(VkInstance instance, VkPhysicalDevice device, uint32_t queuefamily)
     * }
     */
    public static MemorySegment glfwGetPhysicalDevicePresentationSupport$address() {
        return glfwGetPhysicalDevicePresentationSupport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int glfwGetPhysicalDevicePresentationSupport(VkInstance instance, VkPhysicalDevice device, uint32_t queuefamily)
     * }
     */
    public static int glfwGetPhysicalDevicePresentationSupport(MemorySegment instance, MemorySegment device, int queuefamily) {
        var mh$ = glfwGetPhysicalDevicePresentationSupport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwGetPhysicalDevicePresentationSupport", instance, device, queuefamily);
            }
            return (int)mh$.invokeExact(instance, device, queuefamily);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class glfwCreateWindowSurface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            glfw3_h.C_INT,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER,
            glfw3_h.C_POINTER
        );

        public static final MemorySegment ADDR = glfw3_h.findOrThrow("glfwCreateWindowSurface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult glfwCreateWindowSurface(VkInstance instance, GLFWwindow *window, const VkAllocationCallbacks *allocator, VkSurfaceKHR *surface)
     * }
     */
    public static FunctionDescriptor glfwCreateWindowSurface$descriptor() {
        return glfwCreateWindowSurface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult glfwCreateWindowSurface(VkInstance instance, GLFWwindow *window, const VkAllocationCallbacks *allocator, VkSurfaceKHR *surface)
     * }
     */
    public static MethodHandle glfwCreateWindowSurface$handle() {
        return glfwCreateWindowSurface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult glfwCreateWindowSurface(VkInstance instance, GLFWwindow *window, const VkAllocationCallbacks *allocator, VkSurfaceKHR *surface)
     * }
     */
    public static MemorySegment glfwCreateWindowSurface$address() {
        return glfwCreateWindowSurface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult glfwCreateWindowSurface(VkInstance instance, GLFWwindow *window, const VkAllocationCallbacks *allocator, VkSurfaceKHR *surface)
     * }
     */
    public static int glfwCreateWindowSurface(MemorySegment instance, MemorySegment window, MemorySegment allocator, MemorySegment surface) {
        var mh$ = glfwCreateWindowSurface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("glfwCreateWindowSurface", instance, window, allocator, surface);
            }
            return (int)mh$.invokeExact(instance, window, allocator, surface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final int __WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MAX 2147483647
     * }
     */
    public static int __WCHAR_MAX() {
        return __WCHAR_MAX;
    }
    private static final int __WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __WCHAR_MIN -2147483648
     * }
     */
    public static int __WCHAR_MIN() {
        return __WCHAR_MIN;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final long INT_FAST16_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final long INT_FAST32_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final long INT_FAST16_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final long INT_FAST32_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final long UINT_FAST16_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX -1
     * }
     */
    public static long UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final long UINT_FAST32_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX -1
     * }
     */
    public static long UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WINT_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN 0
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 4294967295
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int VK_API_VERSION_1_0 = (int)4194304L;
    /**
     * {@snippet lang=c :
     * #define VK_API_VERSION_1_0 4194304
     * }
     */
    public static int VK_API_VERSION_1_0() {
        return VK_API_VERSION_1_0;
    }
    private static final float VK_LOD_CLAMP_NONE = 1000.0f;
    /**
     * {@snippet lang=c :
     * #define VK_LOD_CLAMP_NONE 1000.0
     * }
     */
    public static float VK_LOD_CLAMP_NONE() {
        return VK_LOD_CLAMP_NONE;
    }
    private static final int VK_REMAINING_MIP_LEVELS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_REMAINING_MIP_LEVELS 4294967295
     * }
     */
    public static int VK_REMAINING_MIP_LEVELS() {
        return VK_REMAINING_MIP_LEVELS;
    }
    private static final int VK_REMAINING_ARRAY_LAYERS = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_REMAINING_ARRAY_LAYERS 4294967295
     * }
     */
    public static int VK_REMAINING_ARRAY_LAYERS() {
        return VK_REMAINING_ARRAY_LAYERS;
    }
    private static final long VK_WHOLE_SIZE = -1L;
    /**
     * {@snippet lang=c :
     * #define VK_WHOLE_SIZE -1
     * }
     */
    public static long VK_WHOLE_SIZE() {
        return VK_WHOLE_SIZE;
    }
    private static final int VK_ATTACHMENT_UNUSED = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_ATTACHMENT_UNUSED 4294967295
     * }
     */
    public static int VK_ATTACHMENT_UNUSED() {
        return VK_ATTACHMENT_UNUSED;
    }
    private static final int VK_QUEUE_FAMILY_IGNORED = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_QUEUE_FAMILY_IGNORED 4294967295
     * }
     */
    public static int VK_QUEUE_FAMILY_IGNORED() {
        return VK_QUEUE_FAMILY_IGNORED;
    }
    private static final int VK_SUBPASS_EXTERNAL = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define VK_SUBPASS_EXTERNAL 4294967295
     * }
     */
    public static int VK_SUBPASS_EXTERNAL() {
        return VK_SUBPASS_EXTERNAL;
    }
    private static final int VK_API_VERSION_1_1 = (int)4198400L;
    /**
     * {@snippet lang=c :
     * #define VK_API_VERSION_1_1 4198400
     * }
     */
    public static int VK_API_VERSION_1_1() {
        return VK_API_VERSION_1_1;
    }
    private static final int VK_QUEUE_FAMILY_EXTERNAL = (int)4294967294L;
    /**
     * {@snippet lang=c :
     * #define VK_QUEUE_FAMILY_EXTERNAL 4294967294
     * }
     */
    public static int VK_QUEUE_FAMILY_EXTERNAL() {
        return VK_QUEUE_FAMILY_EXTERNAL;
    }
    private static final int VK_API_VERSION_1_2 = (int)4202496L;
    /**
     * {@snippet lang=c :
     * #define VK_API_VERSION_1_2 4202496
     * }
     */
    public static int VK_API_VERSION_1_2() {
        return VK_API_VERSION_1_2;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SURFACE_EXTENSION_NAME "VK_KHR_surface"
     * }
     */
    public static MemorySegment VK_KHR_SURFACE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SURFACE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_surface");
        }
        return Holder.VK_KHR_SURFACE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SWAPCHAIN_EXTENSION_NAME "VK_KHR_swapchain"
     * }
     */
    public static MemorySegment VK_KHR_SWAPCHAIN_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SWAPCHAIN_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_swapchain");
        }
        return Holder.VK_KHR_SWAPCHAIN_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DISPLAY_EXTENSION_NAME "VK_KHR_display"
     * }
     */
    public static MemorySegment VK_KHR_DISPLAY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DISPLAY_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_display");
        }
        return Holder.VK_KHR_DISPLAY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME "VK_KHR_display_swapchain"
     * }
     */
    public static MemorySegment VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_display_swapchain");
        }
        return Holder.VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME "VK_KHR_sampler_mirror_clamp_to_edge"
     * }
     */
    public static MemorySegment VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_sampler_mirror_clamp_to_edge");
        }
        return Holder.VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MULTIVIEW_EXTENSION_NAME "VK_KHR_multiview"
     * }
     */
    public static MemorySegment VK_KHR_MULTIVIEW_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MULTIVIEW_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_multiview");
        }
        return Holder.VK_KHR_MULTIVIEW_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_physical_device_properties2"
     * }
     */
    public static MemorySegment VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_get_physical_device_properties2");
        }
        return Holder.VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DEVICE_GROUP_EXTENSION_NAME "VK_KHR_device_group"
     * }
     */
    public static MemorySegment VK_KHR_DEVICE_GROUP_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DEVICE_GROUP_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_device_group");
        }
        return Holder.VK_KHR_DEVICE_GROUP_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME "VK_KHR_shader_draw_parameters"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_draw_parameters");
        }
        return Holder.VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE1_EXTENSION_NAME "VK_KHR_maintenance1"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE1_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE1_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance1");
        }
        return Holder.VK_KHR_MAINTENANCE1_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME "VK_KHR_device_group_creation"
     * }
     */
    public static MemorySegment VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_device_group_creation");
        }
        return Holder.VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME;
    }
    private static final int VK_MAX_DEVICE_GROUP_SIZE_KHR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DEVICE_GROUP_SIZE_KHR 32
     * }
     */
    public static int VK_MAX_DEVICE_GROUP_SIZE_KHR() {
        return VK_MAX_DEVICE_GROUP_SIZE_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_memory_capabilities"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_memory_capabilities");
        }
        return Holder.VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME;
    }
    private static final int VK_LUID_SIZE_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define VK_LUID_SIZE_KHR 8
     * }
     */
    public static int VK_LUID_SIZE_KHR() {
        return VK_LUID_SIZE_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME "VK_KHR_external_memory"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_memory");
        }
        return Holder.VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME;
    }
    private static final int VK_QUEUE_FAMILY_EXTERNAL_KHR = (int)4294967294L;
    /**
     * {@snippet lang=c :
     * #define VK_QUEUE_FAMILY_EXTERNAL_KHR 4294967294
     * }
     */
    public static int VK_QUEUE_FAMILY_EXTERNAL_KHR() {
        return VK_QUEUE_FAMILY_EXTERNAL_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME "VK_KHR_external_memory_fd"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_memory_fd");
        }
        return Holder.VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_semaphore_capabilities"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_semaphore_capabilities");
        }
        return Holder.VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME "VK_KHR_external_semaphore"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_semaphore");
        }
        return Holder.VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME "VK_KHR_external_semaphore_fd"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_semaphore_fd");
        }
        return Holder.VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME "VK_KHR_push_descriptor"
     * }
     */
    public static MemorySegment VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_push_descriptor");
        }
        return Holder.VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME "VK_KHR_shader_float16_int8"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_float16_int8");
        }
        return Holder.VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_16BIT_STORAGE_EXTENSION_NAME "VK_KHR_16bit_storage"
     * }
     */
    public static MemorySegment VK_KHR_16BIT_STORAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_16BIT_STORAGE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_16bit_storage");
        }
        return Holder.VK_KHR_16BIT_STORAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME "VK_KHR_incremental_present"
     * }
     */
    public static MemorySegment VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_incremental_present");
        }
        return Holder.VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME "VK_KHR_descriptor_update_template"
     * }
     */
    public static MemorySegment VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_descriptor_update_template");
        }
        return Holder.VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME "VK_KHR_imageless_framebuffer"
     * }
     */
    public static MemorySegment VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_imageless_framebuffer");
        }
        return Holder.VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME "VK_KHR_create_renderpass2"
     * }
     */
    public static MemorySegment VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_create_renderpass2");
        }
        return Holder.VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME "VK_KHR_shared_presentable_image"
     * }
     */
    public static MemorySegment VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shared_presentable_image");
        }
        return Holder.VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME "VK_KHR_external_fence_capabilities"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_fence_capabilities");
        }
        return Holder.VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME "VK_KHR_external_fence"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_fence");
        }
        return Holder.VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME "VK_KHR_external_fence_fd"
     * }
     */
    public static MemorySegment VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_external_fence_fd");
        }
        return Holder.VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME "VK_KHR_performance_query"
     * }
     */
    public static MemorySegment VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_performance_query");
        }
        return Holder.VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE2_EXTENSION_NAME "VK_KHR_maintenance2"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE2_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance2");
        }
        return Holder.VK_KHR_MAINTENANCE2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME "VK_KHR_get_surface_capabilities2"
     * }
     */
    public static MemorySegment VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_get_surface_capabilities2");
        }
        return Holder.VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME "VK_KHR_variable_pointers"
     * }
     */
    public static MemorySegment VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_variable_pointers");
        }
        return Holder.VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME "VK_KHR_get_display_properties2"
     * }
     */
    public static MemorySegment VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_get_display_properties2");
        }
        return Holder.VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_KHR_dedicated_allocation"
     * }
     */
    public static MemorySegment VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_dedicated_allocation");
        }
        return Holder.VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME "VK_KHR_storage_buffer_storage_class"
     * }
     */
    public static MemorySegment VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_storage_buffer_storage_class");
        }
        return Holder.VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME "VK_KHR_relaxed_block_layout"
     * }
     */
    public static MemorySegment VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_relaxed_block_layout");
        }
        return Holder.VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME "VK_KHR_get_memory_requirements2"
     * }
     */
    public static MemorySegment VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_get_memory_requirements2");
        }
        return Holder.VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME "VK_KHR_image_format_list"
     * }
     */
    public static MemorySegment VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_image_format_list");
        }
        return Holder.VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME "VK_KHR_sampler_ycbcr_conversion"
     * }
     */
    public static MemorySegment VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_sampler_ycbcr_conversion");
        }
        return Holder.VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_BIND_MEMORY_2_EXTENSION_NAME "VK_KHR_bind_memory2"
     * }
     */
    public static MemorySegment VK_KHR_BIND_MEMORY_2_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_BIND_MEMORY_2_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_bind_memory2");
        }
        return Holder.VK_KHR_BIND_MEMORY_2_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_MAINTENANCE3_EXTENSION_NAME "VK_KHR_maintenance3"
     * }
     */
    public static MemorySegment VK_KHR_MAINTENANCE3_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_MAINTENANCE3_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_maintenance3");
        }
        return Holder.VK_KHR_MAINTENANCE3_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_KHR_draw_indirect_count"
     * }
     */
    public static MemorySegment VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_draw_indirect_count");
        }
        return Holder.VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME "VK_KHR_shader_subgroup_extended_types"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_subgroup_extended_types");
        }
        return Holder.VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_8BIT_STORAGE_EXTENSION_NAME "VK_KHR_8bit_storage"
     * }
     */
    public static MemorySegment VK_KHR_8BIT_STORAGE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_8BIT_STORAGE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_8bit_storage");
        }
        return Holder.VK_KHR_8BIT_STORAGE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME "VK_KHR_shader_atomic_int64"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_atomic_int64");
        }
        return Holder.VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_CLOCK_EXTENSION_NAME "VK_KHR_shader_clock"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_CLOCK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_CLOCK_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_clock");
        }
        return Holder.VK_KHR_SHADER_CLOCK_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME "VK_KHR_driver_properties"
     * }
     */
    public static MemorySegment VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_driver_properties");
        }
        return Holder.VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME;
    }
    private static final int VK_MAX_DRIVER_NAME_SIZE_KHR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DRIVER_NAME_SIZE_KHR 256
     * }
     */
    public static int VK_MAX_DRIVER_NAME_SIZE_KHR() {
        return VK_MAX_DRIVER_NAME_SIZE_KHR;
    }
    private static final int VK_MAX_DRIVER_INFO_SIZE_KHR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define VK_MAX_DRIVER_INFO_SIZE_KHR 256
     * }
     */
    public static int VK_MAX_DRIVER_INFO_SIZE_KHR() {
        return VK_MAX_DRIVER_INFO_SIZE_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME "VK_KHR_shader_float_controls"
     * }
     */
    public static MemorySegment VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_shader_float_controls");
        }
        return Holder.VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME "VK_KHR_depth_stencil_resolve"
     * }
     */
    public static MemorySegment VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_depth_stencil_resolve");
        }
        return Holder.VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME "VK_KHR_swapchain_mutable_format"
     * }
     */
    public static MemorySegment VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_swapchain_mutable_format");
        }
        return Holder.VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME "VK_KHR_timeline_semaphore"
     * }
     */
    public static MemorySegment VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_timeline_semaphore");
        }
        return Holder.VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME "VK_KHR_vulkan_memory_model"
     * }
     */
    public static MemorySegment VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_vulkan_memory_model");
        }
        return Holder.VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SPIRV_1_4_EXTENSION_NAME "VK_KHR_spirv_1_4"
     * }
     */
    public static MemorySegment VK_KHR_SPIRV_1_4_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SPIRV_1_4_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_spirv_1_4");
        }
        return Holder.VK_KHR_SPIRV_1_4_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME "VK_KHR_surface_protected_capabilities"
     * }
     */
    public static MemorySegment VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_surface_protected_capabilities");
        }
        return Holder.VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME "VK_KHR_separate_depth_stencil_layouts"
     * }
     */
    public static MemorySegment VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_separate_depth_stencil_layouts");
        }
        return Holder.VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME "VK_KHR_uniform_buffer_standard_layout"
     * }
     */
    public static MemorySegment VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_uniform_buffer_standard_layout");
        }
        return Holder.VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME "VK_KHR_buffer_device_address"
     * }
     */
    public static MemorySegment VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_buffer_device_address");
        }
        return Holder.VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME "VK_KHR_pipeline_executable_properties"
     * }
     */
    public static MemorySegment VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_KHR_pipeline_executable_properties");
        }
        return Holder.VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
     * }
     */
    public static MemorySegment VK_EXT_DEBUG_REPORT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEBUG_REPORT_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_EXT_debug_report");
        }
        return Holder.VK_EXT_DEBUG_REPORT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_GLSL_SHADER_EXTENSION_NAME "VK_NV_glsl_shader"
     * }
     */
    public static MemorySegment VK_NV_GLSL_SHADER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_GLSL_SHADER_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_NV_glsl_shader");
        }
        return Holder.VK_NV_GLSL_SHADER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME "VK_EXT_depth_range_unrestricted"
     * }
     */
    public static MemorySegment VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_EXT_depth_range_unrestricted");
        }
        return Holder.VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_IMG_FILTER_CUBIC_EXTENSION_NAME "VK_IMG_filter_cubic"
     * }
     */
    public static MemorySegment VK_IMG_FILTER_CUBIC_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_IMG_FILTER_CUBIC_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_IMG_filter_cubic");
        }
        return Holder.VK_IMG_FILTER_CUBIC_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME "VK_AMD_rasterization_order"
     * }
     */
    public static MemorySegment VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_AMD_rasterization_order");
        }
        return Holder.VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME "VK_AMD_shader_trinary_minmax"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_trinary_minmax");
        }
        return Holder.VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME "VK_AMD_shader_explicit_vertex_parameter"
     * }
     */
    public static MemorySegment VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_AMD_shader_explicit_vertex_parameter");
        }
        return Holder.VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_DEBUG_MARKER_EXTENSION_NAME "VK_EXT_debug_marker"
     * }
     */
    public static MemorySegment VK_EXT_DEBUG_MARKER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_DEBUG_MARKER_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_EXT_debug_marker");
        }
        return Holder.VK_EXT_DEBUG_MARKER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_GCN_SHADER_EXTENSION_NAME "VK_AMD_gcn_shader"
     * }
     */
    public static MemorySegment VK_AMD_GCN_SHADER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_GCN_SHADER_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_AMD_gcn_shader");
        }
        return Holder.VK_AMD_GCN_SHADER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME "VK_NV_dedicated_allocation"
     * }
     */
    public static MemorySegment VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_NV_dedicated_allocation");
        }
        return Holder.VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME "VK_EXT_transform_feedback"
     * }
     */
    public static MemorySegment VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_EXT_transform_feedback");
        }
        return Holder.VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME "VK_NVX_image_view_handle"
     * }
     */
    public static MemorySegment VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_NVX_image_view_handle");
        }
        return Holder.VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME "VK_AMD_draw_indirect_count"
     * }
     */
    public static MemorySegment VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_AMD_draw_indirect_count");
        }
        return Holder.VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME "VK_AMD_negative_viewport_height"
     * }
     */
    public static MemorySegment VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_AMD_negative_viewport_height");
        }
        return Holder.VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME "VK_AMD_gpu_shader_half_float"
     * }
     */
    public static MemorySegment VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME
                = glfw3_h.LIBRARY_ARENA.allocateFrom("VK_AMD_gpu_shader_half_float");
        }
        return Holder.VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME;
    }
}

