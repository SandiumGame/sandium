// Generated by jextract

package org.sandium.core.libs.vulkan;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class vulkan_h_1 extends vulkan_h_2 {

    vulkan_h_1() {
        // Should not be called directly
    }
    private static final int VK_BUFFER_USAGE_TRANSFER_DST_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_TRANSFER_DST_BIT = 2
     * }
     */
    public static int VK_BUFFER_USAGE_TRANSFER_DST_BIT() {
        return VK_BUFFER_USAGE_TRANSFER_DST_BIT;
    }
    private static final int VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 4
     * }
     */
    public static int VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT() {
        return VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT;
    }
    private static final int VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 8
     * }
     */
    public static int VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT() {
        return VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT;
    }
    private static final int VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 16
     * }
     */
    public static int VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT() {
        return VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT;
    }
    private static final int VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 32
     * }
     */
    public static int VK_BUFFER_USAGE_STORAGE_BUFFER_BIT() {
        return VK_BUFFER_USAGE_STORAGE_BUFFER_BIT;
    }
    private static final int VK_BUFFER_USAGE_INDEX_BUFFER_BIT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 64
     * }
     */
    public static int VK_BUFFER_USAGE_INDEX_BUFFER_BIT() {
        return VK_BUFFER_USAGE_INDEX_BUFFER_BIT;
    }
    private static final int VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 128
     * }
     */
    public static int VK_BUFFER_USAGE_VERTEX_BUFFER_BIT() {
        return VK_BUFFER_USAGE_VERTEX_BUFFER_BIT;
    }
    private static final int VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 256
     * }
     */
    public static int VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT() {
        return VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT;
    }
    private static final int VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT = 131072
     * }
     */
    public static int VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT() {
        return VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT;
    }
    private static final int VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT = 2048
     * }
     */
    public static int VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT() {
        return VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT;
    }
    private static final int VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT = 4096
     * }
     */
    public static int VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT() {
        return VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT;
    }
    private static final int VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = (int)512L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 512
     * }
     */
    public static int VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT() {
        return VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT;
    }
    private static final int VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_RAY_TRACING_BIT_NV = 1024
     * }
     */
    public static int VK_BUFFER_USAGE_RAY_TRACING_BIT_NV() {
        return VK_BUFFER_USAGE_RAY_TRACING_BIT_NV;
    }
    private static final int VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT = 131072
     * }
     */
    public static int VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT() {
        return VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT;
    }
    private static final int VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR = 131072
     * }
     */
    public static int VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR() {
        return VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR;
    }
    private static final int VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkBufferUsageFlagBits.VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM() {
        return VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkBufferUsageFlags
     * }
     */
    public static final OfInt VkBufferUsageFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkBufferViewCreateFlags
     * }
     */
    public static final OfInt VkBufferViewCreateFlags = vulkan_h.C_INT;
    private static final int VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkImageViewCreateFlagBits.VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT = 1
     * }
     */
    public static int VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT() {
        return VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT;
    }
    private static final int VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkImageViewCreateFlagBits.VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkImageViewCreateFlags
     * }
     */
    public static final OfInt VkImageViewCreateFlags = vulkan_h.C_INT;
    private static final int VK_SHADER_MODULE_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkShaderModuleCreateFlagBits.VK_SHADER_MODULE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SHADER_MODULE_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_SHADER_MODULE_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkShaderModuleCreateFlags
     * }
     */
    public static final OfInt VkShaderModuleCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineCacheCreateFlags
     * }
     */
    public static final OfInt VkPipelineCacheCreateFlags = vulkan_h.C_INT;
    private static final int VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1
     * }
     */
    public static int VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT() {
        return VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT;
    }
    private static final int VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 2
     * }
     */
    public static int VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT() {
        return VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT;
    }
    private static final int VK_PIPELINE_CREATE_DERIVATIVE_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_DERIVATIVE_BIT = 4
     * }
     */
    public static int VK_PIPELINE_CREATE_DERIVATIVE_BIT() {
        return VK_PIPELINE_CREATE_DERIVATIVE_BIT;
    }
    private static final int VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 8
     * }
     */
    public static int VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT() {
        return VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT;
    }
    private static final int VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_DISPATCH_BASE_BIT = 16
     * }
     */
    public static int VK_PIPELINE_CREATE_DISPATCH_BASE_BIT() {
        return VK_PIPELINE_CREATE_DISPATCH_BASE_BIT;
    }
    private static final int VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV = 32
     * }
     */
    public static int VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV() {
        return VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV;
    }
    private static final int VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR = 64
     * }
     */
    public static int VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR() {
        return VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR;
    }
    private static final int VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR = 128
     * }
     */
    public static int VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR() {
        return VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR;
    }
    private static final int VK_PIPELINE_CREATE_DISPATCH_BASE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_DISPATCH_BASE = 16
     * }
     */
    public static int VK_PIPELINE_CREATE_DISPATCH_BASE() {
        return VK_PIPELINE_CREATE_DISPATCH_BASE;
    }
    private static final int VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = 8
     * }
     */
    public static int VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR() {
        return VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR;
    }
    private static final int VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = 16
     * }
     */
    public static int VK_PIPELINE_CREATE_DISPATCH_BASE_KHR() {
        return VK_PIPELINE_CREATE_DISPATCH_BASE_KHR;
    }
    private static final int VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineCreateFlagBits.VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineCreateFlags
     * }
     */
    public static final OfInt VkPipelineCreateFlags = vulkan_h.C_INT;
    private static final int VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineShaderStageCreateFlagBits.VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT = 1
     * }
     */
    public static int VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT() {
        return VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT;
    }
    private static final int VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineShaderStageCreateFlagBits.VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT = 2
     * }
     */
    public static int VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT() {
        return VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT;
    }
    private static final int VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineShaderStageCreateFlagBits.VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineShaderStageCreateFlags
     * }
     */
    public static final OfInt VkPipelineShaderStageCreateFlags = vulkan_h.C_INT;
    private static final int VK_SHADER_STAGE_VERTEX_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_VERTEX_BIT = 1
     * }
     */
    public static int VK_SHADER_STAGE_VERTEX_BIT() {
        return VK_SHADER_STAGE_VERTEX_BIT;
    }
    private static final int VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2
     * }
     */
    public static int VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT() {
        return VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT;
    }
    private static final int VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4
     * }
     */
    public static int VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT() {
        return VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT;
    }
    private static final int VK_SHADER_STAGE_GEOMETRY_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_GEOMETRY_BIT = 8
     * }
     */
    public static int VK_SHADER_STAGE_GEOMETRY_BIT() {
        return VK_SHADER_STAGE_GEOMETRY_BIT;
    }
    private static final int VK_SHADER_STAGE_FRAGMENT_BIT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_FRAGMENT_BIT = 16
     * }
     */
    public static int VK_SHADER_STAGE_FRAGMENT_BIT() {
        return VK_SHADER_STAGE_FRAGMENT_BIT;
    }
    private static final int VK_SHADER_STAGE_COMPUTE_BIT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_COMPUTE_BIT = 32
     * }
     */
    public static int VK_SHADER_STAGE_COMPUTE_BIT() {
        return VK_SHADER_STAGE_COMPUTE_BIT;
    }
    private static final int VK_SHADER_STAGE_ALL_GRAPHICS = (int)31L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_ALL_GRAPHICS = 31
     * }
     */
    public static int VK_SHADER_STAGE_ALL_GRAPHICS() {
        return VK_SHADER_STAGE_ALL_GRAPHICS;
    }
    private static final int VK_SHADER_STAGE_ALL = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_ALL = 2147483647
     * }
     */
    public static int VK_SHADER_STAGE_ALL() {
        return VK_SHADER_STAGE_ALL;
    }
    private static final int VK_SHADER_STAGE_RAYGEN_BIT_NV = (int)256L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_RAYGEN_BIT_NV = 256
     * }
     */
    public static int VK_SHADER_STAGE_RAYGEN_BIT_NV() {
        return VK_SHADER_STAGE_RAYGEN_BIT_NV;
    }
    private static final int VK_SHADER_STAGE_ANY_HIT_BIT_NV = (int)512L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_ANY_HIT_BIT_NV = 512
     * }
     */
    public static int VK_SHADER_STAGE_ANY_HIT_BIT_NV() {
        return VK_SHADER_STAGE_ANY_HIT_BIT_NV;
    }
    private static final int VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV = 1024
     * }
     */
    public static int VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV() {
        return VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV;
    }
    private static final int VK_SHADER_STAGE_MISS_BIT_NV = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_MISS_BIT_NV = 2048
     * }
     */
    public static int VK_SHADER_STAGE_MISS_BIT_NV() {
        return VK_SHADER_STAGE_MISS_BIT_NV;
    }
    private static final int VK_SHADER_STAGE_INTERSECTION_BIT_NV = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_INTERSECTION_BIT_NV = 4096
     * }
     */
    public static int VK_SHADER_STAGE_INTERSECTION_BIT_NV() {
        return VK_SHADER_STAGE_INTERSECTION_BIT_NV;
    }
    private static final int VK_SHADER_STAGE_CALLABLE_BIT_NV = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_CALLABLE_BIT_NV = 8192
     * }
     */
    public static int VK_SHADER_STAGE_CALLABLE_BIT_NV() {
        return VK_SHADER_STAGE_CALLABLE_BIT_NV;
    }
    private static final int VK_SHADER_STAGE_TASK_BIT_NV = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_TASK_BIT_NV = 64
     * }
     */
    public static int VK_SHADER_STAGE_TASK_BIT_NV() {
        return VK_SHADER_STAGE_TASK_BIT_NV;
    }
    private static final int VK_SHADER_STAGE_MESH_BIT_NV = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_MESH_BIT_NV = 128
     * }
     */
    public static int VK_SHADER_STAGE_MESH_BIT_NV() {
        return VK_SHADER_STAGE_MESH_BIT_NV;
    }
    private static final int VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkShaderStageFlagBits.VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM() {
        return VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineVertexInputStateCreateFlags
     * }
     */
    public static final OfInt VkPipelineVertexInputStateCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineInputAssemblyStateCreateFlags
     * }
     */
    public static final OfInt VkPipelineInputAssemblyStateCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineTessellationStateCreateFlags
     * }
     */
    public static final OfInt VkPipelineTessellationStateCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineViewportStateCreateFlags
     * }
     */
    public static final OfInt VkPipelineViewportStateCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineRasterizationStateCreateFlags
     * }
     */
    public static final OfInt VkPipelineRasterizationStateCreateFlags = vulkan_h.C_INT;
    private static final int VK_CULL_MODE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkCullModeFlagBits.VK_CULL_MODE_NONE = 0
     * }
     */
    public static int VK_CULL_MODE_NONE() {
        return VK_CULL_MODE_NONE;
    }
    private static final int VK_CULL_MODE_FRONT_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCullModeFlagBits.VK_CULL_MODE_FRONT_BIT = 1
     * }
     */
    public static int VK_CULL_MODE_FRONT_BIT() {
        return VK_CULL_MODE_FRONT_BIT;
    }
    private static final int VK_CULL_MODE_BACK_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkCullModeFlagBits.VK_CULL_MODE_BACK_BIT = 2
     * }
     */
    public static int VK_CULL_MODE_BACK_BIT() {
        return VK_CULL_MODE_BACK_BIT;
    }
    private static final int VK_CULL_MODE_FRONT_AND_BACK = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkCullModeFlagBits.VK_CULL_MODE_FRONT_AND_BACK = 3
     * }
     */
    public static int VK_CULL_MODE_FRONT_AND_BACK() {
        return VK_CULL_MODE_FRONT_AND_BACK;
    }
    private static final int VK_CULL_MODE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCullModeFlagBits.VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_CULL_MODE_FLAG_BITS_MAX_ENUM() {
        return VK_CULL_MODE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkCullModeFlags
     * }
     */
    public static final OfInt VkCullModeFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineMultisampleStateCreateFlags
     * }
     */
    public static final OfInt VkPipelineMultisampleStateCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineDepthStencilStateCreateFlags
     * }
     */
    public static final OfInt VkPipelineDepthStencilStateCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineColorBlendStateCreateFlags
     * }
     */
    public static final OfInt VkPipelineColorBlendStateCreateFlags = vulkan_h.C_INT;
    private static final int VK_COLOR_COMPONENT_R_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkColorComponentFlagBits.VK_COLOR_COMPONENT_R_BIT = 1
     * }
     */
    public static int VK_COLOR_COMPONENT_R_BIT() {
        return VK_COLOR_COMPONENT_R_BIT;
    }
    private static final int VK_COLOR_COMPONENT_G_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkColorComponentFlagBits.VK_COLOR_COMPONENT_G_BIT = 2
     * }
     */
    public static int VK_COLOR_COMPONENT_G_BIT() {
        return VK_COLOR_COMPONENT_G_BIT;
    }
    private static final int VK_COLOR_COMPONENT_B_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkColorComponentFlagBits.VK_COLOR_COMPONENT_B_BIT = 4
     * }
     */
    public static int VK_COLOR_COMPONENT_B_BIT() {
        return VK_COLOR_COMPONENT_B_BIT;
    }
    private static final int VK_COLOR_COMPONENT_A_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkColorComponentFlagBits.VK_COLOR_COMPONENT_A_BIT = 8
     * }
     */
    public static int VK_COLOR_COMPONENT_A_BIT() {
        return VK_COLOR_COMPONENT_A_BIT;
    }
    private static final int VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkColorComponentFlagBits.VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM() {
        return VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkColorComponentFlags
     * }
     */
    public static final OfInt VkColorComponentFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineDynamicStateCreateFlags
     * }
     */
    public static final OfInt VkPipelineDynamicStateCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineLayoutCreateFlags
     * }
     */
    public static final OfInt VkPipelineLayoutCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkShaderStageFlags
     * }
     */
    public static final OfInt VkShaderStageFlags = vulkan_h.C_INT;
    private static final int VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerCreateFlagBits.VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT = 1
     * }
     */
    public static int VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT() {
        return VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT;
    }
    private static final int VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerCreateFlagBits.VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT = 2
     * }
     */
    public static int VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT() {
        return VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT;
    }
    private static final int VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerCreateFlagBits.VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkSamplerCreateFlags
     * }
     */
    public static final OfInt VkSamplerCreateFlags = vulkan_h.C_INT;
    private static final int VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorSetLayoutCreateFlagBits.VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT = 2
     * }
     */
    public static int VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT() {
        return VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT;
    }
    private static final int VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorSetLayoutCreateFlagBits.VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 1
     * }
     */
    public static int VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR() {
        return VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR;
    }
    private static final int VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorSetLayoutCreateFlagBits.VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = 2
     * }
     */
    public static int VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT() {
        return VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT;
    }
    private static final int VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorSetLayoutCreateFlagBits.VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDescriptorSetLayoutCreateFlags
     * }
     */
    public static final OfInt VkDescriptorSetLayoutCreateFlags = vulkan_h.C_INT;
    private static final int VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorPoolCreateFlagBits.VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1
     * }
     */
    public static int VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT() {
        return VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT;
    }
    private static final int VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorPoolCreateFlagBits.VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT = 2
     * }
     */
    public static int VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT() {
        return VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT;
    }
    private static final int VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorPoolCreateFlagBits.VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = 2
     * }
     */
    public static int VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT() {
        return VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT;
    }
    private static final int VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorPoolCreateFlagBits.VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDescriptorPoolCreateFlags
     * }
     */
    public static final OfInt VkDescriptorPoolCreateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDescriptorPoolResetFlags
     * }
     */
    public static final OfInt VkDescriptorPoolResetFlags = vulkan_h.C_INT;
    private static final int VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkFramebufferCreateFlagBits.VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT = 1
     * }
     */
    public static int VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT() {
        return VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT;
    }
    private static final int VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkFramebufferCreateFlagBits.VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR = 1
     * }
     */
    public static int VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR() {
        return VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR;
    }
    private static final int VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkFramebufferCreateFlagBits.VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkFramebufferCreateFlags
     * }
     */
    public static final OfInt VkFramebufferCreateFlags = vulkan_h.C_INT;
    private static final int VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkRenderPassCreateFlagBits.VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkRenderPassCreateFlags
     * }
     */
    public static final OfInt VkRenderPassCreateFlags = vulkan_h.C_INT;
    private static final int VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkAttachmentDescriptionFlagBits.VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1
     * }
     */
    public static int VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT() {
        return VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT;
    }
    private static final int VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkAttachmentDescriptionFlagBits.VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM() {
        return VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkAttachmentDescriptionFlags
     * }
     */
    public static final OfInt VkAttachmentDescriptionFlags = vulkan_h.C_INT;
    private static final int VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassDescriptionFlagBits.VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 1
     * }
     */
    public static int VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX() {
        return VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX;
    }
    private static final int VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassDescriptionFlagBits.VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 2
     * }
     */
    public static int VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX() {
        return VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX;
    }
    private static final int VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSubpassDescriptionFlagBits.VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM() {
        return VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkSubpassDescriptionFlags
     * }
     */
    public static final OfInt VkSubpassDescriptionFlags = vulkan_h.C_INT;
    private static final int VK_ACCESS_INDIRECT_COMMAND_READ_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1
     * }
     */
    public static int VK_ACCESS_INDIRECT_COMMAND_READ_BIT() {
        return VK_ACCESS_INDIRECT_COMMAND_READ_BIT;
    }
    private static final int VK_ACCESS_INDEX_READ_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_INDEX_READ_BIT = 2
     * }
     */
    public static int VK_ACCESS_INDEX_READ_BIT() {
        return VK_ACCESS_INDEX_READ_BIT;
    }
    private static final int VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 4
     * }
     */
    public static int VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT() {
        return VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;
    }
    private static final int VK_ACCESS_UNIFORM_READ_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_UNIFORM_READ_BIT = 8
     * }
     */
    public static int VK_ACCESS_UNIFORM_READ_BIT() {
        return VK_ACCESS_UNIFORM_READ_BIT;
    }
    private static final int VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 16
     * }
     */
    public static int VK_ACCESS_INPUT_ATTACHMENT_READ_BIT() {
        return VK_ACCESS_INPUT_ATTACHMENT_READ_BIT;
    }
    private static final int VK_ACCESS_SHADER_READ_BIT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_SHADER_READ_BIT = 32
     * }
     */
    public static int VK_ACCESS_SHADER_READ_BIT() {
        return VK_ACCESS_SHADER_READ_BIT;
    }
    private static final int VK_ACCESS_SHADER_WRITE_BIT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_SHADER_WRITE_BIT = 64
     * }
     */
    public static int VK_ACCESS_SHADER_WRITE_BIT() {
        return VK_ACCESS_SHADER_WRITE_BIT;
    }
    private static final int VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 128
     * }
     */
    public static int VK_ACCESS_COLOR_ATTACHMENT_READ_BIT() {
        return VK_ACCESS_COLOR_ATTACHMENT_READ_BIT;
    }
    private static final int VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256
     * }
     */
    public static int VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT() {
        return VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT;
    }
    private static final int VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = (int)512L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512
     * }
     */
    public static int VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT() {
        return VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT;
    }
    private static final int VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024
     * }
     */
    public static int VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT() {
        return VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
    }
    private static final int VK_ACCESS_TRANSFER_READ_BIT = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_TRANSFER_READ_BIT = 2048
     * }
     */
    public static int VK_ACCESS_TRANSFER_READ_BIT() {
        return VK_ACCESS_TRANSFER_READ_BIT;
    }
    private static final int VK_ACCESS_TRANSFER_WRITE_BIT = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_TRANSFER_WRITE_BIT = 4096
     * }
     */
    public static int VK_ACCESS_TRANSFER_WRITE_BIT() {
        return VK_ACCESS_TRANSFER_WRITE_BIT;
    }
    private static final int VK_ACCESS_HOST_READ_BIT = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_HOST_READ_BIT = 8192
     * }
     */
    public static int VK_ACCESS_HOST_READ_BIT() {
        return VK_ACCESS_HOST_READ_BIT;
    }
    private static final int VK_ACCESS_HOST_WRITE_BIT = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_HOST_WRITE_BIT = 16384
     * }
     */
    public static int VK_ACCESS_HOST_WRITE_BIT() {
        return VK_ACCESS_HOST_WRITE_BIT;
    }
    private static final int VK_ACCESS_MEMORY_READ_BIT = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_MEMORY_READ_BIT = 32768
     * }
     */
    public static int VK_ACCESS_MEMORY_READ_BIT() {
        return VK_ACCESS_MEMORY_READ_BIT;
    }
    private static final int VK_ACCESS_MEMORY_WRITE_BIT = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_MEMORY_WRITE_BIT = 65536
     * }
     */
    public static int VK_ACCESS_MEMORY_WRITE_BIT() {
        return VK_ACCESS_MEMORY_WRITE_BIT;
    }
    private static final int VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = (int)33554432L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT = 33554432
     * }
     */
    public static int VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT() {
        return VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT;
    }
    private static final int VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = (int)67108864L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT = 67108864
     * }
     */
    public static int VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT() {
        return VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT;
    }
    private static final int VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = (int)134217728L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT = 134217728
     * }
     */
    public static int VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT() {
        return VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT;
    }
    private static final int VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = (int)1048576L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 1048576
     * }
     */
    public static int VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT() {
        return VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT;
    }
    private static final int VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = (int)131072L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = 131072
     * }
     */
    public static int VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX() {
        return VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX;
    }
    private static final int VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = 262144
     * }
     */
    public static int VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX() {
        return VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX;
    }
    private static final int VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 524288
     * }
     */
    public static int VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT() {
        return VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT;
    }
    private static final int VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV = 8388608
     * }
     */
    public static int VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV() {
        return VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV;
    }
    private static final int VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = (int)2097152L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV = 2097152
     * }
     */
    public static int VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV() {
        return VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV;
    }
    private static final int VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = (int)4194304L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV = 4194304
     * }
     */
    public static int VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV() {
        return VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV;
    }
    private static final int VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = (int)16777216L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT = 16777216
     * }
     */
    public static int VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT() {
        return VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT;
    }
    private static final int VK_ACCESS_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkAccessFlagBits.VK_ACCESS_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_ACCESS_FLAG_BITS_MAX_ENUM() {
        return VK_ACCESS_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkAccessFlags
     * }
     */
    public static final OfInt VkAccessFlags = vulkan_h.C_INT;
    private static final int VK_DEPENDENCY_BY_REGION_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDependencyFlagBits.VK_DEPENDENCY_BY_REGION_BIT = 1
     * }
     */
    public static int VK_DEPENDENCY_BY_REGION_BIT() {
        return VK_DEPENDENCY_BY_REGION_BIT;
    }
    private static final int VK_DEPENDENCY_DEVICE_GROUP_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDependencyFlagBits.VK_DEPENDENCY_DEVICE_GROUP_BIT = 4
     * }
     */
    public static int VK_DEPENDENCY_DEVICE_GROUP_BIT() {
        return VK_DEPENDENCY_DEVICE_GROUP_BIT;
    }
    private static final int VK_DEPENDENCY_VIEW_LOCAL_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDependencyFlagBits.VK_DEPENDENCY_VIEW_LOCAL_BIT = 2
     * }
     */
    public static int VK_DEPENDENCY_VIEW_LOCAL_BIT() {
        return VK_DEPENDENCY_VIEW_LOCAL_BIT;
    }
    private static final int VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDependencyFlagBits.VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = 2
     * }
     */
    public static int VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR() {
        return VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR;
    }
    private static final int VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDependencyFlagBits.VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = 4
     * }
     */
    public static int VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR() {
        return VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR;
    }
    private static final int VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDependencyFlagBits.VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_DEPENDENCY_FLAG_BITS_MAX_ENUM() {
        return VK_DEPENDENCY_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDependencyFlags
     * }
     */
    public static final OfInt VkDependencyFlags = vulkan_h.C_INT;
    private static final int VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCommandPoolCreateFlagBits.VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1
     * }
     */
    public static int VK_COMMAND_POOL_CREATE_TRANSIENT_BIT() {
        return VK_COMMAND_POOL_CREATE_TRANSIENT_BIT;
    }
    private static final int VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkCommandPoolCreateFlagBits.VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 2
     * }
     */
    public static int VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT() {
        return VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
    }
    private static final int VK_COMMAND_POOL_CREATE_PROTECTED_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkCommandPoolCreateFlagBits.VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 4
     * }
     */
    public static int VK_COMMAND_POOL_CREATE_PROTECTED_BIT() {
        return VK_COMMAND_POOL_CREATE_PROTECTED_BIT;
    }
    private static final int VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCommandPoolCreateFlagBits.VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM() {
        return VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkCommandPoolCreateFlags
     * }
     */
    public static final OfInt VkCommandPoolCreateFlags = vulkan_h.C_INT;
    private static final int VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCommandPoolResetFlagBits.VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1
     * }
     */
    public static int VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT() {
        return VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT;
    }
    private static final int VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCommandPoolResetFlagBits.VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM() {
        return VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkCommandPoolResetFlags
     * }
     */
    public static final OfInt VkCommandPoolResetFlags = vulkan_h.C_INT;
    private static final int VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCommandBufferUsageFlagBits.VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1
     * }
     */
    public static int VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT() {
        return VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
    }
    private static final int VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkCommandBufferUsageFlagBits.VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 2
     * }
     */
    public static int VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT() {
        return VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT;
    }
    private static final int VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkCommandBufferUsageFlagBits.VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 4
     * }
     */
    public static int VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT() {
        return VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
    }
    private static final int VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCommandBufferUsageFlagBits.VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM() {
        return VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkCommandBufferUsageFlags
     * }
     */
    public static final OfInt VkCommandBufferUsageFlags = vulkan_h.C_INT;
    private static final int VK_QUERY_CONTROL_PRECISE_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkQueryControlFlagBits.VK_QUERY_CONTROL_PRECISE_BIT = 1
     * }
     */
    public static int VK_QUERY_CONTROL_PRECISE_BIT() {
        return VK_QUERY_CONTROL_PRECISE_BIT;
    }
    private static final int VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkQueryControlFlagBits.VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM() {
        return VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkQueryControlFlags
     * }
     */
    public static final OfInt VkQueryControlFlags = vulkan_h.C_INT;
    private static final int VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCommandBufferResetFlagBits.VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1
     * }
     */
    public static int VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT() {
        return VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT;
    }
    private static final int VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCommandBufferResetFlagBits.VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM() {
        return VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkCommandBufferResetFlags
     * }
     */
    public static final OfInt VkCommandBufferResetFlags = vulkan_h.C_INT;
    private static final int VK_STENCIL_FACE_FRONT_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkStencilFaceFlagBits.VK_STENCIL_FACE_FRONT_BIT = 1
     * }
     */
    public static int VK_STENCIL_FACE_FRONT_BIT() {
        return VK_STENCIL_FACE_FRONT_BIT;
    }
    private static final int VK_STENCIL_FACE_BACK_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkStencilFaceFlagBits.VK_STENCIL_FACE_BACK_BIT = 2
     * }
     */
    public static int VK_STENCIL_FACE_BACK_BIT() {
        return VK_STENCIL_FACE_BACK_BIT;
    }
    private static final int VK_STENCIL_FACE_FRONT_AND_BACK = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkStencilFaceFlagBits.VK_STENCIL_FACE_FRONT_AND_BACK = 3
     * }
     */
    public static int VK_STENCIL_FACE_FRONT_AND_BACK() {
        return VK_STENCIL_FACE_FRONT_AND_BACK;
    }
    private static final int VK_STENCIL_FRONT_AND_BACK = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkStencilFaceFlagBits.VK_STENCIL_FRONT_AND_BACK = 3
     * }
     */
    public static int VK_STENCIL_FRONT_AND_BACK() {
        return VK_STENCIL_FRONT_AND_BACK;
    }
    private static final int VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkStencilFaceFlagBits.VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM() {
        return VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkStencilFaceFlags
     * }
     */
    public static final OfInt VkStencilFaceFlags = vulkan_h.C_INT;

    private static class vkCreateInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance)
     * }
     */
    public static FunctionDescriptor vkCreateInstance$descriptor() {
        return vkCreateInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance)
     * }
     */
    public static MethodHandle vkCreateInstance$handle() {
        return vkCreateInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance)
     * }
     */
    public static MemorySegment vkCreateInstance$address() {
        return vkCreateInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance)
     * }
     */
    public static int vkCreateInstance(MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pInstance) {
        var mh$ = vkCreateInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateInstance", pCreateInfo, pAllocator, pInstance);
            }
            return (int)mh$.invokeExact(pCreateInfo, pAllocator, pInstance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyInstance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyInstance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyInstance$descriptor() {
        return vkDestroyInstance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyInstance$handle() {
        return vkDestroyInstance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyInstance$address() {
        return vkDestroyInstance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyInstance(MemorySegment instance, MemorySegment pAllocator) {
        var mh$ = vkDestroyInstance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyInstance", instance, pAllocator);
            }
            mh$.invokeExact(instance, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkEnumeratePhysicalDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEnumeratePhysicalDevices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices)
     * }
     */
    public static FunctionDescriptor vkEnumeratePhysicalDevices$descriptor() {
        return vkEnumeratePhysicalDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices)
     * }
     */
    public static MethodHandle vkEnumeratePhysicalDevices$handle() {
        return vkEnumeratePhysicalDevices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices)
     * }
     */
    public static MemorySegment vkEnumeratePhysicalDevices$address() {
        return vkEnumeratePhysicalDevices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices)
     * }
     */
    public static int vkEnumeratePhysicalDevices(MemorySegment instance, MemorySegment pPhysicalDeviceCount, MemorySegment pPhysicalDevices) {
        var mh$ = vkEnumeratePhysicalDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEnumeratePhysicalDevices", instance, pPhysicalDeviceCount, pPhysicalDevices);
            }
            return (int)mh$.invokeExact(instance, pPhysicalDeviceCount, pPhysicalDevices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceFeatures$descriptor() {
        return vkGetPhysicalDeviceFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceFeatures$handle() {
        return vkGetPhysicalDeviceFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceFeatures$address() {
        return vkGetPhysicalDeviceFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures)
     * }
     */
    public static void vkGetPhysicalDeviceFeatures(MemorySegment physicalDevice, MemorySegment pFeatures) {
        var mh$ = vkGetPhysicalDeviceFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceFeatures", physicalDevice, pFeatures);
            }
            mh$.invokeExact(physicalDevice, pFeatures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceFormatProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceFormatProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceFormatProperties$descriptor() {
        return vkGetPhysicalDeviceFormatProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceFormatProperties$handle() {
        return vkGetPhysicalDeviceFormatProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceFormatProperties$address() {
        return vkGetPhysicalDeviceFormatProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties)
     * }
     */
    public static void vkGetPhysicalDeviceFormatProperties(MemorySegment physicalDevice, int format, MemorySegment pFormatProperties) {
        var mh$ = vkGetPhysicalDeviceFormatProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceFormatProperties", physicalDevice, format, pFormatProperties);
            }
            mh$.invokeExact(physicalDevice, format, pFormatProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceImageFormatProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceImageFormatProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceImageFormatProperties$descriptor() {
        return vkGetPhysicalDeviceImageFormatProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceImageFormatProperties$handle() {
        return vkGetPhysicalDeviceImageFormatProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceImageFormatProperties$address() {
        return vkGetPhysicalDeviceImageFormatProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties)
     * }
     */
    public static int vkGetPhysicalDeviceImageFormatProperties(MemorySegment physicalDevice, int format, int type, int tiling, int usage, int flags, MemorySegment pImageFormatProperties) {
        var mh$ = vkGetPhysicalDeviceImageFormatProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceImageFormatProperties", physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceProperties$descriptor() {
        return vkGetPhysicalDeviceProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceProperties$handle() {
        return vkGetPhysicalDeviceProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceProperties$address() {
        return vkGetPhysicalDeviceProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties)
     * }
     */
    public static void vkGetPhysicalDeviceProperties(MemorySegment physicalDevice, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceProperties", physicalDevice, pProperties);
            }
            mh$.invokeExact(physicalDevice, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceQueueFamilyProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceQueueFamilyProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceQueueFamilyProperties$descriptor() {
        return vkGetPhysicalDeviceQueueFamilyProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceQueueFamilyProperties$handle() {
        return vkGetPhysicalDeviceQueueFamilyProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceQueueFamilyProperties$address() {
        return vkGetPhysicalDeviceQueueFamilyProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties)
     * }
     */
    public static void vkGetPhysicalDeviceQueueFamilyProperties(MemorySegment physicalDevice, MemorySegment pQueueFamilyPropertyCount, MemorySegment pQueueFamilyProperties) {
        var mh$ = vkGetPhysicalDeviceQueueFamilyProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceQueueFamilyProperties", physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
            }
            mh$.invokeExact(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceMemoryProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceMemoryProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceMemoryProperties$descriptor() {
        return vkGetPhysicalDeviceMemoryProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceMemoryProperties$handle() {
        return vkGetPhysicalDeviceMemoryProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceMemoryProperties$address() {
        return vkGetPhysicalDeviceMemoryProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties)
     * }
     */
    public static void vkGetPhysicalDeviceMemoryProperties(MemorySegment physicalDevice, MemorySegment pMemoryProperties) {
        var mh$ = vkGetPhysicalDeviceMemoryProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceMemoryProperties", physicalDevice, pMemoryProperties);
            }
            mh$.invokeExact(physicalDevice, pMemoryProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetInstanceProcAddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetInstanceProcAddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PFN_vkVoidFunction vkGetInstanceProcAddr(VkInstance instance, const char *pName)
     * }
     */
    public static FunctionDescriptor vkGetInstanceProcAddr$descriptor() {
        return vkGetInstanceProcAddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PFN_vkVoidFunction vkGetInstanceProcAddr(VkInstance instance, const char *pName)
     * }
     */
    public static MethodHandle vkGetInstanceProcAddr$handle() {
        return vkGetInstanceProcAddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PFN_vkVoidFunction vkGetInstanceProcAddr(VkInstance instance, const char *pName)
     * }
     */
    public static MemorySegment vkGetInstanceProcAddr$address() {
        return vkGetInstanceProcAddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PFN_vkVoidFunction vkGetInstanceProcAddr(VkInstance instance, const char *pName)
     * }
     */
    public static MemorySegment vkGetInstanceProcAddr(MemorySegment instance, MemorySegment pName) {
        var mh$ = vkGetInstanceProcAddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetInstanceProcAddr", instance, pName);
            }
            return (MemorySegment)mh$.invokeExact(instance, pName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceProcAddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceProcAddr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PFN_vkVoidFunction vkGetDeviceProcAddr(VkDevice device, const char *pName)
     * }
     */
    public static FunctionDescriptor vkGetDeviceProcAddr$descriptor() {
        return vkGetDeviceProcAddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PFN_vkVoidFunction vkGetDeviceProcAddr(VkDevice device, const char *pName)
     * }
     */
    public static MethodHandle vkGetDeviceProcAddr$handle() {
        return vkGetDeviceProcAddr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * PFN_vkVoidFunction vkGetDeviceProcAddr(VkDevice device, const char *pName)
     * }
     */
    public static MemorySegment vkGetDeviceProcAddr$address() {
        return vkGetDeviceProcAddr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * PFN_vkVoidFunction vkGetDeviceProcAddr(VkDevice device, const char *pName)
     * }
     */
    public static MemorySegment vkGetDeviceProcAddr(MemorySegment device, MemorySegment pName) {
        var mh$ = vkGetDeviceProcAddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceProcAddr", device, pName);
            }
            return (MemorySegment)mh$.invokeExact(device, pName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice)
     * }
     */
    public static FunctionDescriptor vkCreateDevice$descriptor() {
        return vkCreateDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice)
     * }
     */
    public static MethodHandle vkCreateDevice$handle() {
        return vkCreateDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice)
     * }
     */
    public static MemorySegment vkCreateDevice$address() {
        return vkCreateDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice)
     * }
     */
    public static int vkCreateDevice(MemorySegment physicalDevice, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pDevice) {
        var mh$ = vkCreateDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateDevice", physicalDevice, pCreateInfo, pAllocator, pDevice);
            }
            return (int)mh$.invokeExact(physicalDevice, pCreateInfo, pAllocator, pDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyDevice$descriptor() {
        return vkDestroyDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyDevice$handle() {
        return vkDestroyDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyDevice$address() {
        return vkDestroyDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyDevice(MemorySegment device, MemorySegment pAllocator) {
        var mh$ = vkDestroyDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyDevice", device, pAllocator);
            }
            mh$.invokeExact(device, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkEnumerateInstanceExtensionProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEnumerateInstanceExtensionProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceExtensionProperties(const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties)
     * }
     */
    public static FunctionDescriptor vkEnumerateInstanceExtensionProperties$descriptor() {
        return vkEnumerateInstanceExtensionProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceExtensionProperties(const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties)
     * }
     */
    public static MethodHandle vkEnumerateInstanceExtensionProperties$handle() {
        return vkEnumerateInstanceExtensionProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceExtensionProperties(const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties)
     * }
     */
    public static MemorySegment vkEnumerateInstanceExtensionProperties$address() {
        return vkEnumerateInstanceExtensionProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceExtensionProperties(const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties)
     * }
     */
    public static int vkEnumerateInstanceExtensionProperties(MemorySegment pLayerName, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkEnumerateInstanceExtensionProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEnumerateInstanceExtensionProperties", pLayerName, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(pLayerName, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkEnumerateDeviceExtensionProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEnumerateDeviceExtensionProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties)
     * }
     */
    public static FunctionDescriptor vkEnumerateDeviceExtensionProperties$descriptor() {
        return vkEnumerateDeviceExtensionProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties)
     * }
     */
    public static MethodHandle vkEnumerateDeviceExtensionProperties$handle() {
        return vkEnumerateDeviceExtensionProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties)
     * }
     */
    public static MemorySegment vkEnumerateDeviceExtensionProperties$address() {
        return vkEnumerateDeviceExtensionProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties)
     * }
     */
    public static int vkEnumerateDeviceExtensionProperties(MemorySegment physicalDevice, MemorySegment pLayerName, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkEnumerateDeviceExtensionProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEnumerateDeviceExtensionProperties", physicalDevice, pLayerName, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pLayerName, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkEnumerateInstanceLayerProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEnumerateInstanceLayerProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceLayerProperties(uint32_t *pPropertyCount, VkLayerProperties *pProperties)
     * }
     */
    public static FunctionDescriptor vkEnumerateInstanceLayerProperties$descriptor() {
        return vkEnumerateInstanceLayerProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceLayerProperties(uint32_t *pPropertyCount, VkLayerProperties *pProperties)
     * }
     */
    public static MethodHandle vkEnumerateInstanceLayerProperties$handle() {
        return vkEnumerateInstanceLayerProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceLayerProperties(uint32_t *pPropertyCount, VkLayerProperties *pProperties)
     * }
     */
    public static MemorySegment vkEnumerateInstanceLayerProperties$address() {
        return vkEnumerateInstanceLayerProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceLayerProperties(uint32_t *pPropertyCount, VkLayerProperties *pProperties)
     * }
     */
    public static int vkEnumerateInstanceLayerProperties(MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkEnumerateInstanceLayerProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEnumerateInstanceLayerProperties", pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkEnumerateDeviceLayerProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEnumerateDeviceLayerProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties)
     * }
     */
    public static FunctionDescriptor vkEnumerateDeviceLayerProperties$descriptor() {
        return vkEnumerateDeviceLayerProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties)
     * }
     */
    public static MethodHandle vkEnumerateDeviceLayerProperties$handle() {
        return vkEnumerateDeviceLayerProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties)
     * }
     */
    public static MemorySegment vkEnumerateDeviceLayerProperties$address() {
        return vkEnumerateDeviceLayerProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties)
     * }
     */
    public static int vkEnumerateDeviceLayerProperties(MemorySegment physicalDevice, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkEnumerateDeviceLayerProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEnumerateDeviceLayerProperties", physicalDevice, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceQueue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue)
     * }
     */
    public static FunctionDescriptor vkGetDeviceQueue$descriptor() {
        return vkGetDeviceQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue)
     * }
     */
    public static MethodHandle vkGetDeviceQueue$handle() {
        return vkGetDeviceQueue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue)
     * }
     */
    public static MemorySegment vkGetDeviceQueue$address() {
        return vkGetDeviceQueue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue)
     * }
     */
    public static void vkGetDeviceQueue(MemorySegment device, int queueFamilyIndex, int queueIndex, MemorySegment pQueue) {
        var mh$ = vkGetDeviceQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceQueue", device, queueFamilyIndex, queueIndex, pQueue);
            }
            mh$.invokeExact(device, queueFamilyIndex, queueIndex, pQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkQueueSubmit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkQueueSubmit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence)
     * }
     */
    public static FunctionDescriptor vkQueueSubmit$descriptor() {
        return vkQueueSubmit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence)
     * }
     */
    public static MethodHandle vkQueueSubmit$handle() {
        return vkQueueSubmit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence)
     * }
     */
    public static MemorySegment vkQueueSubmit$address() {
        return vkQueueSubmit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkQueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence)
     * }
     */
    public static int vkQueueSubmit(MemorySegment queue, int submitCount, MemorySegment pSubmits, MemorySegment fence) {
        var mh$ = vkQueueSubmit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkQueueSubmit", queue, submitCount, pSubmits, fence);
            }
            return (int)mh$.invokeExact(queue, submitCount, pSubmits, fence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkQueueWaitIdle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkQueueWaitIdle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkQueueWaitIdle(VkQueue queue)
     * }
     */
    public static FunctionDescriptor vkQueueWaitIdle$descriptor() {
        return vkQueueWaitIdle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkQueueWaitIdle(VkQueue queue)
     * }
     */
    public static MethodHandle vkQueueWaitIdle$handle() {
        return vkQueueWaitIdle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkQueueWaitIdle(VkQueue queue)
     * }
     */
    public static MemorySegment vkQueueWaitIdle$address() {
        return vkQueueWaitIdle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkQueueWaitIdle(VkQueue queue)
     * }
     */
    public static int vkQueueWaitIdle(MemorySegment queue) {
        var mh$ = vkQueueWaitIdle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkQueueWaitIdle", queue);
            }
            return (int)mh$.invokeExact(queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDeviceWaitIdle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDeviceWaitIdle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkDeviceWaitIdle(VkDevice device)
     * }
     */
    public static FunctionDescriptor vkDeviceWaitIdle$descriptor() {
        return vkDeviceWaitIdle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkDeviceWaitIdle(VkDevice device)
     * }
     */
    public static MethodHandle vkDeviceWaitIdle$handle() {
        return vkDeviceWaitIdle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkDeviceWaitIdle(VkDevice device)
     * }
     */
    public static MemorySegment vkDeviceWaitIdle$address() {
        return vkDeviceWaitIdle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkDeviceWaitIdle(VkDevice device)
     * }
     */
    public static int vkDeviceWaitIdle(MemorySegment device) {
        var mh$ = vkDeviceWaitIdle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDeviceWaitIdle", device);
            }
            return (int)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkAllocateMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkAllocateMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory)
     * }
     */
    public static FunctionDescriptor vkAllocateMemory$descriptor() {
        return vkAllocateMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory)
     * }
     */
    public static MethodHandle vkAllocateMemory$handle() {
        return vkAllocateMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory)
     * }
     */
    public static MemorySegment vkAllocateMemory$address() {
        return vkAllocateMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkAllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory)
     * }
     */
    public static int vkAllocateMemory(MemorySegment device, MemorySegment pAllocateInfo, MemorySegment pAllocator, MemorySegment pMemory) {
        var mh$ = vkAllocateMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkAllocateMemory", device, pAllocateInfo, pAllocator, pMemory);
            }
            return (int)mh$.invokeExact(device, pAllocateInfo, pAllocator, pMemory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkFreeMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkFreeMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkFreeMemory$descriptor() {
        return vkFreeMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkFreeMemory$handle() {
        return vkFreeMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkFreeMemory$address() {
        return vkFreeMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkFreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkFreeMemory(MemorySegment device, MemorySegment memory, MemorySegment pAllocator) {
        var mh$ = vkFreeMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkFreeMemory", device, memory, pAllocator);
            }
            mh$.invokeExact(device, memory, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkMapMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkMapMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData)
     * }
     */
    public static FunctionDescriptor vkMapMemory$descriptor() {
        return vkMapMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData)
     * }
     */
    public static MethodHandle vkMapMemory$handle() {
        return vkMapMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData)
     * }
     */
    public static MemorySegment vkMapMemory$address() {
        return vkMapMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkMapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData)
     * }
     */
    public static int vkMapMemory(MemorySegment device, MemorySegment memory, long offset, long size, int flags, MemorySegment ppData) {
        var mh$ = vkMapMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkMapMemory", device, memory, offset, size, flags, ppData);
            }
            return (int)mh$.invokeExact(device, memory, offset, size, flags, ppData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkUnmapMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkUnmapMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkUnmapMemory(VkDevice device, VkDeviceMemory memory)
     * }
     */
    public static FunctionDescriptor vkUnmapMemory$descriptor() {
        return vkUnmapMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkUnmapMemory(VkDevice device, VkDeviceMemory memory)
     * }
     */
    public static MethodHandle vkUnmapMemory$handle() {
        return vkUnmapMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkUnmapMemory(VkDevice device, VkDeviceMemory memory)
     * }
     */
    public static MemorySegment vkUnmapMemory$address() {
        return vkUnmapMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkUnmapMemory(VkDevice device, VkDeviceMemory memory)
     * }
     */
    public static void vkUnmapMemory(MemorySegment device, MemorySegment memory) {
        var mh$ = vkUnmapMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkUnmapMemory", device, memory);
            }
            mh$.invokeExact(device, memory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkFlushMappedMemoryRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkFlushMappedMemoryRanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkFlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges)
     * }
     */
    public static FunctionDescriptor vkFlushMappedMemoryRanges$descriptor() {
        return vkFlushMappedMemoryRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkFlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges)
     * }
     */
    public static MethodHandle vkFlushMappedMemoryRanges$handle() {
        return vkFlushMappedMemoryRanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkFlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges)
     * }
     */
    public static MemorySegment vkFlushMappedMemoryRanges$address() {
        return vkFlushMappedMemoryRanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkFlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges)
     * }
     */
    public static int vkFlushMappedMemoryRanges(MemorySegment device, int memoryRangeCount, MemorySegment pMemoryRanges) {
        var mh$ = vkFlushMappedMemoryRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkFlushMappedMemoryRanges", device, memoryRangeCount, pMemoryRanges);
            }
            return (int)mh$.invokeExact(device, memoryRangeCount, pMemoryRanges);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkInvalidateMappedMemoryRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkInvalidateMappedMemoryRanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges)
     * }
     */
    public static FunctionDescriptor vkInvalidateMappedMemoryRanges$descriptor() {
        return vkInvalidateMappedMemoryRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges)
     * }
     */
    public static MethodHandle vkInvalidateMappedMemoryRanges$handle() {
        return vkInvalidateMappedMemoryRanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges)
     * }
     */
    public static MemorySegment vkInvalidateMappedMemoryRanges$address() {
        return vkInvalidateMappedMemoryRanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkInvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges)
     * }
     */
    public static int vkInvalidateMappedMemoryRanges(MemorySegment device, int memoryRangeCount, MemorySegment pMemoryRanges) {
        var mh$ = vkInvalidateMappedMemoryRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkInvalidateMappedMemoryRanges", device, memoryRangeCount, pMemoryRanges);
            }
            return (int)mh$.invokeExact(device, memoryRangeCount, pMemoryRanges);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceMemoryCommitment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceMemoryCommitment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes)
     * }
     */
    public static FunctionDescriptor vkGetDeviceMemoryCommitment$descriptor() {
        return vkGetDeviceMemoryCommitment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes)
     * }
     */
    public static MethodHandle vkGetDeviceMemoryCommitment$handle() {
        return vkGetDeviceMemoryCommitment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes)
     * }
     */
    public static MemorySegment vkGetDeviceMemoryCommitment$address() {
        return vkGetDeviceMemoryCommitment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes)
     * }
     */
    public static void vkGetDeviceMemoryCommitment(MemorySegment device, MemorySegment memory, MemorySegment pCommittedMemoryInBytes) {
        var mh$ = vkGetDeviceMemoryCommitment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceMemoryCommitment", device, memory, pCommittedMemoryInBytes);
            }
            mh$.invokeExact(device, memory, pCommittedMemoryInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBindBufferMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkBindBufferMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset)
     * }
     */
    public static FunctionDescriptor vkBindBufferMemory$descriptor() {
        return vkBindBufferMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset)
     * }
     */
    public static MethodHandle vkBindBufferMemory$handle() {
        return vkBindBufferMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset)
     * }
     */
    public static MemorySegment vkBindBufferMemory$address() {
        return vkBindBufferMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset)
     * }
     */
    public static int vkBindBufferMemory(MemorySegment device, MemorySegment buffer, MemorySegment memory, long memoryOffset) {
        var mh$ = vkBindBufferMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBindBufferMemory", device, buffer, memory, memoryOffset);
            }
            return (int)mh$.invokeExact(device, buffer, memory, memoryOffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBindImageMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkBindImageMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset)
     * }
     */
    public static FunctionDescriptor vkBindImageMemory$descriptor() {
        return vkBindImageMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset)
     * }
     */
    public static MethodHandle vkBindImageMemory$handle() {
        return vkBindImageMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset)
     * }
     */
    public static MemorySegment vkBindImageMemory$address() {
        return vkBindImageMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkBindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset)
     * }
     */
    public static int vkBindImageMemory(MemorySegment device, MemorySegment image, MemorySegment memory, long memoryOffset) {
        var mh$ = vkBindImageMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBindImageMemory", device, image, memory, memoryOffset);
            }
            return (int)mh$.invokeExact(device, image, memory, memoryOffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetBufferMemoryRequirements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetBufferMemoryRequirements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetBufferMemoryRequirements$descriptor() {
        return vkGetBufferMemoryRequirements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetBufferMemoryRequirements$handle() {
        return vkGetBufferMemoryRequirements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetBufferMemoryRequirements$address() {
        return vkGetBufferMemoryRequirements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements)
     * }
     */
    public static void vkGetBufferMemoryRequirements(MemorySegment device, MemorySegment buffer, MemorySegment pMemoryRequirements) {
        var mh$ = vkGetBufferMemoryRequirements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetBufferMemoryRequirements", device, buffer, pMemoryRequirements);
            }
            mh$.invokeExact(device, buffer, pMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageMemoryRequirements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetImageMemoryRequirements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetImageMemoryRequirements$descriptor() {
        return vkGetImageMemoryRequirements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetImageMemoryRequirements$handle() {
        return vkGetImageMemoryRequirements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetImageMemoryRequirements$address() {
        return vkGetImageMemoryRequirements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements)
     * }
     */
    public static void vkGetImageMemoryRequirements(MemorySegment device, MemorySegment image, MemorySegment pMemoryRequirements) {
        var mh$ = vkGetImageMemoryRequirements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageMemoryRequirements", device, image, pMemoryRequirements);
            }
            mh$.invokeExact(device, image, pMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageSparseMemoryRequirements {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetImageSparseMemoryRequirements");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetImageSparseMemoryRequirements$descriptor() {
        return vkGetImageSparseMemoryRequirements.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetImageSparseMemoryRequirements$handle() {
        return vkGetImageSparseMemoryRequirements.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetImageSparseMemoryRequirements$address() {
        return vkGetImageSparseMemoryRequirements.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements)
     * }
     */
    public static void vkGetImageSparseMemoryRequirements(MemorySegment device, MemorySegment image, MemorySegment pSparseMemoryRequirementCount, MemorySegment pSparseMemoryRequirements) {
        var mh$ = vkGetImageSparseMemoryRequirements.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageSparseMemoryRequirements", device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
            }
            mh$.invokeExact(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceSparseImageFormatProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSparseImageFormatProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSparseImageFormatProperties$descriptor() {
        return vkGetPhysicalDeviceSparseImageFormatProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSparseImageFormatProperties$handle() {
        return vkGetPhysicalDeviceSparseImageFormatProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSparseImageFormatProperties$address() {
        return vkGetPhysicalDeviceSparseImageFormatProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties)
     * }
     */
    public static void vkGetPhysicalDeviceSparseImageFormatProperties(MemorySegment physicalDevice, int format, int type, int samples, int usage, int tiling, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceSparseImageFormatProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSparseImageFormatProperties", physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
            }
            mh$.invokeExact(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkQueueBindSparse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkQueueBindSparse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkQueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence)
     * }
     */
    public static FunctionDescriptor vkQueueBindSparse$descriptor() {
        return vkQueueBindSparse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkQueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence)
     * }
     */
    public static MethodHandle vkQueueBindSparse$handle() {
        return vkQueueBindSparse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkQueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence)
     * }
     */
    public static MemorySegment vkQueueBindSparse$address() {
        return vkQueueBindSparse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkQueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence)
     * }
     */
    public static int vkQueueBindSparse(MemorySegment queue, int bindInfoCount, MemorySegment pBindInfo, MemorySegment fence) {
        var mh$ = vkQueueBindSparse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkQueueBindSparse", queue, bindInfoCount, pBindInfo, fence);
            }
            return (int)mh$.invokeExact(queue, bindInfoCount, pBindInfo, fence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateFence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateFence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static FunctionDescriptor vkCreateFence$descriptor() {
        return vkCreateFence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static MethodHandle vkCreateFence$handle() {
        return vkCreateFence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static MemorySegment vkCreateFence$address() {
        return vkCreateFence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static int vkCreateFence(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pFence) {
        var mh$ = vkCreateFence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateFence", device, pCreateInfo, pAllocator, pFence);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pFence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyFence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyFence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyFence$descriptor() {
        return vkDestroyFence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyFence$handle() {
        return vkDestroyFence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyFence$address() {
        return vkDestroyFence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyFence(MemorySegment device, MemorySegment fence, MemorySegment pAllocator) {
        var mh$ = vkDestroyFence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyFence", device, fence, pAllocator);
            }
            mh$.invokeExact(device, fence, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkResetFences {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkResetFences");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences)
     * }
     */
    public static FunctionDescriptor vkResetFences$descriptor() {
        return vkResetFences.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences)
     * }
     */
    public static MethodHandle vkResetFences$handle() {
        return vkResetFences.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences)
     * }
     */
    public static MemorySegment vkResetFences$address() {
        return vkResetFences.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences)
     * }
     */
    public static int vkResetFences(MemorySegment device, int fenceCount, MemorySegment pFences) {
        var mh$ = vkResetFences.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkResetFences", device, fenceCount, pFences);
            }
            return (int)mh$.invokeExact(device, fenceCount, pFences);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetFenceStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetFenceStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetFenceStatus(VkDevice device, VkFence fence)
     * }
     */
    public static FunctionDescriptor vkGetFenceStatus$descriptor() {
        return vkGetFenceStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetFenceStatus(VkDevice device, VkFence fence)
     * }
     */
    public static MethodHandle vkGetFenceStatus$handle() {
        return vkGetFenceStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetFenceStatus(VkDevice device, VkFence fence)
     * }
     */
    public static MemorySegment vkGetFenceStatus$address() {
        return vkGetFenceStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetFenceStatus(VkDevice device, VkFence fence)
     * }
     */
    public static int vkGetFenceStatus(MemorySegment device, MemorySegment fence) {
        var mh$ = vkGetFenceStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetFenceStatus", device, fence);
            }
            return (int)mh$.invokeExact(device, fence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkWaitForFences {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_LONG
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkWaitForFences");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkWaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout)
     * }
     */
    public static FunctionDescriptor vkWaitForFences$descriptor() {
        return vkWaitForFences.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkWaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout)
     * }
     */
    public static MethodHandle vkWaitForFences$handle() {
        return vkWaitForFences.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkWaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout)
     * }
     */
    public static MemorySegment vkWaitForFences$address() {
        return vkWaitForFences.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkWaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout)
     * }
     */
    public static int vkWaitForFences(MemorySegment device, int fenceCount, MemorySegment pFences, int waitAll, long timeout) {
        var mh$ = vkWaitForFences.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkWaitForFences", device, fenceCount, pFences, waitAll, timeout);
            }
            return (int)mh$.invokeExact(device, fenceCount, pFences, waitAll, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateSemaphore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateSemaphore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore)
     * }
     */
    public static FunctionDescriptor vkCreateSemaphore$descriptor() {
        return vkCreateSemaphore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore)
     * }
     */
    public static MethodHandle vkCreateSemaphore$handle() {
        return vkCreateSemaphore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore)
     * }
     */
    public static MemorySegment vkCreateSemaphore$address() {
        return vkCreateSemaphore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore)
     * }
     */
    public static int vkCreateSemaphore(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSemaphore) {
        var mh$ = vkCreateSemaphore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateSemaphore", device, pCreateInfo, pAllocator, pSemaphore);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pSemaphore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroySemaphore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroySemaphore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroySemaphore$descriptor() {
        return vkDestroySemaphore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroySemaphore$handle() {
        return vkDestroySemaphore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroySemaphore$address() {
        return vkDestroySemaphore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroySemaphore(MemorySegment device, MemorySegment semaphore, MemorySegment pAllocator) {
        var mh$ = vkDestroySemaphore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroySemaphore", device, semaphore, pAllocator);
            }
            mh$.invokeExact(device, semaphore, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent)
     * }
     */
    public static FunctionDescriptor vkCreateEvent$descriptor() {
        return vkCreateEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent)
     * }
     */
    public static MethodHandle vkCreateEvent$handle() {
        return vkCreateEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent)
     * }
     */
    public static MemorySegment vkCreateEvent$address() {
        return vkCreateEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent)
     * }
     */
    public static int vkCreateEvent(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pEvent) {
        var mh$ = vkCreateEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateEvent", device, pCreateInfo, pAllocator, pEvent);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyEvent$descriptor() {
        return vkDestroyEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyEvent$handle() {
        return vkDestroyEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyEvent$address() {
        return vkDestroyEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyEvent(MemorySegment device, MemorySegment event, MemorySegment pAllocator) {
        var mh$ = vkDestroyEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyEvent", device, event, pAllocator);
            }
            mh$.invokeExact(device, event, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetEventStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetEventStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetEventStatus(VkDevice device, VkEvent event)
     * }
     */
    public static FunctionDescriptor vkGetEventStatus$descriptor() {
        return vkGetEventStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetEventStatus(VkDevice device, VkEvent event)
     * }
     */
    public static MethodHandle vkGetEventStatus$handle() {
        return vkGetEventStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetEventStatus(VkDevice device, VkEvent event)
     * }
     */
    public static MemorySegment vkGetEventStatus$address() {
        return vkGetEventStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetEventStatus(VkDevice device, VkEvent event)
     * }
     */
    public static int vkGetEventStatus(MemorySegment device, MemorySegment event) {
        var mh$ = vkGetEventStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetEventStatus", device, event);
            }
            return (int)mh$.invokeExact(device, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkSetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkSetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkSetEvent(VkDevice device, VkEvent event)
     * }
     */
    public static FunctionDescriptor vkSetEvent$descriptor() {
        return vkSetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkSetEvent(VkDevice device, VkEvent event)
     * }
     */
    public static MethodHandle vkSetEvent$handle() {
        return vkSetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkSetEvent(VkDevice device, VkEvent event)
     * }
     */
    public static MemorySegment vkSetEvent$address() {
        return vkSetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkSetEvent(VkDevice device, VkEvent event)
     * }
     */
    public static int vkSetEvent(MemorySegment device, MemorySegment event) {
        var mh$ = vkSetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkSetEvent", device, event);
            }
            return (int)mh$.invokeExact(device, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkResetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkResetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkResetEvent(VkDevice device, VkEvent event)
     * }
     */
    public static FunctionDescriptor vkResetEvent$descriptor() {
        return vkResetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkResetEvent(VkDevice device, VkEvent event)
     * }
     */
    public static MethodHandle vkResetEvent$handle() {
        return vkResetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkResetEvent(VkDevice device, VkEvent event)
     * }
     */
    public static MemorySegment vkResetEvent$address() {
        return vkResetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkResetEvent(VkDevice device, VkEvent event)
     * }
     */
    public static int vkResetEvent(MemorySegment device, MemorySegment event) {
        var mh$ = vkResetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkResetEvent", device, event);
            }
            return (int)mh$.invokeExact(device, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateQueryPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateQueryPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool)
     * }
     */
    public static FunctionDescriptor vkCreateQueryPool$descriptor() {
        return vkCreateQueryPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool)
     * }
     */
    public static MethodHandle vkCreateQueryPool$handle() {
        return vkCreateQueryPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool)
     * }
     */
    public static MemorySegment vkCreateQueryPool$address() {
        return vkCreateQueryPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool)
     * }
     */
    public static int vkCreateQueryPool(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pQueryPool) {
        var mh$ = vkCreateQueryPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateQueryPool", device, pCreateInfo, pAllocator, pQueryPool);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pQueryPool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyQueryPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyQueryPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyQueryPool$descriptor() {
        return vkDestroyQueryPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyQueryPool$handle() {
        return vkDestroyQueryPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyQueryPool$address() {
        return vkDestroyQueryPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyQueryPool(MemorySegment device, MemorySegment queryPool, MemorySegment pAllocator) {
        var mh$ = vkDestroyQueryPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyQueryPool", device, queryPool, pAllocator);
            }
            mh$.invokeExact(device, queryPool, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetQueryPoolResults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetQueryPoolResults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags)
     * }
     */
    public static FunctionDescriptor vkGetQueryPoolResults$descriptor() {
        return vkGetQueryPoolResults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags)
     * }
     */
    public static MethodHandle vkGetQueryPoolResults$handle() {
        return vkGetQueryPoolResults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags)
     * }
     */
    public static MemorySegment vkGetQueryPoolResults$address() {
        return vkGetQueryPoolResults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags)
     * }
     */
    public static int vkGetQueryPoolResults(MemorySegment device, MemorySegment queryPool, int firstQuery, int queryCount, long dataSize, MemorySegment pData, long stride, int flags) {
        var mh$ = vkGetQueryPoolResults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetQueryPoolResults", device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
            }
            return (int)mh$.invokeExact(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer)
     * }
     */
    public static FunctionDescriptor vkCreateBuffer$descriptor() {
        return vkCreateBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer)
     * }
     */
    public static MethodHandle vkCreateBuffer$handle() {
        return vkCreateBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer)
     * }
     */
    public static MemorySegment vkCreateBuffer$address() {
        return vkCreateBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer)
     * }
     */
    public static int vkCreateBuffer(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pBuffer) {
        var mh$ = vkCreateBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateBuffer", device, pCreateInfo, pAllocator, pBuffer);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyBuffer$descriptor() {
        return vkDestroyBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyBuffer$handle() {
        return vkDestroyBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyBuffer$address() {
        return vkDestroyBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyBuffer(MemorySegment device, MemorySegment buffer, MemorySegment pAllocator) {
        var mh$ = vkDestroyBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyBuffer", device, buffer, pAllocator);
            }
            mh$.invokeExact(device, buffer, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateBufferView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateBufferView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView)
     * }
     */
    public static FunctionDescriptor vkCreateBufferView$descriptor() {
        return vkCreateBufferView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView)
     * }
     */
    public static MethodHandle vkCreateBufferView$handle() {
        return vkCreateBufferView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView)
     * }
     */
    public static MemorySegment vkCreateBufferView$address() {
        return vkCreateBufferView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView)
     * }
     */
    public static int vkCreateBufferView(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pView) {
        var mh$ = vkCreateBufferView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateBufferView", device, pCreateInfo, pAllocator, pView);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pView);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyBufferView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyBufferView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyBufferView$descriptor() {
        return vkDestroyBufferView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyBufferView$handle() {
        return vkDestroyBufferView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyBufferView$address() {
        return vkDestroyBufferView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyBufferView(MemorySegment device, MemorySegment bufferView, MemorySegment pAllocator) {
        var mh$ = vkDestroyBufferView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyBufferView", device, bufferView, pAllocator);
            }
            mh$.invokeExact(device, bufferView, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage)
     * }
     */
    public static FunctionDescriptor vkCreateImage$descriptor() {
        return vkCreateImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage)
     * }
     */
    public static MethodHandle vkCreateImage$handle() {
        return vkCreateImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage)
     * }
     */
    public static MemorySegment vkCreateImage$address() {
        return vkCreateImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage)
     * }
     */
    public static int vkCreateImage(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pImage) {
        var mh$ = vkCreateImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateImage", device, pCreateInfo, pAllocator, pImage);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pImage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyImage$descriptor() {
        return vkDestroyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyImage$handle() {
        return vkDestroyImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyImage$address() {
        return vkDestroyImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyImage(MemorySegment device, MemorySegment image, MemorySegment pAllocator) {
        var mh$ = vkDestroyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyImage", device, image, pAllocator);
            }
            mh$.invokeExact(device, image, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageSubresourceLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetImageSubresourceLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout)
     * }
     */
    public static FunctionDescriptor vkGetImageSubresourceLayout$descriptor() {
        return vkGetImageSubresourceLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout)
     * }
     */
    public static MethodHandle vkGetImageSubresourceLayout$handle() {
        return vkGetImageSubresourceLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout)
     * }
     */
    public static MemorySegment vkGetImageSubresourceLayout$address() {
        return vkGetImageSubresourceLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout)
     * }
     */
    public static void vkGetImageSubresourceLayout(MemorySegment device, MemorySegment image, MemorySegment pSubresource, MemorySegment pLayout) {
        var mh$ = vkGetImageSubresourceLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageSubresourceLayout", device, image, pSubresource, pLayout);
            }
            mh$.invokeExact(device, image, pSubresource, pLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateImageView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateImageView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView)
     * }
     */
    public static FunctionDescriptor vkCreateImageView$descriptor() {
        return vkCreateImageView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView)
     * }
     */
    public static MethodHandle vkCreateImageView$handle() {
        return vkCreateImageView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView)
     * }
     */
    public static MemorySegment vkCreateImageView$address() {
        return vkCreateImageView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView)
     * }
     */
    public static int vkCreateImageView(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pView) {
        var mh$ = vkCreateImageView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateImageView", device, pCreateInfo, pAllocator, pView);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pView);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyImageView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyImageView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyImageView$descriptor() {
        return vkDestroyImageView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyImageView$handle() {
        return vkDestroyImageView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyImageView$address() {
        return vkDestroyImageView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyImageView(MemorySegment device, MemorySegment imageView, MemorySegment pAllocator) {
        var mh$ = vkDestroyImageView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyImageView", device, imageView, pAllocator);
            }
            mh$.invokeExact(device, imageView, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateShaderModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateShaderModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule)
     * }
     */
    public static FunctionDescriptor vkCreateShaderModule$descriptor() {
        return vkCreateShaderModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule)
     * }
     */
    public static MethodHandle vkCreateShaderModule$handle() {
        return vkCreateShaderModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule)
     * }
     */
    public static MemorySegment vkCreateShaderModule$address() {
        return vkCreateShaderModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule)
     * }
     */
    public static int vkCreateShaderModule(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pShaderModule) {
        var mh$ = vkCreateShaderModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateShaderModule", device, pCreateInfo, pAllocator, pShaderModule);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pShaderModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyShaderModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyShaderModule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyShaderModule$descriptor() {
        return vkDestroyShaderModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyShaderModule$handle() {
        return vkDestroyShaderModule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyShaderModule$address() {
        return vkDestroyShaderModule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyShaderModule(MemorySegment device, MemorySegment shaderModule, MemorySegment pAllocator) {
        var mh$ = vkDestroyShaderModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyShaderModule", device, shaderModule, pAllocator);
            }
            mh$.invokeExact(device, shaderModule, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreatePipelineCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreatePipelineCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache)
     * }
     */
    public static FunctionDescriptor vkCreatePipelineCache$descriptor() {
        return vkCreatePipelineCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache)
     * }
     */
    public static MethodHandle vkCreatePipelineCache$handle() {
        return vkCreatePipelineCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache)
     * }
     */
    public static MemorySegment vkCreatePipelineCache$address() {
        return vkCreatePipelineCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache)
     * }
     */
    public static int vkCreatePipelineCache(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pPipelineCache) {
        var mh$ = vkCreatePipelineCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreatePipelineCache", device, pCreateInfo, pAllocator, pPipelineCache);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pPipelineCache);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyPipelineCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyPipelineCache");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyPipelineCache$descriptor() {
        return vkDestroyPipelineCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyPipelineCache$handle() {
        return vkDestroyPipelineCache.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyPipelineCache$address() {
        return vkDestroyPipelineCache.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyPipelineCache(MemorySegment device, MemorySegment pipelineCache, MemorySegment pAllocator) {
        var mh$ = vkDestroyPipelineCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyPipelineCache", device, pipelineCache, pAllocator);
            }
            mh$.invokeExact(device, pipelineCache, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPipelineCacheData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPipelineCacheData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData)
     * }
     */
    public static FunctionDescriptor vkGetPipelineCacheData$descriptor() {
        return vkGetPipelineCacheData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData)
     * }
     */
    public static MethodHandle vkGetPipelineCacheData$handle() {
        return vkGetPipelineCacheData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData)
     * }
     */
    public static MemorySegment vkGetPipelineCacheData$address() {
        return vkGetPipelineCacheData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData)
     * }
     */
    public static int vkGetPipelineCacheData(MemorySegment device, MemorySegment pipelineCache, MemorySegment pDataSize, MemorySegment pData) {
        var mh$ = vkGetPipelineCacheData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPipelineCacheData", device, pipelineCache, pDataSize, pData);
            }
            return (int)mh$.invokeExact(device, pipelineCache, pDataSize, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkMergePipelineCaches {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkMergePipelineCaches");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches)
     * }
     */
    public static FunctionDescriptor vkMergePipelineCaches$descriptor() {
        return vkMergePipelineCaches.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches)
     * }
     */
    public static MethodHandle vkMergePipelineCaches$handle() {
        return vkMergePipelineCaches.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches)
     * }
     */
    public static MemorySegment vkMergePipelineCaches$address() {
        return vkMergePipelineCaches.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkMergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches)
     * }
     */
    public static int vkMergePipelineCaches(MemorySegment device, MemorySegment dstCache, int srcCacheCount, MemorySegment pSrcCaches) {
        var mh$ = vkMergePipelineCaches.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkMergePipelineCaches", device, dstCache, srcCacheCount, pSrcCaches);
            }
            return (int)mh$.invokeExact(device, dstCache, srcCacheCount, pSrcCaches);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateGraphicsPipelines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateGraphicsPipelines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static FunctionDescriptor vkCreateGraphicsPipelines$descriptor() {
        return vkCreateGraphicsPipelines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static MethodHandle vkCreateGraphicsPipelines$handle() {
        return vkCreateGraphicsPipelines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static MemorySegment vkCreateGraphicsPipelines$address() {
        return vkCreateGraphicsPipelines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static int vkCreateGraphicsPipelines(MemorySegment device, MemorySegment pipelineCache, int createInfoCount, MemorySegment pCreateInfos, MemorySegment pAllocator, MemorySegment pPipelines) {
        var mh$ = vkCreateGraphicsPipelines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateGraphicsPipelines", device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
            }
            return (int)mh$.invokeExact(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateComputePipelines {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateComputePipelines");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static FunctionDescriptor vkCreateComputePipelines$descriptor() {
        return vkCreateComputePipelines.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static MethodHandle vkCreateComputePipelines$handle() {
        return vkCreateComputePipelines.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static MemorySegment vkCreateComputePipelines$address() {
        return vkCreateComputePipelines.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines)
     * }
     */
    public static int vkCreateComputePipelines(MemorySegment device, MemorySegment pipelineCache, int createInfoCount, MemorySegment pCreateInfos, MemorySegment pAllocator, MemorySegment pPipelines) {
        var mh$ = vkCreateComputePipelines.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateComputePipelines", device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
            }
            return (int)mh$.invokeExact(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyPipeline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyPipeline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyPipeline$descriptor() {
        return vkDestroyPipeline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyPipeline$handle() {
        return vkDestroyPipeline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyPipeline$address() {
        return vkDestroyPipeline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyPipeline(MemorySegment device, MemorySegment pipeline, MemorySegment pAllocator) {
        var mh$ = vkDestroyPipeline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyPipeline", device, pipeline, pAllocator);
            }
            mh$.invokeExact(device, pipeline, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreatePipelineLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreatePipelineLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout)
     * }
     */
    public static FunctionDescriptor vkCreatePipelineLayout$descriptor() {
        return vkCreatePipelineLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout)
     * }
     */
    public static MethodHandle vkCreatePipelineLayout$handle() {
        return vkCreatePipelineLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout)
     * }
     */
    public static MemorySegment vkCreatePipelineLayout$address() {
        return vkCreatePipelineLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout)
     * }
     */
    public static int vkCreatePipelineLayout(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pPipelineLayout) {
        var mh$ = vkCreatePipelineLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreatePipelineLayout", device, pCreateInfo, pAllocator, pPipelineLayout);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pPipelineLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyPipelineLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyPipelineLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyPipelineLayout$descriptor() {
        return vkDestroyPipelineLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyPipelineLayout$handle() {
        return vkDestroyPipelineLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyPipelineLayout$address() {
        return vkDestroyPipelineLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyPipelineLayout(MemorySegment device, MemorySegment pipelineLayout, MemorySegment pAllocator) {
        var mh$ = vkDestroyPipelineLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyPipelineLayout", device, pipelineLayout, pAllocator);
            }
            mh$.invokeExact(device, pipelineLayout, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateSampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateSampler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler)
     * }
     */
    public static FunctionDescriptor vkCreateSampler$descriptor() {
        return vkCreateSampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler)
     * }
     */
    public static MethodHandle vkCreateSampler$handle() {
        return vkCreateSampler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler)
     * }
     */
    public static MemorySegment vkCreateSampler$address() {
        return vkCreateSampler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler)
     * }
     */
    public static int vkCreateSampler(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSampler) {
        var mh$ = vkCreateSampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateSampler", device, pCreateInfo, pAllocator, pSampler);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pSampler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroySampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroySampler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroySampler$descriptor() {
        return vkDestroySampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroySampler$handle() {
        return vkDestroySampler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroySampler$address() {
        return vkDestroySampler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroySampler(MemorySegment device, MemorySegment sampler, MemorySegment pAllocator) {
        var mh$ = vkDestroySampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroySampler", device, sampler, pAllocator);
            }
            mh$.invokeExact(device, sampler, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateDescriptorSetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateDescriptorSetLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout)
     * }
     */
    public static FunctionDescriptor vkCreateDescriptorSetLayout$descriptor() {
        return vkCreateDescriptorSetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout)
     * }
     */
    public static MethodHandle vkCreateDescriptorSetLayout$handle() {
        return vkCreateDescriptorSetLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout)
     * }
     */
    public static MemorySegment vkCreateDescriptorSetLayout$address() {
        return vkCreateDescriptorSetLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout)
     * }
     */
    public static int vkCreateDescriptorSetLayout(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSetLayout) {
        var mh$ = vkCreateDescriptorSetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateDescriptorSetLayout", device, pCreateInfo, pAllocator, pSetLayout);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pSetLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyDescriptorSetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyDescriptorSetLayout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyDescriptorSetLayout$descriptor() {
        return vkDestroyDescriptorSetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyDescriptorSetLayout$handle() {
        return vkDestroyDescriptorSetLayout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyDescriptorSetLayout$address() {
        return vkDestroyDescriptorSetLayout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyDescriptorSetLayout(MemorySegment device, MemorySegment descriptorSetLayout, MemorySegment pAllocator) {
        var mh$ = vkDestroyDescriptorSetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyDescriptorSetLayout", device, descriptorSetLayout, pAllocator);
            }
            mh$.invokeExact(device, descriptorSetLayout, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateDescriptorPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateDescriptorPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool)
     * }
     */
    public static FunctionDescriptor vkCreateDescriptorPool$descriptor() {
        return vkCreateDescriptorPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool)
     * }
     */
    public static MethodHandle vkCreateDescriptorPool$handle() {
        return vkCreateDescriptorPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool)
     * }
     */
    public static MemorySegment vkCreateDescriptorPool$address() {
        return vkCreateDescriptorPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool)
     * }
     */
    public static int vkCreateDescriptorPool(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pDescriptorPool) {
        var mh$ = vkCreateDescriptorPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateDescriptorPool", device, pCreateInfo, pAllocator, pDescriptorPool);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pDescriptorPool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyDescriptorPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyDescriptorPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyDescriptorPool$descriptor() {
        return vkDestroyDescriptorPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyDescriptorPool$handle() {
        return vkDestroyDescriptorPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyDescriptorPool$address() {
        return vkDestroyDescriptorPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyDescriptorPool(MemorySegment device, MemorySegment descriptorPool, MemorySegment pAllocator) {
        var mh$ = vkDestroyDescriptorPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyDescriptorPool", device, descriptorPool, pAllocator);
            }
            mh$.invokeExact(device, descriptorPool, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkResetDescriptorPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkResetDescriptorPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags)
     * }
     */
    public static FunctionDescriptor vkResetDescriptorPool$descriptor() {
        return vkResetDescriptorPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags)
     * }
     */
    public static MethodHandle vkResetDescriptorPool$handle() {
        return vkResetDescriptorPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags)
     * }
     */
    public static MemorySegment vkResetDescriptorPool$address() {
        return vkResetDescriptorPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags)
     * }
     */
    public static int vkResetDescriptorPool(MemorySegment device, MemorySegment descriptorPool, int flags) {
        var mh$ = vkResetDescriptorPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkResetDescriptorPool", device, descriptorPool, flags);
            }
            return (int)mh$.invokeExact(device, descriptorPool, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkAllocateDescriptorSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkAllocateDescriptorSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkAllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets)
     * }
     */
    public static FunctionDescriptor vkAllocateDescriptorSets$descriptor() {
        return vkAllocateDescriptorSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkAllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets)
     * }
     */
    public static MethodHandle vkAllocateDescriptorSets$handle() {
        return vkAllocateDescriptorSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkAllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets)
     * }
     */
    public static MemorySegment vkAllocateDescriptorSets$address() {
        return vkAllocateDescriptorSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkAllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets)
     * }
     */
    public static int vkAllocateDescriptorSets(MemorySegment device, MemorySegment pAllocateInfo, MemorySegment pDescriptorSets) {
        var mh$ = vkAllocateDescriptorSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkAllocateDescriptorSets", device, pAllocateInfo, pDescriptorSets);
            }
            return (int)mh$.invokeExact(device, pAllocateInfo, pDescriptorSets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkFreeDescriptorSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkFreeDescriptorSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets)
     * }
     */
    public static FunctionDescriptor vkFreeDescriptorSets$descriptor() {
        return vkFreeDescriptorSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets)
     * }
     */
    public static MethodHandle vkFreeDescriptorSets$handle() {
        return vkFreeDescriptorSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets)
     * }
     */
    public static MemorySegment vkFreeDescriptorSets$address() {
        return vkFreeDescriptorSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkFreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets)
     * }
     */
    public static int vkFreeDescriptorSets(MemorySegment device, MemorySegment descriptorPool, int descriptorSetCount, MemorySegment pDescriptorSets) {
        var mh$ = vkFreeDescriptorSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkFreeDescriptorSets", device, descriptorPool, descriptorSetCount, pDescriptorSets);
            }
            return (int)mh$.invokeExact(device, descriptorPool, descriptorSetCount, pDescriptorSets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkUpdateDescriptorSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkUpdateDescriptorSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies)
     * }
     */
    public static FunctionDescriptor vkUpdateDescriptorSets$descriptor() {
        return vkUpdateDescriptorSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies)
     * }
     */
    public static MethodHandle vkUpdateDescriptorSets$handle() {
        return vkUpdateDescriptorSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies)
     * }
     */
    public static MemorySegment vkUpdateDescriptorSets$address() {
        return vkUpdateDescriptorSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkUpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies)
     * }
     */
    public static void vkUpdateDescriptorSets(MemorySegment device, int descriptorWriteCount, MemorySegment pDescriptorWrites, int descriptorCopyCount, MemorySegment pDescriptorCopies) {
        var mh$ = vkUpdateDescriptorSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkUpdateDescriptorSets", device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
            }
            mh$.invokeExact(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer)
     * }
     */
    public static FunctionDescriptor vkCreateFramebuffer$descriptor() {
        return vkCreateFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer)
     * }
     */
    public static MethodHandle vkCreateFramebuffer$handle() {
        return vkCreateFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer)
     * }
     */
    public static MemorySegment vkCreateFramebuffer$address() {
        return vkCreateFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer)
     * }
     */
    public static int vkCreateFramebuffer(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pFramebuffer) {
        var mh$ = vkCreateFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateFramebuffer", device, pCreateInfo, pAllocator, pFramebuffer);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pFramebuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyFramebuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyFramebuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyFramebuffer$descriptor() {
        return vkDestroyFramebuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyFramebuffer$handle() {
        return vkDestroyFramebuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyFramebuffer$address() {
        return vkDestroyFramebuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyFramebuffer(MemorySegment device, MemorySegment framebuffer, MemorySegment pAllocator) {
        var mh$ = vkDestroyFramebuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyFramebuffer", device, framebuffer, pAllocator);
            }
            mh$.invokeExact(device, framebuffer, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateRenderPass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateRenderPass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static FunctionDescriptor vkCreateRenderPass$descriptor() {
        return vkCreateRenderPass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static MethodHandle vkCreateRenderPass$handle() {
        return vkCreateRenderPass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static MemorySegment vkCreateRenderPass$address() {
        return vkCreateRenderPass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static int vkCreateRenderPass(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pRenderPass) {
        var mh$ = vkCreateRenderPass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateRenderPass", device, pCreateInfo, pAllocator, pRenderPass);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pRenderPass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyRenderPass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyRenderPass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyRenderPass$descriptor() {
        return vkDestroyRenderPass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyRenderPass$handle() {
        return vkDestroyRenderPass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyRenderPass$address() {
        return vkDestroyRenderPass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyRenderPass(MemorySegment device, MemorySegment renderPass, MemorySegment pAllocator) {
        var mh$ = vkDestroyRenderPass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyRenderPass", device, renderPass, pAllocator);
            }
            mh$.invokeExact(device, renderPass, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetRenderAreaGranularity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetRenderAreaGranularity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity)
     * }
     */
    public static FunctionDescriptor vkGetRenderAreaGranularity$descriptor() {
        return vkGetRenderAreaGranularity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity)
     * }
     */
    public static MethodHandle vkGetRenderAreaGranularity$handle() {
        return vkGetRenderAreaGranularity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity)
     * }
     */
    public static MemorySegment vkGetRenderAreaGranularity$address() {
        return vkGetRenderAreaGranularity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity)
     * }
     */
    public static void vkGetRenderAreaGranularity(MemorySegment device, MemorySegment renderPass, MemorySegment pGranularity) {
        var mh$ = vkGetRenderAreaGranularity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetRenderAreaGranularity", device, renderPass, pGranularity);
            }
            mh$.invokeExact(device, renderPass, pGranularity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateCommandPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateCommandPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool)
     * }
     */
    public static FunctionDescriptor vkCreateCommandPool$descriptor() {
        return vkCreateCommandPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool)
     * }
     */
    public static MethodHandle vkCreateCommandPool$handle() {
        return vkCreateCommandPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool)
     * }
     */
    public static MemorySegment vkCreateCommandPool$address() {
        return vkCreateCommandPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool)
     * }
     */
    public static int vkCreateCommandPool(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pCommandPool) {
        var mh$ = vkCreateCommandPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateCommandPool", device, pCreateInfo, pAllocator, pCommandPool);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pCommandPool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyCommandPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyCommandPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyCommandPool$descriptor() {
        return vkDestroyCommandPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyCommandPool$handle() {
        return vkDestroyCommandPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyCommandPool$address() {
        return vkDestroyCommandPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyCommandPool(MemorySegment device, MemorySegment commandPool, MemorySegment pAllocator) {
        var mh$ = vkDestroyCommandPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyCommandPool", device, commandPool, pAllocator);
            }
            mh$.invokeExact(device, commandPool, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkResetCommandPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkResetCommandPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags)
     * }
     */
    public static FunctionDescriptor vkResetCommandPool$descriptor() {
        return vkResetCommandPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags)
     * }
     */
    public static MethodHandle vkResetCommandPool$handle() {
        return vkResetCommandPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags)
     * }
     */
    public static MemorySegment vkResetCommandPool$address() {
        return vkResetCommandPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags)
     * }
     */
    public static int vkResetCommandPool(MemorySegment device, MemorySegment commandPool, int flags) {
        var mh$ = vkResetCommandPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkResetCommandPool", device, commandPool, flags);
            }
            return (int)mh$.invokeExact(device, commandPool, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkAllocateCommandBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkAllocateCommandBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkAllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static FunctionDescriptor vkAllocateCommandBuffers$descriptor() {
        return vkAllocateCommandBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkAllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static MethodHandle vkAllocateCommandBuffers$handle() {
        return vkAllocateCommandBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkAllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static MemorySegment vkAllocateCommandBuffers$address() {
        return vkAllocateCommandBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkAllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static int vkAllocateCommandBuffers(MemorySegment device, MemorySegment pAllocateInfo, MemorySegment pCommandBuffers) {
        var mh$ = vkAllocateCommandBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkAllocateCommandBuffers", device, pAllocateInfo, pCommandBuffers);
            }
            return (int)mh$.invokeExact(device, pAllocateInfo, pCommandBuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkFreeCommandBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkFreeCommandBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static FunctionDescriptor vkFreeCommandBuffers$descriptor() {
        return vkFreeCommandBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static MethodHandle vkFreeCommandBuffers$handle() {
        return vkFreeCommandBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static MemorySegment vkFreeCommandBuffers$address() {
        return vkFreeCommandBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkFreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static void vkFreeCommandBuffers(MemorySegment device, MemorySegment commandPool, int commandBufferCount, MemorySegment pCommandBuffers) {
        var mh$ = vkFreeCommandBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkFreeCommandBuffers", device, commandPool, commandBufferCount, pCommandBuffers);
            }
            mh$.invokeExact(device, commandPool, commandBufferCount, pCommandBuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBeginCommandBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkBeginCommandBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo)
     * }
     */
    public static FunctionDescriptor vkBeginCommandBuffer$descriptor() {
        return vkBeginCommandBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo)
     * }
     */
    public static MethodHandle vkBeginCommandBuffer$handle() {
        return vkBeginCommandBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkBeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo)
     * }
     */
    public static MemorySegment vkBeginCommandBuffer$address() {
        return vkBeginCommandBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkBeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo)
     * }
     */
    public static int vkBeginCommandBuffer(MemorySegment commandBuffer, MemorySegment pBeginInfo) {
        var mh$ = vkBeginCommandBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBeginCommandBuffer", commandBuffer, pBeginInfo);
            }
            return (int)mh$.invokeExact(commandBuffer, pBeginInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkEndCommandBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEndCommandBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEndCommandBuffer(VkCommandBuffer commandBuffer)
     * }
     */
    public static FunctionDescriptor vkEndCommandBuffer$descriptor() {
        return vkEndCommandBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEndCommandBuffer(VkCommandBuffer commandBuffer)
     * }
     */
    public static MethodHandle vkEndCommandBuffer$handle() {
        return vkEndCommandBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEndCommandBuffer(VkCommandBuffer commandBuffer)
     * }
     */
    public static MemorySegment vkEndCommandBuffer$address() {
        return vkEndCommandBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEndCommandBuffer(VkCommandBuffer commandBuffer)
     * }
     */
    public static int vkEndCommandBuffer(MemorySegment commandBuffer) {
        var mh$ = vkEndCommandBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEndCommandBuffer", commandBuffer);
            }
            return (int)mh$.invokeExact(commandBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkResetCommandBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkResetCommandBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
     * }
     */
    public static FunctionDescriptor vkResetCommandBuffer$descriptor() {
        return vkResetCommandBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
     * }
     */
    public static MethodHandle vkResetCommandBuffer$handle() {
        return vkResetCommandBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
     * }
     */
    public static MemorySegment vkResetCommandBuffer$address() {
        return vkResetCommandBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
     * }
     */
    public static int vkResetCommandBuffer(MemorySegment commandBuffer, int flags) {
        var mh$ = vkResetCommandBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkResetCommandBuffer", commandBuffer, flags);
            }
            return (int)mh$.invokeExact(commandBuffer, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindPipeline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBindPipeline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
     * }
     */
    public static FunctionDescriptor vkCmdBindPipeline$descriptor() {
        return vkCmdBindPipeline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
     * }
     */
    public static MethodHandle vkCmdBindPipeline$handle() {
        return vkCmdBindPipeline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
     * }
     */
    public static MemorySegment vkCmdBindPipeline$address() {
        return vkCmdBindPipeline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
     * }
     */
    public static void vkCmdBindPipeline(MemorySegment commandBuffer, int pipelineBindPoint, MemorySegment pipeline) {
        var mh$ = vkCmdBindPipeline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindPipeline", commandBuffer, pipelineBindPoint, pipeline);
            }
            mh$.invokeExact(commandBuffer, pipelineBindPoint, pipeline);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetViewport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetViewport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports)
     * }
     */
    public static FunctionDescriptor vkCmdSetViewport$descriptor() {
        return vkCmdSetViewport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports)
     * }
     */
    public static MethodHandle vkCmdSetViewport$handle() {
        return vkCmdSetViewport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports)
     * }
     */
    public static MemorySegment vkCmdSetViewport$address() {
        return vkCmdSetViewport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports)
     * }
     */
    public static void vkCmdSetViewport(MemorySegment commandBuffer, int firstViewport, int viewportCount, MemorySegment pViewports) {
        var mh$ = vkCmdSetViewport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetViewport", commandBuffer, firstViewport, viewportCount, pViewports);
            }
            mh$.invokeExact(commandBuffer, firstViewport, viewportCount, pViewports);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetScissor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetScissor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors)
     * }
     */
    public static FunctionDescriptor vkCmdSetScissor$descriptor() {
        return vkCmdSetScissor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors)
     * }
     */
    public static MethodHandle vkCmdSetScissor$handle() {
        return vkCmdSetScissor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors)
     * }
     */
    public static MemorySegment vkCmdSetScissor$address() {
        return vkCmdSetScissor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors)
     * }
     */
    public static void vkCmdSetScissor(MemorySegment commandBuffer, int firstScissor, int scissorCount, MemorySegment pScissors) {
        var mh$ = vkCmdSetScissor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetScissor", commandBuffer, firstScissor, scissorCount, pScissors);
            }
            mh$.invokeExact(commandBuffer, firstScissor, scissorCount, pScissors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetLineWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_FLOAT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetLineWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth)
     * }
     */
    public static FunctionDescriptor vkCmdSetLineWidth$descriptor() {
        return vkCmdSetLineWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth)
     * }
     */
    public static MethodHandle vkCmdSetLineWidth$handle() {
        return vkCmdSetLineWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth)
     * }
     */
    public static MemorySegment vkCmdSetLineWidth$address() {
        return vkCmdSetLineWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth)
     * }
     */
    public static void vkCmdSetLineWidth(MemorySegment commandBuffer, float lineWidth) {
        var mh$ = vkCmdSetLineWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetLineWidth", commandBuffer, lineWidth);
            }
            mh$.invokeExact(commandBuffer, lineWidth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthBias {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_FLOAT,
            vulkan_h.C_FLOAT,
            vulkan_h.C_FLOAT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetDepthBias");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthBias$descriptor() {
        return vkCmdSetDepthBias.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
     * }
     */
    public static MethodHandle vkCmdSetDepthBias$handle() {
        return vkCmdSetDepthBias.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
     * }
     */
    public static MemorySegment vkCmdSetDepthBias$address() {
        return vkCmdSetDepthBias.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
     * }
     */
    public static void vkCmdSetDepthBias(MemorySegment commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) {
        var mh$ = vkCmdSetDepthBias.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthBias", commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
            }
            mh$.invokeExact(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetBlendConstants {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetBlendConstants");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4])
     * }
     */
    public static FunctionDescriptor vkCmdSetBlendConstants$descriptor() {
        return vkCmdSetBlendConstants.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4])
     * }
     */
    public static MethodHandle vkCmdSetBlendConstants$handle() {
        return vkCmdSetBlendConstants.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4])
     * }
     */
    public static MemorySegment vkCmdSetBlendConstants$address() {
        return vkCmdSetBlendConstants.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4])
     * }
     */
    public static void vkCmdSetBlendConstants(MemorySegment commandBuffer, MemorySegment blendConstants) {
        var mh$ = vkCmdSetBlendConstants.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetBlendConstants", commandBuffer, blendConstants);
            }
            mh$.invokeExact(commandBuffer, blendConstants);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDepthBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_FLOAT,
            vulkan_h.C_FLOAT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetDepthBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds)
     * }
     */
    public static FunctionDescriptor vkCmdSetDepthBounds$descriptor() {
        return vkCmdSetDepthBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds)
     * }
     */
    public static MethodHandle vkCmdSetDepthBounds$handle() {
        return vkCmdSetDepthBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds)
     * }
     */
    public static MemorySegment vkCmdSetDepthBounds$address() {
        return vkCmdSetDepthBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds)
     * }
     */
    public static void vkCmdSetDepthBounds(MemorySegment commandBuffer, float minDepthBounds, float maxDepthBounds) {
        var mh$ = vkCmdSetDepthBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDepthBounds", commandBuffer, minDepthBounds, maxDepthBounds);
            }
            mh$.invokeExact(commandBuffer, minDepthBounds, maxDepthBounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetStencilCompareMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetStencilCompareMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask)
     * }
     */
    public static FunctionDescriptor vkCmdSetStencilCompareMask$descriptor() {
        return vkCmdSetStencilCompareMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask)
     * }
     */
    public static MethodHandle vkCmdSetStencilCompareMask$handle() {
        return vkCmdSetStencilCompareMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask)
     * }
     */
    public static MemorySegment vkCmdSetStencilCompareMask$address() {
        return vkCmdSetStencilCompareMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask)
     * }
     */
    public static void vkCmdSetStencilCompareMask(MemorySegment commandBuffer, int faceMask, int compareMask) {
        var mh$ = vkCmdSetStencilCompareMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetStencilCompareMask", commandBuffer, faceMask, compareMask);
            }
            mh$.invokeExact(commandBuffer, faceMask, compareMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetStencilWriteMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetStencilWriteMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask)
     * }
     */
    public static FunctionDescriptor vkCmdSetStencilWriteMask$descriptor() {
        return vkCmdSetStencilWriteMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask)
     * }
     */
    public static MethodHandle vkCmdSetStencilWriteMask$handle() {
        return vkCmdSetStencilWriteMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask)
     * }
     */
    public static MemorySegment vkCmdSetStencilWriteMask$address() {
        return vkCmdSetStencilWriteMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask)
     * }
     */
    public static void vkCmdSetStencilWriteMask(MemorySegment commandBuffer, int faceMask, int writeMask) {
        var mh$ = vkCmdSetStencilWriteMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetStencilWriteMask", commandBuffer, faceMask, writeMask);
            }
            mh$.invokeExact(commandBuffer, faceMask, writeMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetStencilReference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetStencilReference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference)
     * }
     */
    public static FunctionDescriptor vkCmdSetStencilReference$descriptor() {
        return vkCmdSetStencilReference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference)
     * }
     */
    public static MethodHandle vkCmdSetStencilReference$handle() {
        return vkCmdSetStencilReference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference)
     * }
     */
    public static MemorySegment vkCmdSetStencilReference$address() {
        return vkCmdSetStencilReference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference)
     * }
     */
    public static void vkCmdSetStencilReference(MemorySegment commandBuffer, int faceMask, int reference) {
        var mh$ = vkCmdSetStencilReference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetStencilReference", commandBuffer, faceMask, reference);
            }
            mh$.invokeExact(commandBuffer, faceMask, reference);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindDescriptorSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBindDescriptorSets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets)
     * }
     */
    public static FunctionDescriptor vkCmdBindDescriptorSets$descriptor() {
        return vkCmdBindDescriptorSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets)
     * }
     */
    public static MethodHandle vkCmdBindDescriptorSets$handle() {
        return vkCmdBindDescriptorSets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets)
     * }
     */
    public static MemorySegment vkCmdBindDescriptorSets$address() {
        return vkCmdBindDescriptorSets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets)
     * }
     */
    public static void vkCmdBindDescriptorSets(MemorySegment commandBuffer, int pipelineBindPoint, MemorySegment layout, int firstSet, int descriptorSetCount, MemorySegment pDescriptorSets, int dynamicOffsetCount, MemorySegment pDynamicOffsets) {
        var mh$ = vkCmdBindDescriptorSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindDescriptorSets", commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
            }
            mh$.invokeExact(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindIndexBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBindIndexBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
     * }
     */
    public static FunctionDescriptor vkCmdBindIndexBuffer$descriptor() {
        return vkCmdBindIndexBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
     * }
     */
    public static MethodHandle vkCmdBindIndexBuffer$handle() {
        return vkCmdBindIndexBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
     * }
     */
    public static MemorySegment vkCmdBindIndexBuffer$address() {
        return vkCmdBindIndexBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
     * }
     */
    public static void vkCmdBindIndexBuffer(MemorySegment commandBuffer, MemorySegment buffer, long offset, int indexType) {
        var mh$ = vkCmdBindIndexBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindIndexBuffer", commandBuffer, buffer, offset, indexType);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, indexType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBindVertexBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBindVertexBuffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets)
     * }
     */
    public static FunctionDescriptor vkCmdBindVertexBuffers$descriptor() {
        return vkCmdBindVertexBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets)
     * }
     */
    public static MethodHandle vkCmdBindVertexBuffers$handle() {
        return vkCmdBindVertexBuffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets)
     * }
     */
    public static MemorySegment vkCmdBindVertexBuffers$address() {
        return vkCmdBindVertexBuffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets)
     * }
     */
    public static void vkCmdBindVertexBuffers(MemorySegment commandBuffer, int firstBinding, int bindingCount, MemorySegment pBuffers, MemorySegment pOffsets) {
        var mh$ = vkCmdBindVertexBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindVertexBuffers", commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
            }
            mh$.invokeExact(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDraw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDraw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
     * }
     */
    public static FunctionDescriptor vkCmdDraw$descriptor() {
        return vkCmdDraw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
     * }
     */
    public static MethodHandle vkCmdDraw$handle() {
        return vkCmdDraw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
     * }
     */
    public static MemorySegment vkCmdDraw$address() {
        return vkCmdDraw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
     * }
     */
    public static void vkCmdDraw(MemorySegment commandBuffer, int vertexCount, int instanceCount, int firstVertex, int firstInstance) {
        var mh$ = vkCmdDraw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDraw", commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
            }
            mh$.invokeExact(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawIndexed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndexed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndexed$descriptor() {
        return vkCmdDrawIndexed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
     * }
     */
    public static MethodHandle vkCmdDrawIndexed$handle() {
        return vkCmdDrawIndexed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
     * }
     */
    public static MemorySegment vkCmdDrawIndexed$address() {
        return vkCmdDrawIndexed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
     * }
     */
    public static void vkCmdDrawIndexed(MemorySegment commandBuffer, int indexCount, int instanceCount, int firstIndex, int vertexOffset, int firstInstance) {
        var mh$ = vkCmdDrawIndexed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndexed", commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
            }
            mh$.invokeExact(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndirect$descriptor() {
        return vkCmdDrawIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawIndirect$handle() {
        return vkCmdDrawIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawIndirect$address() {
        return vkCmdDrawIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawIndirect(MemorySegment commandBuffer, MemorySegment buffer, long offset, int drawCount, int stride) {
        var mh$ = vkCmdDrawIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndirect", commandBuffer, buffer, offset, drawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, drawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawIndexedIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndexedIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndexedIndirect$descriptor() {
        return vkCmdDrawIndexedIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawIndexedIndirect$handle() {
        return vkCmdDrawIndexedIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawIndexedIndirect$address() {
        return vkCmdDrawIndexedIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawIndexedIndirect(MemorySegment commandBuffer, MemorySegment buffer, long offset, int drawCount, int stride) {
        var mh$ = vkCmdDrawIndexedIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndexedIndirect", commandBuffer, buffer, offset, drawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, drawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDispatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDispatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static FunctionDescriptor vkCmdDispatch$descriptor() {
        return vkCmdDispatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static MethodHandle vkCmdDispatch$handle() {
        return vkCmdDispatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static MemorySegment vkCmdDispatch$address() {
        return vkCmdDispatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static void vkCmdDispatch(MemorySegment commandBuffer, int groupCountX, int groupCountY, int groupCountZ) {
        var mh$ = vkCmdDispatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDispatch", commandBuffer, groupCountX, groupCountY, groupCountZ);
            }
            mh$.invokeExact(commandBuffer, groupCountX, groupCountY, groupCountZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDispatchIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDispatchIndirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
     * }
     */
    public static FunctionDescriptor vkCmdDispatchIndirect$descriptor() {
        return vkCmdDispatchIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
     * }
     */
    public static MethodHandle vkCmdDispatchIndirect$handle() {
        return vkCmdDispatchIndirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
     * }
     */
    public static MemorySegment vkCmdDispatchIndirect$address() {
        return vkCmdDispatchIndirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
     * }
     */
    public static void vkCmdDispatchIndirect(MemorySegment commandBuffer, MemorySegment buffer, long offset) {
        var mh$ = vkCmdDispatchIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDispatchIndirect", commandBuffer, buffer, offset);
            }
            mh$.invokeExact(commandBuffer, buffer, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdCopyBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions)
     * }
     */
    public static FunctionDescriptor vkCmdCopyBuffer$descriptor() {
        return vkCmdCopyBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions)
     * }
     */
    public static MethodHandle vkCmdCopyBuffer$handle() {
        return vkCmdCopyBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions)
     * }
     */
    public static MemorySegment vkCmdCopyBuffer$address() {
        return vkCmdCopyBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions)
     * }
     */
    public static void vkCmdCopyBuffer(MemorySegment commandBuffer, MemorySegment srcBuffer, MemorySegment dstBuffer, int regionCount, MemorySegment pRegions) {
        var mh$ = vkCmdCopyBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyBuffer", commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
            }
            mh$.invokeExact(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdCopyImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions)
     * }
     */
    public static FunctionDescriptor vkCmdCopyImage$descriptor() {
        return vkCmdCopyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions)
     * }
     */
    public static MethodHandle vkCmdCopyImage$handle() {
        return vkCmdCopyImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions)
     * }
     */
    public static MemorySegment vkCmdCopyImage$address() {
        return vkCmdCopyImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions)
     * }
     */
    public static void vkCmdCopyImage(MemorySegment commandBuffer, MemorySegment srcImage, int srcImageLayout, MemorySegment dstImage, int dstImageLayout, int regionCount, MemorySegment pRegions) {
        var mh$ = vkCmdCopyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyImage", commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
            }
            mh$.invokeExact(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBlitImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBlitImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter)
     * }
     */
    public static FunctionDescriptor vkCmdBlitImage$descriptor() {
        return vkCmdBlitImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter)
     * }
     */
    public static MethodHandle vkCmdBlitImage$handle() {
        return vkCmdBlitImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter)
     * }
     */
    public static MemorySegment vkCmdBlitImage$address() {
        return vkCmdBlitImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter)
     * }
     */
    public static void vkCmdBlitImage(MemorySegment commandBuffer, MemorySegment srcImage, int srcImageLayout, MemorySegment dstImage, int dstImageLayout, int regionCount, MemorySegment pRegions, int filter) {
        var mh$ = vkCmdBlitImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBlitImage", commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
            }
            mh$.invokeExact(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyBufferToImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdCopyBufferToImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions)
     * }
     */
    public static FunctionDescriptor vkCmdCopyBufferToImage$descriptor() {
        return vkCmdCopyBufferToImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions)
     * }
     */
    public static MethodHandle vkCmdCopyBufferToImage$handle() {
        return vkCmdCopyBufferToImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions)
     * }
     */
    public static MemorySegment vkCmdCopyBufferToImage$address() {
        return vkCmdCopyBufferToImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions)
     * }
     */
    public static void vkCmdCopyBufferToImage(MemorySegment commandBuffer, MemorySegment srcBuffer, MemorySegment dstImage, int dstImageLayout, int regionCount, MemorySegment pRegions) {
        var mh$ = vkCmdCopyBufferToImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyBufferToImage", commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
            }
            mh$.invokeExact(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyImageToBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdCopyImageToBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions)
     * }
     */
    public static FunctionDescriptor vkCmdCopyImageToBuffer$descriptor() {
        return vkCmdCopyImageToBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions)
     * }
     */
    public static MethodHandle vkCmdCopyImageToBuffer$handle() {
        return vkCmdCopyImageToBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions)
     * }
     */
    public static MemorySegment vkCmdCopyImageToBuffer$address() {
        return vkCmdCopyImageToBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions)
     * }
     */
    public static void vkCmdCopyImageToBuffer(MemorySegment commandBuffer, MemorySegment srcImage, int srcImageLayout, MemorySegment dstBuffer, int regionCount, MemorySegment pRegions) {
        var mh$ = vkCmdCopyImageToBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyImageToBuffer", commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
            }
            mh$.invokeExact(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdUpdateBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdUpdateBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData)
     * }
     */
    public static FunctionDescriptor vkCmdUpdateBuffer$descriptor() {
        return vkCmdUpdateBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData)
     * }
     */
    public static MethodHandle vkCmdUpdateBuffer$handle() {
        return vkCmdUpdateBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData)
     * }
     */
    public static MemorySegment vkCmdUpdateBuffer$address() {
        return vkCmdUpdateBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData)
     * }
     */
    public static void vkCmdUpdateBuffer(MemorySegment commandBuffer, MemorySegment dstBuffer, long dstOffset, long dataSize, MemorySegment pData) {
        var mh$ = vkCmdUpdateBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdUpdateBuffer", commandBuffer, dstBuffer, dstOffset, dataSize, pData);
            }
            mh$.invokeExact(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdFillBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_LONG,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdFillBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data)
     * }
     */
    public static FunctionDescriptor vkCmdFillBuffer$descriptor() {
        return vkCmdFillBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data)
     * }
     */
    public static MethodHandle vkCmdFillBuffer$handle() {
        return vkCmdFillBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data)
     * }
     */
    public static MemorySegment vkCmdFillBuffer$address() {
        return vkCmdFillBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data)
     * }
     */
    public static void vkCmdFillBuffer(MemorySegment commandBuffer, MemorySegment dstBuffer, long dstOffset, long size, int data) {
        var mh$ = vkCmdFillBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdFillBuffer", commandBuffer, dstBuffer, dstOffset, size, data);
            }
            mh$.invokeExact(commandBuffer, dstBuffer, dstOffset, size, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdClearColorImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdClearColorImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges)
     * }
     */
    public static FunctionDescriptor vkCmdClearColorImage$descriptor() {
        return vkCmdClearColorImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges)
     * }
     */
    public static MethodHandle vkCmdClearColorImage$handle() {
        return vkCmdClearColorImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges)
     * }
     */
    public static MemorySegment vkCmdClearColorImage$address() {
        return vkCmdClearColorImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges)
     * }
     */
    public static void vkCmdClearColorImage(MemorySegment commandBuffer, MemorySegment image, int imageLayout, MemorySegment pColor, int rangeCount, MemorySegment pRanges) {
        var mh$ = vkCmdClearColorImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdClearColorImage", commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
            }
            mh$.invokeExact(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdClearDepthStencilImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdClearDepthStencilImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges)
     * }
     */
    public static FunctionDescriptor vkCmdClearDepthStencilImage$descriptor() {
        return vkCmdClearDepthStencilImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges)
     * }
     */
    public static MethodHandle vkCmdClearDepthStencilImage$handle() {
        return vkCmdClearDepthStencilImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges)
     * }
     */
    public static MemorySegment vkCmdClearDepthStencilImage$address() {
        return vkCmdClearDepthStencilImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges)
     * }
     */
    public static void vkCmdClearDepthStencilImage(MemorySegment commandBuffer, MemorySegment image, int imageLayout, MemorySegment pDepthStencil, int rangeCount, MemorySegment pRanges) {
        var mh$ = vkCmdClearDepthStencilImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdClearDepthStencilImage", commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
            }
            mh$.invokeExact(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdClearAttachments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdClearAttachments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects)
     * }
     */
    public static FunctionDescriptor vkCmdClearAttachments$descriptor() {
        return vkCmdClearAttachments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects)
     * }
     */
    public static MethodHandle vkCmdClearAttachments$handle() {
        return vkCmdClearAttachments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects)
     * }
     */
    public static MemorySegment vkCmdClearAttachments$address() {
        return vkCmdClearAttachments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects)
     * }
     */
    public static void vkCmdClearAttachments(MemorySegment commandBuffer, int attachmentCount, MemorySegment pAttachments, int rectCount, MemorySegment pRects) {
        var mh$ = vkCmdClearAttachments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdClearAttachments", commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
            }
            mh$.invokeExact(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdResolveImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdResolveImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions)
     * }
     */
    public static FunctionDescriptor vkCmdResolveImage$descriptor() {
        return vkCmdResolveImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions)
     * }
     */
    public static MethodHandle vkCmdResolveImage$handle() {
        return vkCmdResolveImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions)
     * }
     */
    public static MemorySegment vkCmdResolveImage$address() {
        return vkCmdResolveImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions)
     * }
     */
    public static void vkCmdResolveImage(MemorySegment commandBuffer, MemorySegment srcImage, int srcImageLayout, MemorySegment dstImage, int dstImageLayout, int regionCount, MemorySegment pRegions) {
        var mh$ = vkCmdResolveImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdResolveImage", commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
            }
            mh$.invokeExact(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
     * }
     */
    public static FunctionDescriptor vkCmdSetEvent$descriptor() {
        return vkCmdSetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
     * }
     */
    public static MethodHandle vkCmdSetEvent$handle() {
        return vkCmdSetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
     * }
     */
    public static MemorySegment vkCmdSetEvent$address() {
        return vkCmdSetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
     * }
     */
    public static void vkCmdSetEvent(MemorySegment commandBuffer, MemorySegment event, int stageMask) {
        var mh$ = vkCmdSetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetEvent", commandBuffer, event, stageMask);
            }
            mh$.invokeExact(commandBuffer, event, stageMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdResetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdResetEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
     * }
     */
    public static FunctionDescriptor vkCmdResetEvent$descriptor() {
        return vkCmdResetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
     * }
     */
    public static MethodHandle vkCmdResetEvent$handle() {
        return vkCmdResetEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
     * }
     */
    public static MemorySegment vkCmdResetEvent$address() {
        return vkCmdResetEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
     * }
     */
    public static void vkCmdResetEvent(MemorySegment commandBuffer, MemorySegment event, int stageMask) {
        var mh$ = vkCmdResetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdResetEvent", commandBuffer, event, stageMask);
            }
            mh$.invokeExact(commandBuffer, event, stageMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdWaitEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdWaitEvents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers)
     * }
     */
    public static FunctionDescriptor vkCmdWaitEvents$descriptor() {
        return vkCmdWaitEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers)
     * }
     */
    public static MethodHandle vkCmdWaitEvents$handle() {
        return vkCmdWaitEvents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers)
     * }
     */
    public static MemorySegment vkCmdWaitEvents$address() {
        return vkCmdWaitEvents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers)
     * }
     */
    public static void vkCmdWaitEvents(MemorySegment commandBuffer, int eventCount, MemorySegment pEvents, int srcStageMask, int dstStageMask, int memoryBarrierCount, MemorySegment pMemoryBarriers, int bufferMemoryBarrierCount, MemorySegment pBufferMemoryBarriers, int imageMemoryBarrierCount, MemorySegment pImageMemoryBarriers) {
        var mh$ = vkCmdWaitEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdWaitEvents", commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
            }
            mh$.invokeExact(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdPipelineBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdPipelineBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers)
     * }
     */
    public static FunctionDescriptor vkCmdPipelineBarrier$descriptor() {
        return vkCmdPipelineBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers)
     * }
     */
    public static MethodHandle vkCmdPipelineBarrier$handle() {
        return vkCmdPipelineBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers)
     * }
     */
    public static MemorySegment vkCmdPipelineBarrier$address() {
        return vkCmdPipelineBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers)
     * }
     */
    public static void vkCmdPipelineBarrier(MemorySegment commandBuffer, int srcStageMask, int dstStageMask, int dependencyFlags, int memoryBarrierCount, MemorySegment pMemoryBarriers, int bufferMemoryBarrierCount, MemorySegment pBufferMemoryBarriers, int imageMemoryBarrierCount, MemorySegment pImageMemoryBarriers) {
        var mh$ = vkCmdPipelineBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdPipelineBarrier", commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
            }
            mh$.invokeExact(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBeginQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBeginQuery");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags)
     * }
     */
    public static FunctionDescriptor vkCmdBeginQuery$descriptor() {
        return vkCmdBeginQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags)
     * }
     */
    public static MethodHandle vkCmdBeginQuery$handle() {
        return vkCmdBeginQuery.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags)
     * }
     */
    public static MemorySegment vkCmdBeginQuery$address() {
        return vkCmdBeginQuery.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags)
     * }
     */
    public static void vkCmdBeginQuery(MemorySegment commandBuffer, MemorySegment queryPool, int query, int flags) {
        var mh$ = vkCmdBeginQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBeginQuery", commandBuffer, queryPool, query, flags);
            }
            mh$.invokeExact(commandBuffer, queryPool, query, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdEndQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdEndQuery");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
     * }
     */
    public static FunctionDescriptor vkCmdEndQuery$descriptor() {
        return vkCmdEndQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
     * }
     */
    public static MethodHandle vkCmdEndQuery$handle() {
        return vkCmdEndQuery.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
     * }
     */
    public static MemorySegment vkCmdEndQuery$address() {
        return vkCmdEndQuery.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
     * }
     */
    public static void vkCmdEndQuery(MemorySegment commandBuffer, MemorySegment queryPool, int query) {
        var mh$ = vkCmdEndQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdEndQuery", commandBuffer, queryPool, query);
            }
            mh$.invokeExact(commandBuffer, queryPool, query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdResetQueryPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdResetQueryPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static FunctionDescriptor vkCmdResetQueryPool$descriptor() {
        return vkCmdResetQueryPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static MethodHandle vkCmdResetQueryPool$handle() {
        return vkCmdResetQueryPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static MemorySegment vkCmdResetQueryPool$address() {
        return vkCmdResetQueryPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static void vkCmdResetQueryPool(MemorySegment commandBuffer, MemorySegment queryPool, int firstQuery, int queryCount) {
        var mh$ = vkCmdResetQueryPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdResetQueryPool", commandBuffer, queryPool, firstQuery, queryCount);
            }
            mh$.invokeExact(commandBuffer, queryPool, firstQuery, queryCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdWriteTimestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdWriteTimestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query)
     * }
     */
    public static FunctionDescriptor vkCmdWriteTimestamp$descriptor() {
        return vkCmdWriteTimestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query)
     * }
     */
    public static MethodHandle vkCmdWriteTimestamp$handle() {
        return vkCmdWriteTimestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query)
     * }
     */
    public static MemorySegment vkCmdWriteTimestamp$address() {
        return vkCmdWriteTimestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query)
     * }
     */
    public static void vkCmdWriteTimestamp(MemorySegment commandBuffer, int pipelineStage, MemorySegment queryPool, int query) {
        var mh$ = vkCmdWriteTimestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdWriteTimestamp", commandBuffer, pipelineStage, queryPool, query);
            }
            mh$.invokeExact(commandBuffer, pipelineStage, queryPool, query);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdCopyQueryPoolResults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_LONG,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdCopyQueryPoolResults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags)
     * }
     */
    public static FunctionDescriptor vkCmdCopyQueryPoolResults$descriptor() {
        return vkCmdCopyQueryPoolResults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags)
     * }
     */
    public static MethodHandle vkCmdCopyQueryPoolResults$handle() {
        return vkCmdCopyQueryPoolResults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags)
     * }
     */
    public static MemorySegment vkCmdCopyQueryPoolResults$address() {
        return vkCmdCopyQueryPoolResults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags)
     * }
     */
    public static void vkCmdCopyQueryPoolResults(MemorySegment commandBuffer, MemorySegment queryPool, int firstQuery, int queryCount, MemorySegment dstBuffer, long dstOffset, long stride, int flags) {
        var mh$ = vkCmdCopyQueryPoolResults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdCopyQueryPoolResults", commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
            }
            mh$.invokeExact(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdPushConstants {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdPushConstants");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues)
     * }
     */
    public static FunctionDescriptor vkCmdPushConstants$descriptor() {
        return vkCmdPushConstants.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues)
     * }
     */
    public static MethodHandle vkCmdPushConstants$handle() {
        return vkCmdPushConstants.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues)
     * }
     */
    public static MemorySegment vkCmdPushConstants$address() {
        return vkCmdPushConstants.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues)
     * }
     */
    public static void vkCmdPushConstants(MemorySegment commandBuffer, MemorySegment layout, int stageFlags, int offset, int size, MemorySegment pValues) {
        var mh$ = vkCmdPushConstants.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdPushConstants", commandBuffer, layout, stageFlags, offset, size, pValues);
            }
            mh$.invokeExact(commandBuffer, layout, stageFlags, offset, size, pValues);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBeginRenderPass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBeginRenderPass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents)
     * }
     */
    public static FunctionDescriptor vkCmdBeginRenderPass$descriptor() {
        return vkCmdBeginRenderPass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents)
     * }
     */
    public static MethodHandle vkCmdBeginRenderPass$handle() {
        return vkCmdBeginRenderPass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents)
     * }
     */
    public static MemorySegment vkCmdBeginRenderPass$address() {
        return vkCmdBeginRenderPass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents)
     * }
     */
    public static void vkCmdBeginRenderPass(MemorySegment commandBuffer, MemorySegment pRenderPassBegin, int contents) {
        var mh$ = vkCmdBeginRenderPass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBeginRenderPass", commandBuffer, pRenderPassBegin, contents);
            }
            mh$.invokeExact(commandBuffer, pRenderPassBegin, contents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdNextSubpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdNextSubpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents)
     * }
     */
    public static FunctionDescriptor vkCmdNextSubpass$descriptor() {
        return vkCmdNextSubpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents)
     * }
     */
    public static MethodHandle vkCmdNextSubpass$handle() {
        return vkCmdNextSubpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents)
     * }
     */
    public static MemorySegment vkCmdNextSubpass$address() {
        return vkCmdNextSubpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents)
     * }
     */
    public static void vkCmdNextSubpass(MemorySegment commandBuffer, int contents) {
        var mh$ = vkCmdNextSubpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdNextSubpass", commandBuffer, contents);
            }
            mh$.invokeExact(commandBuffer, contents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdEndRenderPass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdEndRenderPass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdEndRenderPass(VkCommandBuffer commandBuffer)
     * }
     */
    public static FunctionDescriptor vkCmdEndRenderPass$descriptor() {
        return vkCmdEndRenderPass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdEndRenderPass(VkCommandBuffer commandBuffer)
     * }
     */
    public static MethodHandle vkCmdEndRenderPass$handle() {
        return vkCmdEndRenderPass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdEndRenderPass(VkCommandBuffer commandBuffer)
     * }
     */
    public static MemorySegment vkCmdEndRenderPass$address() {
        return vkCmdEndRenderPass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdEndRenderPass(VkCommandBuffer commandBuffer)
     * }
     */
    public static void vkCmdEndRenderPass(MemorySegment commandBuffer) {
        var mh$ = vkCmdEndRenderPass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdEndRenderPass", commandBuffer);
            }
            mh$.invokeExact(commandBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdExecuteCommands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdExecuteCommands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static FunctionDescriptor vkCmdExecuteCommands$descriptor() {
        return vkCmdExecuteCommands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static MethodHandle vkCmdExecuteCommands$handle() {
        return vkCmdExecuteCommands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static MemorySegment vkCmdExecuteCommands$address() {
        return vkCmdExecuteCommands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers)
     * }
     */
    public static void vkCmdExecuteCommands(MemorySegment commandBuffer, int commandBufferCount, MemorySegment pCommandBuffers) {
        var mh$ = vkCmdExecuteCommands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdExecuteCommands", commandBuffer, commandBufferCount, pCommandBuffers);
            }
            mh$.invokeExact(commandBuffer, commandBufferCount, pCommandBuffers);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkSamplerYcbcrConversion_T *VkSamplerYcbcrConversion
     * }
     */
    public static final AddressLayout VkSamplerYcbcrConversion = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct VkDescriptorUpdateTemplate_T *VkDescriptorUpdateTemplate
     * }
     */
    public static final AddressLayout VkDescriptorUpdateTemplate = vulkan_h.C_POINTER;
    private static final int VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPointClippingBehavior.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0
     * }
     */
    public static int VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES() {
        return VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES;
    }
    private static final int VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPointClippingBehavior.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1
     * }
     */
    public static int VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY() {
        return VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY;
    }
    private static final int VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPointClippingBehavior.VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = 0
     * }
     */
    public static int VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR() {
        return VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR;
    }
    private static final int VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPointClippingBehavior.VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = 1
     * }
     */
    public static int VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR() {
        return VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR;
    }
    private static final int VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPointClippingBehavior.VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE = 0
     * }
     */
    public static int VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE() {
        return VK_POINT_CLIPPING_BEHAVIOR_BEGIN_RANGE;
    }
    private static final int VK_POINT_CLIPPING_BEHAVIOR_END_RANGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPointClippingBehavior.VK_POINT_CLIPPING_BEHAVIOR_END_RANGE = 1
     * }
     */
    public static int VK_POINT_CLIPPING_BEHAVIOR_END_RANGE() {
        return VK_POINT_CLIPPING_BEHAVIOR_END_RANGE;
    }
    private static final int VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPointClippingBehavior.VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE = 2
     * }
     */
    public static int VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE() {
        return VK_POINT_CLIPPING_BEHAVIOR_RANGE_SIZE;
    }
    private static final int VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPointClippingBehavior.VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM() {
        return VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM;
    }
    private static final int VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkTessellationDomainOrigin.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0
     * }
     */
    public static int VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT() {
        return VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT;
    }
    private static final int VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkTessellationDomainOrigin.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1
     * }
     */
    public static int VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT() {
        return VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT;
    }
    private static final int VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkTessellationDomainOrigin.VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = 0
     * }
     */
    public static int VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR() {
        return VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR;
    }
    private static final int VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkTessellationDomainOrigin.VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = 1
     * }
     */
    public static int VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR() {
        return VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR;
    }
    private static final int VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkTessellationDomainOrigin.VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE = 0
     * }
     */
    public static int VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE() {
        return VK_TESSELLATION_DOMAIN_ORIGIN_BEGIN_RANGE;
    }
    private static final int VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkTessellationDomainOrigin.VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE = 1
     * }
     */
    public static int VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE() {
        return VK_TESSELLATION_DOMAIN_ORIGIN_END_RANGE;
    }
    private static final int VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkTessellationDomainOrigin.VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE = 2
     * }
     */
    public static int VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE() {
        return VK_TESSELLATION_DOMAIN_ORIGIN_RANGE_SIZE;
    }
    private static final int VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkTessellationDomainOrigin.VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM() {
        return VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = 0
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = 1
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = 2
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = 3
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = 4
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE = 0
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_BEGIN_RANGE;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE = 4
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_END_RANGE;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE = 5
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_RANGE_SIZE;
    }
    private static final int VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrModelConversion.VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM() {
        return VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM;
    }
    private static final int VK_SAMPLER_YCBCR_RANGE_ITU_FULL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrRange.VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0
     * }
     */
    public static int VK_SAMPLER_YCBCR_RANGE_ITU_FULL() {
        return VK_SAMPLER_YCBCR_RANGE_ITU_FULL;
    }
    private static final int VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrRange.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1
     * }
     */
    public static int VK_SAMPLER_YCBCR_RANGE_ITU_NARROW() {
        return VK_SAMPLER_YCBCR_RANGE_ITU_NARROW;
    }
    private static final int VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrRange.VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = 0
     * }
     */
    public static int VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR() {
        return VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR;
    }
    private static final int VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrRange.VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = 1
     * }
     */
    public static int VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR() {
        return VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR;
    }
    private static final int VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrRange.VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE = 0
     * }
     */
    public static int VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE() {
        return VK_SAMPLER_YCBCR_RANGE_BEGIN_RANGE;
    }
    private static final int VK_SAMPLER_YCBCR_RANGE_END_RANGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrRange.VK_SAMPLER_YCBCR_RANGE_END_RANGE = 1
     * }
     */
    public static int VK_SAMPLER_YCBCR_RANGE_END_RANGE() {
        return VK_SAMPLER_YCBCR_RANGE_END_RANGE;
    }
    private static final int VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrRange.VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE = 2
     * }
     */
    public static int VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE() {
        return VK_SAMPLER_YCBCR_RANGE_RANGE_SIZE;
    }
    private static final int VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerYcbcrRange.VK_SAMPLER_YCBCR_RANGE_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SAMPLER_YCBCR_RANGE_MAX_ENUM() {
        return VK_SAMPLER_YCBCR_RANGE_MAX_ENUM;
    }
    private static final int VK_CHROMA_LOCATION_COSITED_EVEN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkChromaLocation.VK_CHROMA_LOCATION_COSITED_EVEN = 0
     * }
     */
    public static int VK_CHROMA_LOCATION_COSITED_EVEN() {
        return VK_CHROMA_LOCATION_COSITED_EVEN;
    }
    private static final int VK_CHROMA_LOCATION_MIDPOINT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkChromaLocation.VK_CHROMA_LOCATION_MIDPOINT = 1
     * }
     */
    public static int VK_CHROMA_LOCATION_MIDPOINT() {
        return VK_CHROMA_LOCATION_MIDPOINT;
    }
    private static final int VK_CHROMA_LOCATION_COSITED_EVEN_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkChromaLocation.VK_CHROMA_LOCATION_COSITED_EVEN_KHR = 0
     * }
     */
    public static int VK_CHROMA_LOCATION_COSITED_EVEN_KHR() {
        return VK_CHROMA_LOCATION_COSITED_EVEN_KHR;
    }
    private static final int VK_CHROMA_LOCATION_MIDPOINT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkChromaLocation.VK_CHROMA_LOCATION_MIDPOINT_KHR = 1
     * }
     */
    public static int VK_CHROMA_LOCATION_MIDPOINT_KHR() {
        return VK_CHROMA_LOCATION_MIDPOINT_KHR;
    }
    private static final int VK_CHROMA_LOCATION_BEGIN_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkChromaLocation.VK_CHROMA_LOCATION_BEGIN_RANGE = 0
     * }
     */
    public static int VK_CHROMA_LOCATION_BEGIN_RANGE() {
        return VK_CHROMA_LOCATION_BEGIN_RANGE;
    }
    private static final int VK_CHROMA_LOCATION_END_RANGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkChromaLocation.VK_CHROMA_LOCATION_END_RANGE = 1
     * }
     */
    public static int VK_CHROMA_LOCATION_END_RANGE() {
        return VK_CHROMA_LOCATION_END_RANGE;
    }
    private static final int VK_CHROMA_LOCATION_RANGE_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkChromaLocation.VK_CHROMA_LOCATION_RANGE_SIZE = 2
     * }
     */
    public static int VK_CHROMA_LOCATION_RANGE_SIZE() {
        return VK_CHROMA_LOCATION_RANGE_SIZE;
    }
    private static final int VK_CHROMA_LOCATION_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkChromaLocation.VK_CHROMA_LOCATION_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_CHROMA_LOCATION_MAX_ENUM() {
        return VK_CHROMA_LOCATION_MAX_ENUM;
    }
    private static final int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorUpdateTemplateType.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0
     * }
     */
    public static int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET() {
        return VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET;
    }
    private static final int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorUpdateTemplateType.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1
     * }
     */
    public static int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR() {
        return VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR;
    }
    private static final int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorUpdateTemplateType.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = 0
     * }
     */
    public static int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR() {
        return VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR;
    }
    private static final int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorUpdateTemplateType.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE = 0
     * }
     */
    public static int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE() {
        return VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE;
    }
    private static final int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorUpdateTemplateType.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE = 0
     * }
     */
    public static int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE() {
        return VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE;
    }
    private static final int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorUpdateTemplateType.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE = 1
     * }
     */
    public static int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE() {
        return VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE;
    }
    private static final int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorUpdateTemplateType.VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM() {
        return VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM;
    }
    private static final int VK_SUBGROUP_FEATURE_BASIC_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_BASIC_BIT = 1
     * }
     */
    public static int VK_SUBGROUP_FEATURE_BASIC_BIT() {
        return VK_SUBGROUP_FEATURE_BASIC_BIT;
    }
    private static final int VK_SUBGROUP_FEATURE_VOTE_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_VOTE_BIT = 2
     * }
     */
    public static int VK_SUBGROUP_FEATURE_VOTE_BIT() {
        return VK_SUBGROUP_FEATURE_VOTE_BIT;
    }
    private static final int VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 4
     * }
     */
    public static int VK_SUBGROUP_FEATURE_ARITHMETIC_BIT() {
        return VK_SUBGROUP_FEATURE_ARITHMETIC_BIT;
    }
    private static final int VK_SUBGROUP_FEATURE_BALLOT_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_BALLOT_BIT = 8
     * }
     */
    public static int VK_SUBGROUP_FEATURE_BALLOT_BIT() {
        return VK_SUBGROUP_FEATURE_BALLOT_BIT;
    }
    private static final int VK_SUBGROUP_FEATURE_SHUFFLE_BIT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 16
     * }
     */
    public static int VK_SUBGROUP_FEATURE_SHUFFLE_BIT() {
        return VK_SUBGROUP_FEATURE_SHUFFLE_BIT;
    }
    private static final int VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 32
     * }
     */
    public static int VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT() {
        return VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT;
    }
    private static final int VK_SUBGROUP_FEATURE_CLUSTERED_BIT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 64
     * }
     */
    public static int VK_SUBGROUP_FEATURE_CLUSTERED_BIT() {
        return VK_SUBGROUP_FEATURE_CLUSTERED_BIT;
    }
    private static final int VK_SUBGROUP_FEATURE_QUAD_BIT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_QUAD_BIT = 128
     * }
     */
    public static int VK_SUBGROUP_FEATURE_QUAD_BIT() {
        return VK_SUBGROUP_FEATURE_QUAD_BIT;
    }
    private static final int VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = (int)256L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 256
     * }
     */
    public static int VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV() {
        return VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV;
    }
    private static final int VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSubgroupFeatureFlagBits.VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM() {
        return VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkSubgroupFeatureFlags
     * }
     */
    public static final OfInt VkSubgroupFeatureFlags = vulkan_h.C_INT;
    private static final int VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPeerMemoryFeatureFlagBits.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 1
     * }
     */
    public static int VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT() {
        return VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT;
    }
    private static final int VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPeerMemoryFeatureFlagBits.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 2
     * }
     */
    public static int VK_PEER_MEMORY_FEATURE_COPY_DST_BIT() {
        return VK_PEER_MEMORY_FEATURE_COPY_DST_BIT;
    }
    private static final int VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPeerMemoryFeatureFlagBits.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 4
     * }
     */
    public static int VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT() {
        return VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT;
    }
    private static final int VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkPeerMemoryFeatureFlagBits.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 8
     * }
     */
    public static int VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT() {
        return VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT;
    }
    private static final int VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPeerMemoryFeatureFlagBits.VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = 1
     * }
     */
    public static int VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR() {
        return VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR;
    }
    private static final int VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPeerMemoryFeatureFlagBits.VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = 2
     * }
     */
    public static int VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR() {
        return VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR;
    }
    private static final int VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPeerMemoryFeatureFlagBits.VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = 4
     * }
     */
    public static int VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR() {
        return VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR;
    }
    private static final int VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkPeerMemoryFeatureFlagBits.VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = 8
     * }
     */
    public static int VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR() {
        return VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR;
    }
    private static final int VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPeerMemoryFeatureFlagBits.VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM() {
        return VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPeerMemoryFeatureFlags
     * }
     */
    public static final OfInt VkPeerMemoryFeatureFlags = vulkan_h.C_INT;
    private static final int VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryAllocateFlagBits.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 1
     * }
     */
    public static int VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT() {
        return VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT;
    }
    private static final int VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryAllocateFlagBits.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT = 2
     * }
     */
    public static int VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT() {
        return VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT;
    }
    private static final int VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryAllocateFlagBits.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT = 4
     * }
     */
    public static int VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT() {
        return VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT;
    }
    private static final int VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryAllocateFlagBits.VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = 1
     * }
     */
    public static int VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR() {
        return VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR;
    }
    private static final int VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryAllocateFlagBits.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR = 2
     * }
     */
    public static int VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR() {
        return VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR;
    }
    private static final int VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryAllocateFlagBits.VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR = 4
     * }
     */
    public static int VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR() {
        return VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR;
    }
    private static final int VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkMemoryAllocateFlagBits.VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM() {
        return VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkMemoryAllocateFlags
     * }
     */
    public static final OfInt VkMemoryAllocateFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkCommandPoolTrimFlags
     * }
     */
    public static final OfInt VkCommandPoolTrimFlags = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDescriptorUpdateTemplateCreateFlags
     * }
     */
    public static final OfInt VkDescriptorUpdateTemplateCreateFlags = vulkan_h.C_INT;
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 1
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 8
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 16
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 32
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 64
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = (int)512L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 512
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 1024
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 128
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = (int)256L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 256
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 2
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 4
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = 8
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = 16
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = 32
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = 64
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBits.VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkExternalMemoryHandleTypeFlags
     * }
     */
    public static final OfInt VkExternalMemoryHandleTypeFlags = vulkan_h.C_INT;
    private static final int VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBits.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 1
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT() {
        return VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBits.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 2
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT() {
        return VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBits.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 4
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT() {
        return VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
    }
    private static final int VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBits.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = 1
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBits.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = 2
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBits.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = 4
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR() {
        return VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR;
    }
    private static final int VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBits.VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM() {
        return VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkExternalMemoryFeatureFlags
     * }
     */
    public static final OfInt VkExternalMemoryFeatureFlags = vulkan_h.C_INT;
    private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceHandleTypeFlagBits.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 1
     * }
     */
    public static int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT() {
        return VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT;
    }
    private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceHandleTypeFlagBits.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2
     * }
     */
    public static int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT() {
        return VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
    }
    private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceHandleTypeFlagBits.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4
     * }
     */
    public static int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT() {
        return VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
    }
    private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceHandleTypeFlagBits.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 8
     * }
     */
    public static int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT() {
        return VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT;
    }
    private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceHandleTypeFlagBits.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1
     * }
     */
    public static int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR() {
        return VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    }
    private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceHandleTypeFlagBits.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 2
     * }
     */
    public static int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR() {
        return VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    }
    private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceHandleTypeFlagBits.VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 4
     * }
     */
    public static int VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR() {
        return VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    }
    private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceHandleTypeFlagBits.VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 8
     * }
     */
    public static int VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR() {
        return VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    }
    private static final int VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceHandleTypeFlagBits.VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM() {
        return VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkExternalFenceHandleTypeFlags
     * }
     */
    public static final OfInt VkExternalFenceHandleTypeFlags = vulkan_h.C_INT;
    private static final int VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceFeatureFlagBits.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 1
     * }
     */
    public static int VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT() {
        return VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT;
    }
    private static final int VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceFeatureFlagBits.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 2
     * }
     */
    public static int VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT() {
        return VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT;
    }
    private static final int VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceFeatureFlagBits.VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = 1
     * }
     */
    public static int VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR() {
        return VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR;
    }
    private static final int VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceFeatureFlagBits.VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = 2
     * }
     */
    public static int VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR() {
        return VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR;
    }
    private static final int VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkExternalFenceFeatureFlagBits.VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM() {
        return VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkExternalFenceFeatureFlags
     * }
     */
    public static final OfInt VkExternalFenceFeatureFlags = vulkan_h.C_INT;
    private static final int VK_FENCE_IMPORT_TEMPORARY_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkFenceImportFlagBits.VK_FENCE_IMPORT_TEMPORARY_BIT = 1
     * }
     */
    public static int VK_FENCE_IMPORT_TEMPORARY_BIT() {
        return VK_FENCE_IMPORT_TEMPORARY_BIT;
    }
    private static final int VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkFenceImportFlagBits.VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = 1
     * }
     */
    public static int VK_FENCE_IMPORT_TEMPORARY_BIT_KHR() {
        return VK_FENCE_IMPORT_TEMPORARY_BIT_KHR;
    }
    private static final int VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkFenceImportFlagBits.VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM() {
        return VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkFenceImportFlags
     * }
     */
    public static final OfInt VkFenceImportFlags = vulkan_h.C_INT;
    private static final int VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreImportFlagBits.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 1
     * }
     */
    public static int VK_SEMAPHORE_IMPORT_TEMPORARY_BIT() {
        return VK_SEMAPHORE_IMPORT_TEMPORARY_BIT;
    }
    private static final int VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreImportFlagBits.VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = 1
     * }
     */
    public static int VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR() {
        return VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR;
    }
    private static final int VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreImportFlagBits.VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM() {
        return VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkSemaphoreImportFlags
     * }
     */
    public static final OfInt VkSemaphoreImportFlags = vulkan_h.C_INT;
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 1
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 2
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 4
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 8
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 16
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 2
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 4
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = 8
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 16
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreHandleTypeFlagBits.VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM() {
        return VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkExternalSemaphoreHandleTypeFlags
     * }
     */
    public static final OfInt VkExternalSemaphoreHandleTypeFlags = vulkan_h.C_INT;
    private static final int VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreFeatureFlagBits.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 1
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT() {
        return VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreFeatureFlagBits.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 2
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT() {
        return VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreFeatureFlagBits.VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = 1
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR() {
        return VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreFeatureFlagBits.VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = 2
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR() {
        return VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR;
    }
    private static final int VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkExternalSemaphoreFeatureFlagBits.VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM() {
        return VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkExternalSemaphoreFeatureFlags
     * }
     */
    public static final OfInt VkExternalSemaphoreFeatureFlags = vulkan_h.C_INT;

    private static class vkEnumerateInstanceVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEnumerateInstanceVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceVersion(uint32_t *pApiVersion)
     * }
     */
    public static FunctionDescriptor vkEnumerateInstanceVersion$descriptor() {
        return vkEnumerateInstanceVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceVersion(uint32_t *pApiVersion)
     * }
     */
    public static MethodHandle vkEnumerateInstanceVersion$handle() {
        return vkEnumerateInstanceVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceVersion(uint32_t *pApiVersion)
     * }
     */
    public static MemorySegment vkEnumerateInstanceVersion$address() {
        return vkEnumerateInstanceVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEnumerateInstanceVersion(uint32_t *pApiVersion)
     * }
     */
    public static int vkEnumerateInstanceVersion(MemorySegment pApiVersion) {
        var mh$ = vkEnumerateInstanceVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEnumerateInstanceVersion", pApiVersion);
            }
            return (int)mh$.invokeExact(pApiVersion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBindBufferMemory2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkBindBufferMemory2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos)
     * }
     */
    public static FunctionDescriptor vkBindBufferMemory2$descriptor() {
        return vkBindBufferMemory2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos)
     * }
     */
    public static MethodHandle vkBindBufferMemory2$handle() {
        return vkBindBufferMemory2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos)
     * }
     */
    public static MemorySegment vkBindBufferMemory2$address() {
        return vkBindBufferMemory2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos)
     * }
     */
    public static int vkBindBufferMemory2(MemorySegment device, int bindInfoCount, MemorySegment pBindInfos) {
        var mh$ = vkBindBufferMemory2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBindBufferMemory2", device, bindInfoCount, pBindInfos);
            }
            return (int)mh$.invokeExact(device, bindInfoCount, pBindInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBindImageMemory2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkBindImageMemory2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos)
     * }
     */
    public static FunctionDescriptor vkBindImageMemory2$descriptor() {
        return vkBindImageMemory2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos)
     * }
     */
    public static MethodHandle vkBindImageMemory2$handle() {
        return vkBindImageMemory2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkBindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos)
     * }
     */
    public static MemorySegment vkBindImageMemory2$address() {
        return vkBindImageMemory2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkBindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos)
     * }
     */
    public static int vkBindImageMemory2(MemorySegment device, int bindInfoCount, MemorySegment pBindInfos) {
        var mh$ = vkBindImageMemory2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBindImageMemory2", device, bindInfoCount, pBindInfos);
            }
            return (int)mh$.invokeExact(device, bindInfoCount, pBindInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceGroupPeerMemoryFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceGroupPeerMemoryFeatures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures)
     * }
     */
    public static FunctionDescriptor vkGetDeviceGroupPeerMemoryFeatures$descriptor() {
        return vkGetDeviceGroupPeerMemoryFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures)
     * }
     */
    public static MethodHandle vkGetDeviceGroupPeerMemoryFeatures$handle() {
        return vkGetDeviceGroupPeerMemoryFeatures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures)
     * }
     */
    public static MemorySegment vkGetDeviceGroupPeerMemoryFeatures$address() {
        return vkGetDeviceGroupPeerMemoryFeatures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures)
     * }
     */
    public static void vkGetDeviceGroupPeerMemoryFeatures(MemorySegment device, int heapIndex, int localDeviceIndex, int remoteDeviceIndex, MemorySegment pPeerMemoryFeatures) {
        var mh$ = vkGetDeviceGroupPeerMemoryFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceGroupPeerMemoryFeatures", device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
            }
            mh$.invokeExact(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDeviceMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetDeviceMask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask)
     * }
     */
    public static FunctionDescriptor vkCmdSetDeviceMask$descriptor() {
        return vkCmdSetDeviceMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask)
     * }
     */
    public static MethodHandle vkCmdSetDeviceMask$handle() {
        return vkCmdSetDeviceMask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask)
     * }
     */
    public static MemorySegment vkCmdSetDeviceMask$address() {
        return vkCmdSetDeviceMask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask)
     * }
     */
    public static void vkCmdSetDeviceMask(MemorySegment commandBuffer, int deviceMask) {
        var mh$ = vkCmdSetDeviceMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDeviceMask", commandBuffer, deviceMask);
            }
            mh$.invokeExact(commandBuffer, deviceMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDispatchBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDispatchBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static FunctionDescriptor vkCmdDispatchBase$descriptor() {
        return vkCmdDispatchBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static MethodHandle vkCmdDispatchBase$handle() {
        return vkCmdDispatchBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static MemorySegment vkCmdDispatchBase$address() {
        return vkCmdDispatchBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static void vkCmdDispatchBase(MemorySegment commandBuffer, int baseGroupX, int baseGroupY, int baseGroupZ, int groupCountX, int groupCountY, int groupCountZ) {
        var mh$ = vkCmdDispatchBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDispatchBase", commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
            }
            mh$.invokeExact(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkEnumeratePhysicalDeviceGroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEnumeratePhysicalDeviceGroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties)
     * }
     */
    public static FunctionDescriptor vkEnumeratePhysicalDeviceGroups$descriptor() {
        return vkEnumeratePhysicalDeviceGroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties)
     * }
     */
    public static MethodHandle vkEnumeratePhysicalDeviceGroups$handle() {
        return vkEnumeratePhysicalDeviceGroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties)
     * }
     */
    public static MemorySegment vkEnumeratePhysicalDeviceGroups$address() {
        return vkEnumeratePhysicalDeviceGroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties)
     * }
     */
    public static int vkEnumeratePhysicalDeviceGroups(MemorySegment instance, MemorySegment pPhysicalDeviceGroupCount, MemorySegment pPhysicalDeviceGroupProperties) {
        var mh$ = vkEnumeratePhysicalDeviceGroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEnumeratePhysicalDeviceGroups", instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
            }
            return (int)mh$.invokeExact(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageMemoryRequirements2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetImageMemoryRequirements2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetImageMemoryRequirements2$descriptor() {
        return vkGetImageMemoryRequirements2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetImageMemoryRequirements2$handle() {
        return vkGetImageMemoryRequirements2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetImageMemoryRequirements2$address() {
        return vkGetImageMemoryRequirements2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static void vkGetImageMemoryRequirements2(MemorySegment device, MemorySegment pInfo, MemorySegment pMemoryRequirements) {
        var mh$ = vkGetImageMemoryRequirements2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageMemoryRequirements2", device, pInfo, pMemoryRequirements);
            }
            mh$.invokeExact(device, pInfo, pMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetBufferMemoryRequirements2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetBufferMemoryRequirements2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetBufferMemoryRequirements2$descriptor() {
        return vkGetBufferMemoryRequirements2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetBufferMemoryRequirements2$handle() {
        return vkGetBufferMemoryRequirements2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetBufferMemoryRequirements2$address() {
        return vkGetBufferMemoryRequirements2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static void vkGetBufferMemoryRequirements2(MemorySegment device, MemorySegment pInfo, MemorySegment pMemoryRequirements) {
        var mh$ = vkGetBufferMemoryRequirements2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetBufferMemoryRequirements2", device, pInfo, pMemoryRequirements);
            }
            mh$.invokeExact(device, pInfo, pMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageSparseMemoryRequirements2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetImageSparseMemoryRequirements2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetImageSparseMemoryRequirements2$descriptor() {
        return vkGetImageSparseMemoryRequirements2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetImageSparseMemoryRequirements2$handle() {
        return vkGetImageSparseMemoryRequirements2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetImageSparseMemoryRequirements2$address() {
        return vkGetImageSparseMemoryRequirements2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements)
     * }
     */
    public static void vkGetImageSparseMemoryRequirements2(MemorySegment device, MemorySegment pInfo, MemorySegment pSparseMemoryRequirementCount, MemorySegment pSparseMemoryRequirements) {
        var mh$ = vkGetImageSparseMemoryRequirements2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageSparseMemoryRequirements2", device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
            }
            mh$.invokeExact(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceFeatures2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceFeatures2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceFeatures2$descriptor() {
        return vkGetPhysicalDeviceFeatures2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceFeatures2$handle() {
        return vkGetPhysicalDeviceFeatures2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceFeatures2$address() {
        return vkGetPhysicalDeviceFeatures2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures)
     * }
     */
    public static void vkGetPhysicalDeviceFeatures2(MemorySegment physicalDevice, MemorySegment pFeatures) {
        var mh$ = vkGetPhysicalDeviceFeatures2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceFeatures2", physicalDevice, pFeatures);
            }
            mh$.invokeExact(physicalDevice, pFeatures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceProperties2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceProperties2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceProperties2$descriptor() {
        return vkGetPhysicalDeviceProperties2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceProperties2$handle() {
        return vkGetPhysicalDeviceProperties2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceProperties2$address() {
        return vkGetPhysicalDeviceProperties2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties)
     * }
     */
    public static void vkGetPhysicalDeviceProperties2(MemorySegment physicalDevice, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceProperties2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceProperties2", physicalDevice, pProperties);
            }
            mh$.invokeExact(physicalDevice, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceFormatProperties2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceFormatProperties2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceFormatProperties2$descriptor() {
        return vkGetPhysicalDeviceFormatProperties2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceFormatProperties2$handle() {
        return vkGetPhysicalDeviceFormatProperties2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceFormatProperties2$address() {
        return vkGetPhysicalDeviceFormatProperties2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties)
     * }
     */
    public static void vkGetPhysicalDeviceFormatProperties2(MemorySegment physicalDevice, int format, MemorySegment pFormatProperties) {
        var mh$ = vkGetPhysicalDeviceFormatProperties2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceFormatProperties2", physicalDevice, format, pFormatProperties);
            }
            mh$.invokeExact(physicalDevice, format, pFormatProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceImageFormatProperties2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceImageFormatProperties2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceImageFormatProperties2$descriptor() {
        return vkGetPhysicalDeviceImageFormatProperties2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceImageFormatProperties2$handle() {
        return vkGetPhysicalDeviceImageFormatProperties2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceImageFormatProperties2$address() {
        return vkGetPhysicalDeviceImageFormatProperties2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties)
     * }
     */
    public static int vkGetPhysicalDeviceImageFormatProperties2(MemorySegment physicalDevice, MemorySegment pImageFormatInfo, MemorySegment pImageFormatProperties) {
        var mh$ = vkGetPhysicalDeviceImageFormatProperties2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceImageFormatProperties2", physicalDevice, pImageFormatInfo, pImageFormatProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pImageFormatInfo, pImageFormatProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceQueueFamilyProperties2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceQueueFamilyProperties2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceQueueFamilyProperties2$descriptor() {
        return vkGetPhysicalDeviceQueueFamilyProperties2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceQueueFamilyProperties2$handle() {
        return vkGetPhysicalDeviceQueueFamilyProperties2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceQueueFamilyProperties2$address() {
        return vkGetPhysicalDeviceQueueFamilyProperties2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties)
     * }
     */
    public static void vkGetPhysicalDeviceQueueFamilyProperties2(MemorySegment physicalDevice, MemorySegment pQueueFamilyPropertyCount, MemorySegment pQueueFamilyProperties) {
        var mh$ = vkGetPhysicalDeviceQueueFamilyProperties2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceQueueFamilyProperties2", physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
            }
            mh$.invokeExact(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceMemoryProperties2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceMemoryProperties2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceMemoryProperties2$descriptor() {
        return vkGetPhysicalDeviceMemoryProperties2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceMemoryProperties2$handle() {
        return vkGetPhysicalDeviceMemoryProperties2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceMemoryProperties2$address() {
        return vkGetPhysicalDeviceMemoryProperties2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties)
     * }
     */
    public static void vkGetPhysicalDeviceMemoryProperties2(MemorySegment physicalDevice, MemorySegment pMemoryProperties) {
        var mh$ = vkGetPhysicalDeviceMemoryProperties2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceMemoryProperties2", physicalDevice, pMemoryProperties);
            }
            mh$.invokeExact(physicalDevice, pMemoryProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceSparseImageFormatProperties2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSparseImageFormatProperties2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSparseImageFormatProperties2$descriptor() {
        return vkGetPhysicalDeviceSparseImageFormatProperties2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSparseImageFormatProperties2$handle() {
        return vkGetPhysicalDeviceSparseImageFormatProperties2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSparseImageFormatProperties2$address() {
        return vkGetPhysicalDeviceSparseImageFormatProperties2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties)
     * }
     */
    public static void vkGetPhysicalDeviceSparseImageFormatProperties2(MemorySegment physicalDevice, MemorySegment pFormatInfo, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceSparseImageFormatProperties2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSparseImageFormatProperties2", physicalDevice, pFormatInfo, pPropertyCount, pProperties);
            }
            mh$.invokeExact(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkTrimCommandPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkTrimCommandPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkTrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
     * }
     */
    public static FunctionDescriptor vkTrimCommandPool$descriptor() {
        return vkTrimCommandPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkTrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
     * }
     */
    public static MethodHandle vkTrimCommandPool$handle() {
        return vkTrimCommandPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkTrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
     * }
     */
    public static MemorySegment vkTrimCommandPool$address() {
        return vkTrimCommandPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkTrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
     * }
     */
    public static void vkTrimCommandPool(MemorySegment device, MemorySegment commandPool, int flags) {
        var mh$ = vkTrimCommandPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkTrimCommandPool", device, commandPool, flags);
            }
            mh$.invokeExact(device, commandPool, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceQueue2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceQueue2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue)
     * }
     */
    public static FunctionDescriptor vkGetDeviceQueue2$descriptor() {
        return vkGetDeviceQueue2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue)
     * }
     */
    public static MethodHandle vkGetDeviceQueue2$handle() {
        return vkGetDeviceQueue2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue)
     * }
     */
    public static MemorySegment vkGetDeviceQueue2$address() {
        return vkGetDeviceQueue2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue)
     * }
     */
    public static void vkGetDeviceQueue2(MemorySegment device, MemorySegment pQueueInfo, MemorySegment pQueue) {
        var mh$ = vkGetDeviceQueue2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceQueue2", device, pQueueInfo, pQueue);
            }
            mh$.invokeExact(device, pQueueInfo, pQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateSamplerYcbcrConversion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateSamplerYcbcrConversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion)
     * }
     */
    public static FunctionDescriptor vkCreateSamplerYcbcrConversion$descriptor() {
        return vkCreateSamplerYcbcrConversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion)
     * }
     */
    public static MethodHandle vkCreateSamplerYcbcrConversion$handle() {
        return vkCreateSamplerYcbcrConversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion)
     * }
     */
    public static MemorySegment vkCreateSamplerYcbcrConversion$address() {
        return vkCreateSamplerYcbcrConversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion)
     * }
     */
    public static int vkCreateSamplerYcbcrConversion(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pYcbcrConversion) {
        var mh$ = vkCreateSamplerYcbcrConversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateSamplerYcbcrConversion", device, pCreateInfo, pAllocator, pYcbcrConversion);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pYcbcrConversion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroySamplerYcbcrConversion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroySamplerYcbcrConversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroySamplerYcbcrConversion$descriptor() {
        return vkDestroySamplerYcbcrConversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroySamplerYcbcrConversion$handle() {
        return vkDestroySamplerYcbcrConversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroySamplerYcbcrConversion$address() {
        return vkDestroySamplerYcbcrConversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroySamplerYcbcrConversion(MemorySegment device, MemorySegment ycbcrConversion, MemorySegment pAllocator) {
        var mh$ = vkDestroySamplerYcbcrConversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroySamplerYcbcrConversion", device, ycbcrConversion, pAllocator);
            }
            mh$.invokeExact(device, ycbcrConversion, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateDescriptorUpdateTemplate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateDescriptorUpdateTemplate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate)
     * }
     */
    public static FunctionDescriptor vkCreateDescriptorUpdateTemplate$descriptor() {
        return vkCreateDescriptorUpdateTemplate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate)
     * }
     */
    public static MethodHandle vkCreateDescriptorUpdateTemplate$handle() {
        return vkCreateDescriptorUpdateTemplate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate)
     * }
     */
    public static MemorySegment vkCreateDescriptorUpdateTemplate$address() {
        return vkCreateDescriptorUpdateTemplate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate)
     * }
     */
    public static int vkCreateDescriptorUpdateTemplate(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pDescriptorUpdateTemplate) {
        var mh$ = vkCreateDescriptorUpdateTemplate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateDescriptorUpdateTemplate", device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyDescriptorUpdateTemplate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyDescriptorUpdateTemplate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyDescriptorUpdateTemplate$descriptor() {
        return vkDestroyDescriptorUpdateTemplate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyDescriptorUpdateTemplate$handle() {
        return vkDestroyDescriptorUpdateTemplate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyDescriptorUpdateTemplate$address() {
        return vkDestroyDescriptorUpdateTemplate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyDescriptorUpdateTemplate(MemorySegment device, MemorySegment descriptorUpdateTemplate, MemorySegment pAllocator) {
        var mh$ = vkDestroyDescriptorUpdateTemplate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyDescriptorUpdateTemplate", device, descriptorUpdateTemplate, pAllocator);
            }
            mh$.invokeExact(device, descriptorUpdateTemplate, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkUpdateDescriptorSetWithTemplate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkUpdateDescriptorSetWithTemplate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData)
     * }
     */
    public static FunctionDescriptor vkUpdateDescriptorSetWithTemplate$descriptor() {
        return vkUpdateDescriptorSetWithTemplate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData)
     * }
     */
    public static MethodHandle vkUpdateDescriptorSetWithTemplate$handle() {
        return vkUpdateDescriptorSetWithTemplate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData)
     * }
     */
    public static MemorySegment vkUpdateDescriptorSetWithTemplate$address() {
        return vkUpdateDescriptorSetWithTemplate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkUpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData)
     * }
     */
    public static void vkUpdateDescriptorSetWithTemplate(MemorySegment device, MemorySegment descriptorSet, MemorySegment descriptorUpdateTemplate, MemorySegment pData) {
        var mh$ = vkUpdateDescriptorSetWithTemplate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkUpdateDescriptorSetWithTemplate", device, descriptorSet, descriptorUpdateTemplate, pData);
            }
            mh$.invokeExact(device, descriptorSet, descriptorUpdateTemplate, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceExternalBufferProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceExternalBufferProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceExternalBufferProperties$descriptor() {
        return vkGetPhysicalDeviceExternalBufferProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceExternalBufferProperties$handle() {
        return vkGetPhysicalDeviceExternalBufferProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceExternalBufferProperties$address() {
        return vkGetPhysicalDeviceExternalBufferProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties)
     * }
     */
    public static void vkGetPhysicalDeviceExternalBufferProperties(MemorySegment physicalDevice, MemorySegment pExternalBufferInfo, MemorySegment pExternalBufferProperties) {
        var mh$ = vkGetPhysicalDeviceExternalBufferProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceExternalBufferProperties", physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
            }
            mh$.invokeExact(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceExternalFenceProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceExternalFenceProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceExternalFenceProperties$descriptor() {
        return vkGetPhysicalDeviceExternalFenceProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceExternalFenceProperties$handle() {
        return vkGetPhysicalDeviceExternalFenceProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceExternalFenceProperties$address() {
        return vkGetPhysicalDeviceExternalFenceProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties)
     * }
     */
    public static void vkGetPhysicalDeviceExternalFenceProperties(MemorySegment physicalDevice, MemorySegment pExternalFenceInfo, MemorySegment pExternalFenceProperties) {
        var mh$ = vkGetPhysicalDeviceExternalFenceProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceExternalFenceProperties", physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
            }
            mh$.invokeExact(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceExternalSemaphoreProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceExternalSemaphoreProperties");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceExternalSemaphoreProperties$descriptor() {
        return vkGetPhysicalDeviceExternalSemaphoreProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceExternalSemaphoreProperties$handle() {
        return vkGetPhysicalDeviceExternalSemaphoreProperties.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceExternalSemaphoreProperties$address() {
        return vkGetPhysicalDeviceExternalSemaphoreProperties.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties)
     * }
     */
    public static void vkGetPhysicalDeviceExternalSemaphoreProperties(MemorySegment physicalDevice, MemorySegment pExternalSemaphoreInfo, MemorySegment pExternalSemaphoreProperties) {
        var mh$ = vkGetPhysicalDeviceExternalSemaphoreProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceExternalSemaphoreProperties", physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
            }
            mh$.invokeExact(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDescriptorSetLayoutSupport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDescriptorSetLayoutSupport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport)
     * }
     */
    public static FunctionDescriptor vkGetDescriptorSetLayoutSupport$descriptor() {
        return vkGetDescriptorSetLayoutSupport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport)
     * }
     */
    public static MethodHandle vkGetDescriptorSetLayoutSupport$handle() {
        return vkGetDescriptorSetLayoutSupport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport)
     * }
     */
    public static MemorySegment vkGetDescriptorSetLayoutSupport$address() {
        return vkGetDescriptorSetLayoutSupport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport)
     * }
     */
    public static void vkGetDescriptorSetLayoutSupport(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pSupport) {
        var mh$ = vkGetDescriptorSetLayoutSupport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDescriptorSetLayoutSupport", device, pCreateInfo, pSupport);
            }
            mh$.invokeExact(device, pCreateInfo, pSupport);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint64_t VkDeviceAddress
     * }
     */
    public static final OfLong VkDeviceAddress = vulkan_h.C_LONG;
    private static final int VK_DRIVER_ID_AMD_PROPRIETARY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_AMD_PROPRIETARY = 1
     * }
     */
    public static int VK_DRIVER_ID_AMD_PROPRIETARY() {
        return VK_DRIVER_ID_AMD_PROPRIETARY;
    }
    private static final int VK_DRIVER_ID_AMD_OPEN_SOURCE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_AMD_OPEN_SOURCE = 2
     * }
     */
    public static int VK_DRIVER_ID_AMD_OPEN_SOURCE() {
        return VK_DRIVER_ID_AMD_OPEN_SOURCE;
    }
    private static final int VK_DRIVER_ID_MESA_RADV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_MESA_RADV = 3
     * }
     */
    public static int VK_DRIVER_ID_MESA_RADV() {
        return VK_DRIVER_ID_MESA_RADV;
    }
    private static final int VK_DRIVER_ID_NVIDIA_PROPRIETARY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4
     * }
     */
    public static int VK_DRIVER_ID_NVIDIA_PROPRIETARY() {
        return VK_DRIVER_ID_NVIDIA_PROPRIETARY;
    }
    private static final int VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5
     * }
     */
    public static int VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS() {
        return VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS;
    }
    private static final int VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6
     * }
     */
    public static int VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA() {
        return VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA;
    }
    private static final int VK_DRIVER_ID_IMAGINATION_PROPRIETARY = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7
     * }
     */
    public static int VK_DRIVER_ID_IMAGINATION_PROPRIETARY() {
        return VK_DRIVER_ID_IMAGINATION_PROPRIETARY;
    }
    private static final int VK_DRIVER_ID_QUALCOMM_PROPRIETARY = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8
     * }
     */
    public static int VK_DRIVER_ID_QUALCOMM_PROPRIETARY() {
        return VK_DRIVER_ID_QUALCOMM_PROPRIETARY;
    }
    private static final int VK_DRIVER_ID_ARM_PROPRIETARY = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_ARM_PROPRIETARY = 9
     * }
     */
    public static int VK_DRIVER_ID_ARM_PROPRIETARY() {
        return VK_DRIVER_ID_ARM_PROPRIETARY;
    }
    private static final int VK_DRIVER_ID_GOOGLE_SWIFTSHADER = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10
     * }
     */
    public static int VK_DRIVER_ID_GOOGLE_SWIFTSHADER() {
        return VK_DRIVER_ID_GOOGLE_SWIFTSHADER;
    }
    private static final int VK_DRIVER_ID_GGP_PROPRIETARY = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_GGP_PROPRIETARY = 11
     * }
     */
    public static int VK_DRIVER_ID_GGP_PROPRIETARY() {
        return VK_DRIVER_ID_GGP_PROPRIETARY;
    }
    private static final int VK_DRIVER_ID_BROADCOM_PROPRIETARY = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12
     * }
     */
    public static int VK_DRIVER_ID_BROADCOM_PROPRIETARY() {
        return VK_DRIVER_ID_BROADCOM_PROPRIETARY;
    }
    private static final int VK_DRIVER_ID_AMD_PROPRIETARY_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_AMD_PROPRIETARY_KHR = 1
     * }
     */
    public static int VK_DRIVER_ID_AMD_PROPRIETARY_KHR() {
        return VK_DRIVER_ID_AMD_PROPRIETARY_KHR;
    }
    private static final int VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = 2
     * }
     */
    public static int VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR() {
        return VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR;
    }
    private static final int VK_DRIVER_ID_MESA_RADV_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_MESA_RADV_KHR = 3
     * }
     */
    public static int VK_DRIVER_ID_MESA_RADV_KHR() {
        return VK_DRIVER_ID_MESA_RADV_KHR;
    }
    private static final int VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = 4
     * }
     */
    public static int VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR() {
        return VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR;
    }
    private static final int VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = 5
     * }
     */
    public static int VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR() {
        return VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR;
    }
    private static final int VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = 6
     * }
     */
    public static int VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR() {
        return VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR;
    }
    private static final int VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = 7
     * }
     */
    public static int VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR() {
        return VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR;
    }
    private static final int VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = 8
     * }
     */
    public static int VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR() {
        return VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR;
    }
    private static final int VK_DRIVER_ID_ARM_PROPRIETARY_KHR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_ARM_PROPRIETARY_KHR = 9
     * }
     */
    public static int VK_DRIVER_ID_ARM_PROPRIETARY_KHR() {
        return VK_DRIVER_ID_ARM_PROPRIETARY_KHR;
    }
    private static final int VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = 10
     * }
     */
    public static int VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR() {
        return VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR;
    }
    private static final int VK_DRIVER_ID_GGP_PROPRIETARY_KHR = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_GGP_PROPRIETARY_KHR = 11
     * }
     */
    public static int VK_DRIVER_ID_GGP_PROPRIETARY_KHR() {
        return VK_DRIVER_ID_GGP_PROPRIETARY_KHR;
    }
    private static final int VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR = 12
     * }
     */
    public static int VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR() {
        return VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR;
    }
    private static final int VK_DRIVER_ID_BEGIN_RANGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_BEGIN_RANGE = 1
     * }
     */
    public static int VK_DRIVER_ID_BEGIN_RANGE() {
        return VK_DRIVER_ID_BEGIN_RANGE;
    }
    private static final int VK_DRIVER_ID_END_RANGE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_END_RANGE = 12
     * }
     */
    public static int VK_DRIVER_ID_END_RANGE() {
        return VK_DRIVER_ID_END_RANGE;
    }
    private static final int VK_DRIVER_ID_RANGE_SIZE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_RANGE_SIZE = 12
     * }
     */
    public static int VK_DRIVER_ID_RANGE_SIZE() {
        return VK_DRIVER_ID_RANGE_SIZE;
    }
    private static final int VK_DRIVER_ID_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDriverId.VK_DRIVER_ID_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_DRIVER_ID_MAX_ENUM() {
        return VK_DRIVER_ID_MAX_ENUM;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY = 0
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL = 1
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE = 2
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR = 0
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR = 1
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR = 2
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_BEGIN_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_BEGIN_RANGE = 0
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_BEGIN_RANGE() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_BEGIN_RANGE;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_END_RANGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_END_RANGE = 2
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_END_RANGE() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_END_RANGE;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_RANGE_SIZE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_RANGE_SIZE = 3
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_RANGE_SIZE() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_RANGE_SIZE;
    }
    private static final int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkShaderFloatControlsIndependence.VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM() {
        return VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE = 0
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE() {
        return VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_MIN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_MIN = 1
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_MIN() {
        return VK_SAMPLER_REDUCTION_MODE_MIN;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_MAX = 2
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_MAX() {
        return VK_SAMPLER_REDUCTION_MODE_MAX;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = 0
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT() {
        return VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_MIN_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_MIN_EXT = 1
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_MIN_EXT() {
        return VK_SAMPLER_REDUCTION_MODE_MIN_EXT;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_MAX_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_MAX_EXT = 2
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_MAX_EXT() {
        return VK_SAMPLER_REDUCTION_MODE_MAX_EXT;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE = 0
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE() {
        return VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_END_RANGE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_END_RANGE = 2
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_END_RANGE() {
        return VK_SAMPLER_REDUCTION_MODE_END_RANGE;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE = 3
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE() {
        return VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE;
    }
    private static final int VK_SAMPLER_REDUCTION_MODE_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSamplerReductionMode.VK_SAMPLER_REDUCTION_MODE_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SAMPLER_REDUCTION_MODE_MAX_ENUM() {
        return VK_SAMPLER_REDUCTION_MODE_MAX_ENUM;
    }
    private static final int VK_SEMAPHORE_TYPE_BINARY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreType.VK_SEMAPHORE_TYPE_BINARY = 0
     * }
     */
    public static int VK_SEMAPHORE_TYPE_BINARY() {
        return VK_SEMAPHORE_TYPE_BINARY;
    }
    private static final int VK_SEMAPHORE_TYPE_TIMELINE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreType.VK_SEMAPHORE_TYPE_TIMELINE = 1
     * }
     */
    public static int VK_SEMAPHORE_TYPE_TIMELINE() {
        return VK_SEMAPHORE_TYPE_TIMELINE;
    }
    private static final int VK_SEMAPHORE_TYPE_BINARY_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreType.VK_SEMAPHORE_TYPE_BINARY_KHR = 0
     * }
     */
    public static int VK_SEMAPHORE_TYPE_BINARY_KHR() {
        return VK_SEMAPHORE_TYPE_BINARY_KHR;
    }
    private static final int VK_SEMAPHORE_TYPE_TIMELINE_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreType.VK_SEMAPHORE_TYPE_TIMELINE_KHR = 1
     * }
     */
    public static int VK_SEMAPHORE_TYPE_TIMELINE_KHR() {
        return VK_SEMAPHORE_TYPE_TIMELINE_KHR;
    }
    private static final int VK_SEMAPHORE_TYPE_BEGIN_RANGE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreType.VK_SEMAPHORE_TYPE_BEGIN_RANGE = 0
     * }
     */
    public static int VK_SEMAPHORE_TYPE_BEGIN_RANGE() {
        return VK_SEMAPHORE_TYPE_BEGIN_RANGE;
    }
    private static final int VK_SEMAPHORE_TYPE_END_RANGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreType.VK_SEMAPHORE_TYPE_END_RANGE = 1
     * }
     */
    public static int VK_SEMAPHORE_TYPE_END_RANGE() {
        return VK_SEMAPHORE_TYPE_END_RANGE;
    }
    private static final int VK_SEMAPHORE_TYPE_RANGE_SIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreType.VK_SEMAPHORE_TYPE_RANGE_SIZE = 2
     * }
     */
    public static int VK_SEMAPHORE_TYPE_RANGE_SIZE() {
        return VK_SEMAPHORE_TYPE_RANGE_SIZE;
    }
    private static final int VK_SEMAPHORE_TYPE_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreType.VK_SEMAPHORE_TYPE_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SEMAPHORE_TYPE_MAX_ENUM() {
        return VK_SEMAPHORE_TYPE_MAX_ENUM;
    }
    private static final int VK_RESOLVE_MODE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_NONE = 0
     * }
     */
    public static int VK_RESOLVE_MODE_NONE() {
        return VK_RESOLVE_MODE_NONE;
    }
    private static final int VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT = 1
     * }
     */
    public static int VK_RESOLVE_MODE_SAMPLE_ZERO_BIT() {
        return VK_RESOLVE_MODE_SAMPLE_ZERO_BIT;
    }
    private static final int VK_RESOLVE_MODE_AVERAGE_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_AVERAGE_BIT = 2
     * }
     */
    public static int VK_RESOLVE_MODE_AVERAGE_BIT() {
        return VK_RESOLVE_MODE_AVERAGE_BIT;
    }
    private static final int VK_RESOLVE_MODE_MIN_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_MIN_BIT = 4
     * }
     */
    public static int VK_RESOLVE_MODE_MIN_BIT() {
        return VK_RESOLVE_MODE_MIN_BIT;
    }
    private static final int VK_RESOLVE_MODE_MAX_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_MAX_BIT = 8
     * }
     */
    public static int VK_RESOLVE_MODE_MAX_BIT() {
        return VK_RESOLVE_MODE_MAX_BIT;
    }
    private static final int VK_RESOLVE_MODE_NONE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_NONE_KHR = 0
     * }
     */
    public static int VK_RESOLVE_MODE_NONE_KHR() {
        return VK_RESOLVE_MODE_NONE_KHR;
    }
    private static final int VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR = 1
     * }
     */
    public static int VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR() {
        return VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR;
    }
    private static final int VK_RESOLVE_MODE_AVERAGE_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_AVERAGE_BIT_KHR = 2
     * }
     */
    public static int VK_RESOLVE_MODE_AVERAGE_BIT_KHR() {
        return VK_RESOLVE_MODE_AVERAGE_BIT_KHR;
    }
    private static final int VK_RESOLVE_MODE_MIN_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_MIN_BIT_KHR = 4
     * }
     */
    public static int VK_RESOLVE_MODE_MIN_BIT_KHR() {
        return VK_RESOLVE_MODE_MIN_BIT_KHR;
    }
    private static final int VK_RESOLVE_MODE_MAX_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_MAX_BIT_KHR = 8
     * }
     */
    public static int VK_RESOLVE_MODE_MAX_BIT_KHR() {
        return VK_RESOLVE_MODE_MAX_BIT_KHR;
    }
    private static final int VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkResolveModeFlagBits.VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM() {
        return VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkResolveModeFlags
     * }
     */
    public static final OfInt VkResolveModeFlags = vulkan_h.C_INT;
    private static final int VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorBindingFlagBits.VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT = 1
     * }
     */
    public static int VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT() {
        return VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT;
    }
    private static final int VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorBindingFlagBits.VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT = 2
     * }
     */
    public static int VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT() {
        return VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT;
    }
    private static final int VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorBindingFlagBits.VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT = 4
     * }
     */
    public static int VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT() {
        return VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT;
    }
    private static final int VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorBindingFlagBits.VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT = 8
     * }
     */
    public static int VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT() {
        return VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT;
    }
    private static final int VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorBindingFlagBits.VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = 1
     * }
     */
    public static int VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT() {
        return VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT;
    }
    private static final int VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorBindingFlagBits.VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = 2
     * }
     */
    public static int VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT() {
        return VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT;
    }
    private static final int VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorBindingFlagBits.VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = 4
     * }
     */
    public static int VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT() {
        return VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT;
    }
    private static final int VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorBindingFlagBits.VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = 8
     * }
     */
    public static int VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT() {
        return VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT;
    }
    private static final int VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDescriptorBindingFlagBits.VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM() {
        return VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDescriptorBindingFlags
     * }
     */
    public static final OfInt VkDescriptorBindingFlags = vulkan_h.C_INT;
    private static final int VK_SEMAPHORE_WAIT_ANY_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreWaitFlagBits.VK_SEMAPHORE_WAIT_ANY_BIT = 1
     * }
     */
    public static int VK_SEMAPHORE_WAIT_ANY_BIT() {
        return VK_SEMAPHORE_WAIT_ANY_BIT;
    }
    private static final int VK_SEMAPHORE_WAIT_ANY_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreWaitFlagBits.VK_SEMAPHORE_WAIT_ANY_BIT_KHR = 1
     * }
     */
    public static int VK_SEMAPHORE_WAIT_ANY_BIT_KHR() {
        return VK_SEMAPHORE_WAIT_ANY_BIT_KHR;
    }
    private static final int VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSemaphoreWaitFlagBits.VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM = 2147483647
     * }
     */
    public static int VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM() {
        return VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkSemaphoreWaitFlags
     * }
     */
    public static final OfInt VkSemaphoreWaitFlags = vulkan_h.C_INT;

    private static class vkCmdDrawIndirectCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndirectCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndirectCount$descriptor() {
        return vkCmdDrawIndirectCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawIndirectCount$handle() {
        return vkCmdDrawIndirectCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawIndirectCount$address() {
        return vkCmdDrawIndirectCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawIndirectCount(MemorySegment commandBuffer, MemorySegment buffer, long offset, MemorySegment countBuffer, long countBufferOffset, int maxDrawCount, int stride) {
        var mh$ = vkCmdDrawIndirectCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndirectCount", commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawIndexedIndirectCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndexedIndirectCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndexedIndirectCount$descriptor() {
        return vkCmdDrawIndexedIndirectCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawIndexedIndirectCount$handle() {
        return vkCmdDrawIndexedIndirectCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawIndexedIndirectCount$address() {
        return vkCmdDrawIndexedIndirectCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawIndexedIndirectCount(MemorySegment commandBuffer, MemorySegment buffer, long offset, MemorySegment countBuffer, long countBufferOffset, int maxDrawCount, int stride) {
        var mh$ = vkCmdDrawIndexedIndirectCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndexedIndirectCount", commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateRenderPass2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateRenderPass2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static FunctionDescriptor vkCreateRenderPass2$descriptor() {
        return vkCreateRenderPass2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static MethodHandle vkCreateRenderPass2$handle() {
        return vkCreateRenderPass2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static MemorySegment vkCreateRenderPass2$address() {
        return vkCreateRenderPass2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static int vkCreateRenderPass2(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pRenderPass) {
        var mh$ = vkCreateRenderPass2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateRenderPass2", device, pCreateInfo, pAllocator, pRenderPass);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pRenderPass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBeginRenderPass2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBeginRenderPass2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo)
     * }
     */
    public static FunctionDescriptor vkCmdBeginRenderPass2$descriptor() {
        return vkCmdBeginRenderPass2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo)
     * }
     */
    public static MethodHandle vkCmdBeginRenderPass2$handle() {
        return vkCmdBeginRenderPass2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo)
     * }
     */
    public static MemorySegment vkCmdBeginRenderPass2$address() {
        return vkCmdBeginRenderPass2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo)
     * }
     */
    public static void vkCmdBeginRenderPass2(MemorySegment commandBuffer, MemorySegment pRenderPassBegin, MemorySegment pSubpassBeginInfo) {
        var mh$ = vkCmdBeginRenderPass2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBeginRenderPass2", commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
            }
            mh$.invokeExact(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdNextSubpass2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdNextSubpass2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static FunctionDescriptor vkCmdNextSubpass2$descriptor() {
        return vkCmdNextSubpass2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static MethodHandle vkCmdNextSubpass2$handle() {
        return vkCmdNextSubpass2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static MemorySegment vkCmdNextSubpass2$address() {
        return vkCmdNextSubpass2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static void vkCmdNextSubpass2(MemorySegment commandBuffer, MemorySegment pSubpassBeginInfo, MemorySegment pSubpassEndInfo) {
        var mh$ = vkCmdNextSubpass2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdNextSubpass2", commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
            }
            mh$.invokeExact(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdEndRenderPass2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdEndRenderPass2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static FunctionDescriptor vkCmdEndRenderPass2$descriptor() {
        return vkCmdEndRenderPass2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static MethodHandle vkCmdEndRenderPass2$handle() {
        return vkCmdEndRenderPass2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static MemorySegment vkCmdEndRenderPass2$address() {
        return vkCmdEndRenderPass2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static void vkCmdEndRenderPass2(MemorySegment commandBuffer, MemorySegment pSubpassEndInfo) {
        var mh$ = vkCmdEndRenderPass2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdEndRenderPass2", commandBuffer, pSubpassEndInfo);
            }
            mh$.invokeExact(commandBuffer, pSubpassEndInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkResetQueryPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkResetQueryPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static FunctionDescriptor vkResetQueryPool$descriptor() {
        return vkResetQueryPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static MethodHandle vkResetQueryPool$handle() {
        return vkResetQueryPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static MemorySegment vkResetQueryPool$address() {
        return vkResetQueryPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
     * }
     */
    public static void vkResetQueryPool(MemorySegment device, MemorySegment queryPool, int firstQuery, int queryCount) {
        var mh$ = vkResetQueryPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkResetQueryPool", device, queryPool, firstQuery, queryCount);
            }
            mh$.invokeExact(device, queryPool, firstQuery, queryCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetSemaphoreCounterValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetSemaphoreCounterValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue)
     * }
     */
    public static FunctionDescriptor vkGetSemaphoreCounterValue$descriptor() {
        return vkGetSemaphoreCounterValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue)
     * }
     */
    public static MethodHandle vkGetSemaphoreCounterValue$handle() {
        return vkGetSemaphoreCounterValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue)
     * }
     */
    public static MemorySegment vkGetSemaphoreCounterValue$address() {
        return vkGetSemaphoreCounterValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue)
     * }
     */
    public static int vkGetSemaphoreCounterValue(MemorySegment device, MemorySegment semaphore, MemorySegment pValue) {
        var mh$ = vkGetSemaphoreCounterValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetSemaphoreCounterValue", device, semaphore, pValue);
            }
            return (int)mh$.invokeExact(device, semaphore, pValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkWaitSemaphores {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkWaitSemaphores");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout)
     * }
     */
    public static FunctionDescriptor vkWaitSemaphores$descriptor() {
        return vkWaitSemaphores.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout)
     * }
     */
    public static MethodHandle vkWaitSemaphores$handle() {
        return vkWaitSemaphores.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout)
     * }
     */
    public static MemorySegment vkWaitSemaphores$address() {
        return vkWaitSemaphores.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkWaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout)
     * }
     */
    public static int vkWaitSemaphores(MemorySegment device, MemorySegment pWaitInfo, long timeout) {
        var mh$ = vkWaitSemaphores.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkWaitSemaphores", device, pWaitInfo, timeout);
            }
            return (int)mh$.invokeExact(device, pWaitInfo, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkSignalSemaphore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkSignalSemaphore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo)
     * }
     */
    public static FunctionDescriptor vkSignalSemaphore$descriptor() {
        return vkSignalSemaphore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo)
     * }
     */
    public static MethodHandle vkSignalSemaphore$handle() {
        return vkSignalSemaphore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo)
     * }
     */
    public static MemorySegment vkSignalSemaphore$address() {
        return vkSignalSemaphore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkSignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo)
     * }
     */
    public static int vkSignalSemaphore(MemorySegment device, MemorySegment pSignalInfo) {
        var mh$ = vkSignalSemaphore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkSignalSemaphore", device, pSignalInfo);
            }
            return (int)mh$.invokeExact(device, pSignalInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetBufferDeviceAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetBufferDeviceAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetBufferDeviceAddress$descriptor() {
        return vkGetBufferDeviceAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MethodHandle vkGetBufferDeviceAddress$handle() {
        return vkGetBufferDeviceAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MemorySegment vkGetBufferDeviceAddress$address() {
        return vkGetBufferDeviceAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static long vkGetBufferDeviceAddress(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetBufferDeviceAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetBufferDeviceAddress", device, pInfo);
            }
            return (long)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetBufferOpaqueCaptureAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetBufferOpaqueCaptureAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t vkGetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetBufferOpaqueCaptureAddress$descriptor() {
        return vkGetBufferOpaqueCaptureAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t vkGetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MethodHandle vkGetBufferOpaqueCaptureAddress$handle() {
        return vkGetBufferOpaqueCaptureAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t vkGetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MemorySegment vkGetBufferOpaqueCaptureAddress$address() {
        return vkGetBufferOpaqueCaptureAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t vkGetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static long vkGetBufferOpaqueCaptureAddress(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetBufferOpaqueCaptureAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetBufferOpaqueCaptureAddress", device, pInfo);
            }
            return (long)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceMemoryOpaqueCaptureAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceMemoryOpaqueCaptureAddress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t vkGetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetDeviceMemoryOpaqueCaptureAddress$descriptor() {
        return vkGetDeviceMemoryOpaqueCaptureAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t vkGetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo)
     * }
     */
    public static MethodHandle vkGetDeviceMemoryOpaqueCaptureAddress$handle() {
        return vkGetDeviceMemoryOpaqueCaptureAddress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t vkGetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo)
     * }
     */
    public static MemorySegment vkGetDeviceMemoryOpaqueCaptureAddress$address() {
        return vkGetDeviceMemoryOpaqueCaptureAddress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t vkGetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo)
     * }
     */
    public static long vkGetDeviceMemoryOpaqueCaptureAddress(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetDeviceMemoryOpaqueCaptureAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceMemoryOpaqueCaptureAddress", device, pInfo);
            }
            return (long)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkSurfaceKHR_T *VkSurfaceKHR
     * }
     */
    public static final AddressLayout VkSurfaceKHR = vulkan_h.C_POINTER;
    private static final int VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0
     * }
     */
    public static int VK_COLOR_SPACE_SRGB_NONLINEAR_KHR() {
        return VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
    }
    private static final int VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = (int)1000104001L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001
     * }
     */
    public static int VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT() {
        return VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = (int)1000104002L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002
     * }
     */
    public static int VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT() {
        return VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = (int)1000104003L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT = 1000104003
     * }
     */
    public static int VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT() {
        return VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = (int)1000104004L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004
     * }
     */
    public static int VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT() {
        return VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_BT709_LINEAR_EXT = (int)1000104005L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005
     * }
     */
    public static int VK_COLOR_SPACE_BT709_LINEAR_EXT() {
        return VK_COLOR_SPACE_BT709_LINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_BT709_NONLINEAR_EXT = (int)1000104006L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006
     * }
     */
    public static int VK_COLOR_SPACE_BT709_NONLINEAR_EXT() {
        return VK_COLOR_SPACE_BT709_NONLINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_BT2020_LINEAR_EXT = (int)1000104007L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007
     * }
     */
    public static int VK_COLOR_SPACE_BT2020_LINEAR_EXT() {
        return VK_COLOR_SPACE_BT2020_LINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_HDR10_ST2084_EXT = (int)1000104008L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008
     * }
     */
    public static int VK_COLOR_SPACE_HDR10_ST2084_EXT() {
        return VK_COLOR_SPACE_HDR10_ST2084_EXT;
    }
    private static final int VK_COLOR_SPACE_DOLBYVISION_EXT = (int)1000104009L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009
     * }
     */
    public static int VK_COLOR_SPACE_DOLBYVISION_EXT() {
        return VK_COLOR_SPACE_DOLBYVISION_EXT;
    }
    private static final int VK_COLOR_SPACE_HDR10_HLG_EXT = (int)1000104010L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010
     * }
     */
    public static int VK_COLOR_SPACE_HDR10_HLG_EXT() {
        return VK_COLOR_SPACE_HDR10_HLG_EXT;
    }
    private static final int VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = (int)1000104011L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011
     * }
     */
    public static int VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT() {
        return VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = (int)1000104012L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012
     * }
     */
    public static int VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT() {
        return VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_PASS_THROUGH_EXT = (int)1000104013L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013
     * }
     */
    public static int VK_COLOR_SPACE_PASS_THROUGH_EXT() {
        return VK_COLOR_SPACE_PASS_THROUGH_EXT;
    }
    private static final int VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = (int)1000104014L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014
     * }
     */
    public static int VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT() {
        return VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = (int)1000213000L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000
     * }
     */
    public static int VK_COLOR_SPACE_DISPLAY_NATIVE_AMD() {
        return VK_COLOR_SPACE_DISPLAY_NATIVE_AMD;
    }
    private static final int VK_COLORSPACE_SRGB_NONLINEAR_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0
     * }
     */
    public static int VK_COLORSPACE_SRGB_NONLINEAR_KHR() {
        return VK_COLORSPACE_SRGB_NONLINEAR_KHR;
    }
    private static final int VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = (int)1000104003L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = 1000104003
     * }
     */
    public static int VK_COLOR_SPACE_DCI_P3_LINEAR_EXT() {
        return VK_COLOR_SPACE_DCI_P3_LINEAR_EXT;
    }
    private static final int VK_COLOR_SPACE_BEGIN_RANGE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_BEGIN_RANGE_KHR = 0
     * }
     */
    public static int VK_COLOR_SPACE_BEGIN_RANGE_KHR() {
        return VK_COLOR_SPACE_BEGIN_RANGE_KHR;
    }
    private static final int VK_COLOR_SPACE_END_RANGE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_END_RANGE_KHR = 0
     * }
     */
    public static int VK_COLOR_SPACE_END_RANGE_KHR() {
        return VK_COLOR_SPACE_END_RANGE_KHR;
    }
    private static final int VK_COLOR_SPACE_RANGE_SIZE_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_RANGE_SIZE_KHR = 1
     * }
     */
    public static int VK_COLOR_SPACE_RANGE_SIZE_KHR() {
        return VK_COLOR_SPACE_RANGE_SIZE_KHR;
    }
    private static final int VK_COLOR_SPACE_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkColorSpaceKHR.VK_COLOR_SPACE_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_COLOR_SPACE_MAX_ENUM_KHR() {
        return VK_COLOR_SPACE_MAX_ENUM_KHR;
    }
    private static final int VK_PRESENT_MODE_IMMEDIATE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_IMMEDIATE_KHR = 0
     * }
     */
    public static int VK_PRESENT_MODE_IMMEDIATE_KHR() {
        return VK_PRESENT_MODE_IMMEDIATE_KHR;
    }
    private static final int VK_PRESENT_MODE_MAILBOX_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_MAILBOX_KHR = 1
     * }
     */
    public static int VK_PRESENT_MODE_MAILBOX_KHR() {
        return VK_PRESENT_MODE_MAILBOX_KHR;
    }
    private static final int VK_PRESENT_MODE_FIFO_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_FIFO_KHR = 2
     * }
     */
    public static int VK_PRESENT_MODE_FIFO_KHR() {
        return VK_PRESENT_MODE_FIFO_KHR;
    }
    private static final int VK_PRESENT_MODE_FIFO_RELAXED_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3
     * }
     */
    public static int VK_PRESENT_MODE_FIFO_RELAXED_KHR() {
        return VK_PRESENT_MODE_FIFO_RELAXED_KHR;
    }
    private static final int VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = (int)1000111000L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000
     * }
     */
    public static int VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR() {
        return VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR;
    }
    private static final int VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = (int)1000111001L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001
     * }
     */
    public static int VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR() {
        return VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR;
    }
    private static final int VK_PRESENT_MODE_BEGIN_RANGE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_BEGIN_RANGE_KHR = 0
     * }
     */
    public static int VK_PRESENT_MODE_BEGIN_RANGE_KHR() {
        return VK_PRESENT_MODE_BEGIN_RANGE_KHR;
    }
    private static final int VK_PRESENT_MODE_END_RANGE_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_END_RANGE_KHR = 3
     * }
     */
    public static int VK_PRESENT_MODE_END_RANGE_KHR() {
        return VK_PRESENT_MODE_END_RANGE_KHR;
    }
    private static final int VK_PRESENT_MODE_RANGE_SIZE_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_RANGE_SIZE_KHR = 4
     * }
     */
    public static int VK_PRESENT_MODE_RANGE_SIZE_KHR() {
        return VK_PRESENT_MODE_RANGE_SIZE_KHR;
    }
    private static final int VK_PRESENT_MODE_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPresentModeKHR.VK_PRESENT_MODE_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_PRESENT_MODE_MAX_ENUM_KHR() {
        return VK_PRESENT_MODE_MAX_ENUM_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1
     * }
     */
    public static int VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR() {
        return VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 2
     * }
     */
    public static int VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR() {
        return VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 4
     * }
     */
    public static int VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR() {
        return VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 8
     * }
     */
    public static int VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR() {
        return VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 16
     * }
     */
    public static int VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR() {
        return VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32
     * }
     */
    public static int VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR() {
        return VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = (int)64L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64
     * }
     */
    public static int VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR() {
        return VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = (int)128L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128
     * }
     */
    public static int VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR() {
        return VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = (int)256L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 256
     * }
     */
    public static int VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR() {
        return VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR;
    }
    private static final int VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceTransformFlagBitsKHR.VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR() {
        return VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkSurfaceTransformFlagsKHR
     * }
     */
    public static final OfInt VkSurfaceTransformFlagsKHR = vulkan_h.C_INT;
    private static final int VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkCompositeAlphaFlagBitsKHR.VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1
     * }
     */
    public static int VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR() {
        return VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    }
    private static final int VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkCompositeAlphaFlagBitsKHR.VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 2
     * }
     */
    public static int VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR() {
        return VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR;
    }
    private static final int VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkCompositeAlphaFlagBitsKHR.VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 4
     * }
     */
    public static int VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR() {
        return VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR;
    }
    private static final int VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkCompositeAlphaFlagBitsKHR.VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 8
     * }
     */
    public static int VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR() {
        return VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR;
    }
    private static final int VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkCompositeAlphaFlagBitsKHR.VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR() {
        return VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkCompositeAlphaFlagsKHR
     * }
     */
    public static final OfInt VkCompositeAlphaFlagsKHR = vulkan_h.C_INT;

    private static class vkDestroySurfaceKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroySurfaceKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroySurfaceKHR$descriptor() {
        return vkDestroySurfaceKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroySurfaceKHR$handle() {
        return vkDestroySurfaceKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroySurfaceKHR$address() {
        return vkDestroySurfaceKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroySurfaceKHR(MemorySegment instance, MemorySegment surface, MemorySegment pAllocator) {
        var mh$ = vkDestroySurfaceKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroySurfaceKHR", instance, surface, pAllocator);
            }
            mh$.invokeExact(instance, surface, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceSurfaceSupportKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSurfaceSupportKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSurfaceSupportKHR$descriptor() {
        return vkGetPhysicalDeviceSurfaceSupportKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSurfaceSupportKHR$handle() {
        return vkGetPhysicalDeviceSurfaceSupportKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSurfaceSupportKHR$address() {
        return vkGetPhysicalDeviceSurfaceSupportKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported)
     * }
     */
    public static int vkGetPhysicalDeviceSurfaceSupportKHR(MemorySegment physicalDevice, int queueFamilyIndex, MemorySegment surface, MemorySegment pSupported) {
        var mh$ = vkGetPhysicalDeviceSurfaceSupportKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSurfaceSupportKHR", physicalDevice, queueFamilyIndex, surface, pSupported);
            }
            return (int)mh$.invokeExact(physicalDevice, queueFamilyIndex, surface, pSupported);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceSurfaceCapabilitiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSurfaceCapabilitiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSurfaceCapabilitiesKHR$descriptor() {
        return vkGetPhysicalDeviceSurfaceCapabilitiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSurfaceCapabilitiesKHR$handle() {
        return vkGetPhysicalDeviceSurfaceCapabilitiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSurfaceCapabilitiesKHR$address() {
        return vkGetPhysicalDeviceSurfaceCapabilitiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities)
     * }
     */
    public static int vkGetPhysicalDeviceSurfaceCapabilitiesKHR(MemorySegment physicalDevice, MemorySegment surface, MemorySegment pSurfaceCapabilities) {
        var mh$ = vkGetPhysicalDeviceSurfaceCapabilitiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", physicalDevice, surface, pSurfaceCapabilities);
            }
            return (int)mh$.invokeExact(physicalDevice, surface, pSurfaceCapabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceSurfaceFormatsKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSurfaceFormatsKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSurfaceFormatsKHR$descriptor() {
        return vkGetPhysicalDeviceSurfaceFormatsKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSurfaceFormatsKHR$handle() {
        return vkGetPhysicalDeviceSurfaceFormatsKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSurfaceFormatsKHR$address() {
        return vkGetPhysicalDeviceSurfaceFormatsKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats)
     * }
     */
    public static int vkGetPhysicalDeviceSurfaceFormatsKHR(MemorySegment physicalDevice, MemorySegment surface, MemorySegment pSurfaceFormatCount, MemorySegment pSurfaceFormats) {
        var mh$ = vkGetPhysicalDeviceSurfaceFormatsKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSurfaceFormatsKHR", physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
            }
            return (int)mh$.invokeExact(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceSurfacePresentModesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSurfacePresentModesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSurfacePresentModesKHR$descriptor() {
        return vkGetPhysicalDeviceSurfacePresentModesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSurfacePresentModesKHR$handle() {
        return vkGetPhysicalDeviceSurfacePresentModesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSurfacePresentModesKHR$address() {
        return vkGetPhysicalDeviceSurfacePresentModesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes)
     * }
     */
    public static int vkGetPhysicalDeviceSurfacePresentModesKHR(MemorySegment physicalDevice, MemorySegment surface, MemorySegment pPresentModeCount, MemorySegment pPresentModes) {
        var mh$ = vkGetPhysicalDeviceSurfacePresentModesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSurfacePresentModesKHR", physicalDevice, surface, pPresentModeCount, pPresentModes);
            }
            return (int)mh$.invokeExact(physicalDevice, surface, pPresentModeCount, pPresentModes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkSwapchainKHR_T *VkSwapchainKHR
     * }
     */
    public static final AddressLayout VkSwapchainKHR = vulkan_h.C_POINTER;
    private static final int VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSwapchainCreateFlagBitsKHR.VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 1
     * }
     */
    public static int VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR() {
        return VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR;
    }
    private static final int VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkSwapchainCreateFlagBitsKHR.VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 2
     * }
     */
    public static int VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR() {
        return VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR;
    }
    private static final int VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkSwapchainCreateFlagBitsKHR.VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR = 4
     * }
     */
    public static int VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR() {
        return VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR;
    }
    private static final int VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSwapchainCreateFlagBitsKHR.VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR() {
        return VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkSwapchainCreateFlagsKHR
     * }
     */
    public static final OfInt VkSwapchainCreateFlagsKHR = vulkan_h.C_INT;
    private static final int VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceGroupPresentModeFlagBitsKHR.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 1
     * }
     */
    public static int VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR() {
        return VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR;
    }
    private static final int VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceGroupPresentModeFlagBitsKHR.VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 2
     * }
     */
    public static int VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR() {
        return VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR;
    }
    private static final int VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceGroupPresentModeFlagBitsKHR.VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 4
     * }
     */
    public static int VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR() {
        return VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR;
    }
    private static final int VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceGroupPresentModeFlagBitsKHR.VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 8
     * }
     */
    public static int VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR() {
        return VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR;
    }
    private static final int VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceGroupPresentModeFlagBitsKHR.VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR() {
        return VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHR;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDeviceGroupPresentModeFlagsKHR
     * }
     */
    public static final OfInt VkDeviceGroupPresentModeFlagsKHR = vulkan_h.C_INT;

    private static class vkCreateSwapchainKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateSwapchainKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain)
     * }
     */
    public static FunctionDescriptor vkCreateSwapchainKHR$descriptor() {
        return vkCreateSwapchainKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain)
     * }
     */
    public static MethodHandle vkCreateSwapchainKHR$handle() {
        return vkCreateSwapchainKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain)
     * }
     */
    public static MemorySegment vkCreateSwapchainKHR$address() {
        return vkCreateSwapchainKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain)
     * }
     */
    public static int vkCreateSwapchainKHR(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSwapchain) {
        var mh$ = vkCreateSwapchainKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateSwapchainKHR", device, pCreateInfo, pAllocator, pSwapchain);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pSwapchain);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroySwapchainKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroySwapchainKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroySwapchainKHR$descriptor() {
        return vkDestroySwapchainKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroySwapchainKHR$handle() {
        return vkDestroySwapchainKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroySwapchainKHR$address() {
        return vkDestroySwapchainKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroySwapchainKHR(MemorySegment device, MemorySegment swapchain, MemorySegment pAllocator) {
        var mh$ = vkDestroySwapchainKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroySwapchainKHR", device, swapchain, pAllocator);
            }
            mh$.invokeExact(device, swapchain, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetSwapchainImagesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetSwapchainImagesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages)
     * }
     */
    public static FunctionDescriptor vkGetSwapchainImagesKHR$descriptor() {
        return vkGetSwapchainImagesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages)
     * }
     */
    public static MethodHandle vkGetSwapchainImagesKHR$handle() {
        return vkGetSwapchainImagesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages)
     * }
     */
    public static MemorySegment vkGetSwapchainImagesKHR$address() {
        return vkGetSwapchainImagesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages)
     * }
     */
    public static int vkGetSwapchainImagesKHR(MemorySegment device, MemorySegment swapchain, MemorySegment pSwapchainImageCount, MemorySegment pSwapchainImages) {
        var mh$ = vkGetSwapchainImagesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetSwapchainImagesKHR", device, swapchain, pSwapchainImageCount, pSwapchainImages);
            }
            return (int)mh$.invokeExact(device, swapchain, pSwapchainImageCount, pSwapchainImages);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkAcquireNextImageKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkAcquireNextImageKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex)
     * }
     */
    public static FunctionDescriptor vkAcquireNextImageKHR$descriptor() {
        return vkAcquireNextImageKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex)
     * }
     */
    public static MethodHandle vkAcquireNextImageKHR$handle() {
        return vkAcquireNextImageKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex)
     * }
     */
    public static MemorySegment vkAcquireNextImageKHR$address() {
        return vkAcquireNextImageKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkAcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex)
     * }
     */
    public static int vkAcquireNextImageKHR(MemorySegment device, MemorySegment swapchain, long timeout, MemorySegment semaphore, MemorySegment fence, MemorySegment pImageIndex) {
        var mh$ = vkAcquireNextImageKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkAcquireNextImageKHR", device, swapchain, timeout, semaphore, fence, pImageIndex);
            }
            return (int)mh$.invokeExact(device, swapchain, timeout, semaphore, fence, pImageIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkQueuePresentKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkQueuePresentKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo)
     * }
     */
    public static FunctionDescriptor vkQueuePresentKHR$descriptor() {
        return vkQueuePresentKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo)
     * }
     */
    public static MethodHandle vkQueuePresentKHR$handle() {
        return vkQueuePresentKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo)
     * }
     */
    public static MemorySegment vkQueuePresentKHR$address() {
        return vkQueuePresentKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo)
     * }
     */
    public static int vkQueuePresentKHR(MemorySegment queue, MemorySegment pPresentInfo) {
        var mh$ = vkQueuePresentKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkQueuePresentKHR", queue, pPresentInfo);
            }
            return (int)mh$.invokeExact(queue, pPresentInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceGroupPresentCapabilitiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceGroupPresentCapabilitiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities)
     * }
     */
    public static FunctionDescriptor vkGetDeviceGroupPresentCapabilitiesKHR$descriptor() {
        return vkGetDeviceGroupPresentCapabilitiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities)
     * }
     */
    public static MethodHandle vkGetDeviceGroupPresentCapabilitiesKHR$handle() {
        return vkGetDeviceGroupPresentCapabilitiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities)
     * }
     */
    public static MemorySegment vkGetDeviceGroupPresentCapabilitiesKHR$address() {
        return vkGetDeviceGroupPresentCapabilitiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities)
     * }
     */
    public static int vkGetDeviceGroupPresentCapabilitiesKHR(MemorySegment device, MemorySegment pDeviceGroupPresentCapabilities) {
        var mh$ = vkGetDeviceGroupPresentCapabilitiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceGroupPresentCapabilitiesKHR", device, pDeviceGroupPresentCapabilities);
            }
            return (int)mh$.invokeExact(device, pDeviceGroupPresentCapabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceGroupSurfacePresentModesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceGroupSurfacePresentModesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes)
     * }
     */
    public static FunctionDescriptor vkGetDeviceGroupSurfacePresentModesKHR$descriptor() {
        return vkGetDeviceGroupSurfacePresentModesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes)
     * }
     */
    public static MethodHandle vkGetDeviceGroupSurfacePresentModesKHR$handle() {
        return vkGetDeviceGroupSurfacePresentModesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes)
     * }
     */
    public static MemorySegment vkGetDeviceGroupSurfacePresentModesKHR$address() {
        return vkGetDeviceGroupSurfacePresentModesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes)
     * }
     */
    public static int vkGetDeviceGroupSurfacePresentModesKHR(MemorySegment device, MemorySegment surface, MemorySegment pModes) {
        var mh$ = vkGetDeviceGroupSurfacePresentModesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceGroupSurfacePresentModesKHR", device, surface, pModes);
            }
            return (int)mh$.invokeExact(device, surface, pModes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDevicePresentRectanglesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDevicePresentRectanglesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDevicePresentRectanglesKHR$descriptor() {
        return vkGetPhysicalDevicePresentRectanglesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects)
     * }
     */
    public static MethodHandle vkGetPhysicalDevicePresentRectanglesKHR$handle() {
        return vkGetPhysicalDevicePresentRectanglesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects)
     * }
     */
    public static MemorySegment vkGetPhysicalDevicePresentRectanglesKHR$address() {
        return vkGetPhysicalDevicePresentRectanglesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects)
     * }
     */
    public static int vkGetPhysicalDevicePresentRectanglesKHR(MemorySegment physicalDevice, MemorySegment surface, MemorySegment pRectCount, MemorySegment pRects) {
        var mh$ = vkGetPhysicalDevicePresentRectanglesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDevicePresentRectanglesKHR", physicalDevice, surface, pRectCount, pRects);
            }
            return (int)mh$.invokeExact(physicalDevice, surface, pRectCount, pRects);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkAcquireNextImage2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkAcquireNextImage2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkAcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex)
     * }
     */
    public static FunctionDescriptor vkAcquireNextImage2KHR$descriptor() {
        return vkAcquireNextImage2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkAcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex)
     * }
     */
    public static MethodHandle vkAcquireNextImage2KHR$handle() {
        return vkAcquireNextImage2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkAcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex)
     * }
     */
    public static MemorySegment vkAcquireNextImage2KHR$address() {
        return vkAcquireNextImage2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkAcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex)
     * }
     */
    public static int vkAcquireNextImage2KHR(MemorySegment device, MemorySegment pAcquireInfo, MemorySegment pImageIndex) {
        var mh$ = vkAcquireNextImage2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkAcquireNextImage2KHR", device, pAcquireInfo, pImageIndex);
            }
            return (int)mh$.invokeExact(device, pAcquireInfo, pImageIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkDisplayKHR_T *VkDisplayKHR
     * }
     */
    public static final AddressLayout VkDisplayKHR = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct VkDisplayModeKHR_T *VkDisplayModeKHR
     * }
     */
    public static final AddressLayout VkDisplayModeKHR = vulkan_h.C_POINTER;
    private static final int VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPlaneAlphaFlagBitsKHR.VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1
     * }
     */
    public static int VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR() {
        return VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR;
    }
    private static final int VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPlaneAlphaFlagBitsKHR.VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 2
     * }
     */
    public static int VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR() {
        return VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR;
    }
    private static final int VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPlaneAlphaFlagBitsKHR.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 4
     * }
     */
    public static int VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR() {
        return VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR;
    }
    private static final int VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPlaneAlphaFlagBitsKHR.VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8
     * }
     */
    public static int VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR() {
        return VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR;
    }
    private static final int VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPlaneAlphaFlagBitsKHR.VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR() {
        return VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDisplayPlaneAlphaFlagsKHR
     * }
     */
    public static final OfInt VkDisplayPlaneAlphaFlagsKHR = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDisplayModeCreateFlagsKHR
     * }
     */
    public static final OfInt VkDisplayModeCreateFlagsKHR = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDisplaySurfaceCreateFlagsKHR
     * }
     */
    public static final OfInt VkDisplaySurfaceCreateFlagsKHR = vulkan_h.C_INT;

    private static class vkGetPhysicalDeviceDisplayPropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceDisplayPropertiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceDisplayPropertiesKHR$descriptor() {
        return vkGetPhysicalDeviceDisplayPropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceDisplayPropertiesKHR$handle() {
        return vkGetPhysicalDeviceDisplayPropertiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceDisplayPropertiesKHR$address() {
        return vkGetPhysicalDeviceDisplayPropertiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties)
     * }
     */
    public static int vkGetPhysicalDeviceDisplayPropertiesKHR(MemorySegment physicalDevice, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceDisplayPropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceDisplayPropertiesKHR", physicalDevice, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceDisplayPlanePropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceDisplayPlanePropertiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceDisplayPlanePropertiesKHR$descriptor() {
        return vkGetPhysicalDeviceDisplayPlanePropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceDisplayPlanePropertiesKHR$handle() {
        return vkGetPhysicalDeviceDisplayPlanePropertiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceDisplayPlanePropertiesKHR$address() {
        return vkGetPhysicalDeviceDisplayPlanePropertiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties)
     * }
     */
    public static int vkGetPhysicalDeviceDisplayPlanePropertiesKHR(MemorySegment physicalDevice, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceDisplayPlanePropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceDisplayPlanePropertiesKHR", physicalDevice, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDisplayPlaneSupportedDisplaysKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDisplayPlaneSupportedDisplaysKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays)
     * }
     */
    public static FunctionDescriptor vkGetDisplayPlaneSupportedDisplaysKHR$descriptor() {
        return vkGetDisplayPlaneSupportedDisplaysKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays)
     * }
     */
    public static MethodHandle vkGetDisplayPlaneSupportedDisplaysKHR$handle() {
        return vkGetDisplayPlaneSupportedDisplaysKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays)
     * }
     */
    public static MemorySegment vkGetDisplayPlaneSupportedDisplaysKHR$address() {
        return vkGetDisplayPlaneSupportedDisplaysKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays)
     * }
     */
    public static int vkGetDisplayPlaneSupportedDisplaysKHR(MemorySegment physicalDevice, int planeIndex, MemorySegment pDisplayCount, MemorySegment pDisplays) {
        var mh$ = vkGetDisplayPlaneSupportedDisplaysKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDisplayPlaneSupportedDisplaysKHR", physicalDevice, planeIndex, pDisplayCount, pDisplays);
            }
            return (int)mh$.invokeExact(physicalDevice, planeIndex, pDisplayCount, pDisplays);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDisplayModePropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDisplayModePropertiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetDisplayModePropertiesKHR$descriptor() {
        return vkGetDisplayModePropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties)
     * }
     */
    public static MethodHandle vkGetDisplayModePropertiesKHR$handle() {
        return vkGetDisplayModePropertiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties)
     * }
     */
    public static MemorySegment vkGetDisplayModePropertiesKHR$address() {
        return vkGetDisplayModePropertiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties)
     * }
     */
    public static int vkGetDisplayModePropertiesKHR(MemorySegment physicalDevice, MemorySegment display, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetDisplayModePropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDisplayModePropertiesKHR", physicalDevice, display, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, display, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateDisplayModeKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateDisplayModeKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode)
     * }
     */
    public static FunctionDescriptor vkCreateDisplayModeKHR$descriptor() {
        return vkCreateDisplayModeKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode)
     * }
     */
    public static MethodHandle vkCreateDisplayModeKHR$handle() {
        return vkCreateDisplayModeKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode)
     * }
     */
    public static MemorySegment vkCreateDisplayModeKHR$address() {
        return vkCreateDisplayModeKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode)
     * }
     */
    public static int vkCreateDisplayModeKHR(MemorySegment physicalDevice, MemorySegment display, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pMode) {
        var mh$ = vkCreateDisplayModeKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateDisplayModeKHR", physicalDevice, display, pCreateInfo, pAllocator, pMode);
            }
            return (int)mh$.invokeExact(physicalDevice, display, pCreateInfo, pAllocator, pMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDisplayPlaneCapabilitiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDisplayPlaneCapabilitiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities)
     * }
     */
    public static FunctionDescriptor vkGetDisplayPlaneCapabilitiesKHR$descriptor() {
        return vkGetDisplayPlaneCapabilitiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities)
     * }
     */
    public static MethodHandle vkGetDisplayPlaneCapabilitiesKHR$handle() {
        return vkGetDisplayPlaneCapabilitiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities)
     * }
     */
    public static MemorySegment vkGetDisplayPlaneCapabilitiesKHR$address() {
        return vkGetDisplayPlaneCapabilitiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities)
     * }
     */
    public static int vkGetDisplayPlaneCapabilitiesKHR(MemorySegment physicalDevice, MemorySegment mode, int planeIndex, MemorySegment pCapabilities) {
        var mh$ = vkGetDisplayPlaneCapabilitiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDisplayPlaneCapabilitiesKHR", physicalDevice, mode, planeIndex, pCapabilities);
            }
            return (int)mh$.invokeExact(physicalDevice, mode, planeIndex, pCapabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateDisplayPlaneSurfaceKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateDisplayPlaneSurfaceKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static FunctionDescriptor vkCreateDisplayPlaneSurfaceKHR$descriptor() {
        return vkCreateDisplayPlaneSurfaceKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static MethodHandle vkCreateDisplayPlaneSurfaceKHR$handle() {
        return vkCreateDisplayPlaneSurfaceKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static MemorySegment vkCreateDisplayPlaneSurfaceKHR$address() {
        return vkCreateDisplayPlaneSurfaceKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface)
     * }
     */
    public static int vkCreateDisplayPlaneSurfaceKHR(MemorySegment instance, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pSurface) {
        var mh$ = vkCreateDisplayPlaneSurfaceKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateDisplayPlaneSurfaceKHR", instance, pCreateInfo, pAllocator, pSurface);
            }
            return (int)mh$.invokeExact(instance, pCreateInfo, pAllocator, pSurface);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateSharedSwapchainsKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateSharedSwapchainsKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains)
     * }
     */
    public static FunctionDescriptor vkCreateSharedSwapchainsKHR$descriptor() {
        return vkCreateSharedSwapchainsKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains)
     * }
     */
    public static MethodHandle vkCreateSharedSwapchainsKHR$handle() {
        return vkCreateSharedSwapchainsKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains)
     * }
     */
    public static MemorySegment vkCreateSharedSwapchainsKHR$address() {
        return vkCreateSharedSwapchainsKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains)
     * }
     */
    public static int vkCreateSharedSwapchainsKHR(MemorySegment device, int swapchainCount, MemorySegment pCreateInfos, MemorySegment pAllocator, MemorySegment pSwapchains) {
        var mh$ = vkCreateSharedSwapchainsKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateSharedSwapchainsKHR", device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
            }
            return (int)mh$.invokeExact(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceFeatures2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceFeatures2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceFeatures2KHR$descriptor() {
        return vkGetPhysicalDeviceFeatures2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceFeatures2KHR$handle() {
        return vkGetPhysicalDeviceFeatures2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceFeatures2KHR$address() {
        return vkGetPhysicalDeviceFeatures2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures)
     * }
     */
    public static void vkGetPhysicalDeviceFeatures2KHR(MemorySegment physicalDevice, MemorySegment pFeatures) {
        var mh$ = vkGetPhysicalDeviceFeatures2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceFeatures2KHR", physicalDevice, pFeatures);
            }
            mh$.invokeExact(physicalDevice, pFeatures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceProperties2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceProperties2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceProperties2KHR$descriptor() {
        return vkGetPhysicalDeviceProperties2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceProperties2KHR$handle() {
        return vkGetPhysicalDeviceProperties2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceProperties2KHR$address() {
        return vkGetPhysicalDeviceProperties2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties)
     * }
     */
    public static void vkGetPhysicalDeviceProperties2KHR(MemorySegment physicalDevice, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceProperties2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceProperties2KHR", physicalDevice, pProperties);
            }
            mh$.invokeExact(physicalDevice, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceFormatProperties2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceFormatProperties2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceFormatProperties2KHR$descriptor() {
        return vkGetPhysicalDeviceFormatProperties2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceFormatProperties2KHR$handle() {
        return vkGetPhysicalDeviceFormatProperties2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceFormatProperties2KHR$address() {
        return vkGetPhysicalDeviceFormatProperties2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties)
     * }
     */
    public static void vkGetPhysicalDeviceFormatProperties2KHR(MemorySegment physicalDevice, int format, MemorySegment pFormatProperties) {
        var mh$ = vkGetPhysicalDeviceFormatProperties2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceFormatProperties2KHR", physicalDevice, format, pFormatProperties);
            }
            mh$.invokeExact(physicalDevice, format, pFormatProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceImageFormatProperties2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceImageFormatProperties2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceImageFormatProperties2KHR$descriptor() {
        return vkGetPhysicalDeviceImageFormatProperties2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceImageFormatProperties2KHR$handle() {
        return vkGetPhysicalDeviceImageFormatProperties2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceImageFormatProperties2KHR$address() {
        return vkGetPhysicalDeviceImageFormatProperties2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties)
     * }
     */
    public static int vkGetPhysicalDeviceImageFormatProperties2KHR(MemorySegment physicalDevice, MemorySegment pImageFormatInfo, MemorySegment pImageFormatProperties) {
        var mh$ = vkGetPhysicalDeviceImageFormatProperties2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceImageFormatProperties2KHR", physicalDevice, pImageFormatInfo, pImageFormatProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pImageFormatInfo, pImageFormatProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceQueueFamilyProperties2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceQueueFamilyProperties2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceQueueFamilyProperties2KHR$descriptor() {
        return vkGetPhysicalDeviceQueueFamilyProperties2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceQueueFamilyProperties2KHR$handle() {
        return vkGetPhysicalDeviceQueueFamilyProperties2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceQueueFamilyProperties2KHR$address() {
        return vkGetPhysicalDeviceQueueFamilyProperties2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties)
     * }
     */
    public static void vkGetPhysicalDeviceQueueFamilyProperties2KHR(MemorySegment physicalDevice, MemorySegment pQueueFamilyPropertyCount, MemorySegment pQueueFamilyProperties) {
        var mh$ = vkGetPhysicalDeviceQueueFamilyProperties2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceQueueFamilyProperties2KHR", physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
            }
            mh$.invokeExact(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceMemoryProperties2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceMemoryProperties2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceMemoryProperties2KHR$descriptor() {
        return vkGetPhysicalDeviceMemoryProperties2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceMemoryProperties2KHR$handle() {
        return vkGetPhysicalDeviceMemoryProperties2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceMemoryProperties2KHR$address() {
        return vkGetPhysicalDeviceMemoryProperties2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties)
     * }
     */
    public static void vkGetPhysicalDeviceMemoryProperties2KHR(MemorySegment physicalDevice, MemorySegment pMemoryProperties) {
        var mh$ = vkGetPhysicalDeviceMemoryProperties2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceMemoryProperties2KHR", physicalDevice, pMemoryProperties);
            }
            mh$.invokeExact(physicalDevice, pMemoryProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceSparseImageFormatProperties2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSparseImageFormatProperties2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSparseImageFormatProperties2KHR$descriptor() {
        return vkGetPhysicalDeviceSparseImageFormatProperties2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSparseImageFormatProperties2KHR$handle() {
        return vkGetPhysicalDeviceSparseImageFormatProperties2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSparseImageFormatProperties2KHR$address() {
        return vkGetPhysicalDeviceSparseImageFormatProperties2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties)
     * }
     */
    public static void vkGetPhysicalDeviceSparseImageFormatProperties2KHR(MemorySegment physicalDevice, MemorySegment pFormatInfo, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceSparseImageFormatProperties2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSparseImageFormatProperties2KHR", physicalDevice, pFormatInfo, pPropertyCount, pProperties);
            }
            mh$.invokeExact(physicalDevice, pFormatInfo, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkPeerMemoryFeatureFlags VkPeerMemoryFeatureFlagsKHR
     * }
     */
    public static final OfInt VkPeerMemoryFeatureFlagsKHR = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkMemoryAllocateFlags VkMemoryAllocateFlagsKHR
     * }
     */
    public static final OfInt VkMemoryAllocateFlagsKHR = vulkan_h.C_INT;

    private static class vkGetDeviceGroupPeerMemoryFeaturesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceGroupPeerMemoryFeaturesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures)
     * }
     */
    public static FunctionDescriptor vkGetDeviceGroupPeerMemoryFeaturesKHR$descriptor() {
        return vkGetDeviceGroupPeerMemoryFeaturesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures)
     * }
     */
    public static MethodHandle vkGetDeviceGroupPeerMemoryFeaturesKHR$handle() {
        return vkGetDeviceGroupPeerMemoryFeaturesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures)
     * }
     */
    public static MemorySegment vkGetDeviceGroupPeerMemoryFeaturesKHR$address() {
        return vkGetDeviceGroupPeerMemoryFeaturesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures)
     * }
     */
    public static void vkGetDeviceGroupPeerMemoryFeaturesKHR(MemorySegment device, int heapIndex, int localDeviceIndex, int remoteDeviceIndex, MemorySegment pPeerMemoryFeatures) {
        var mh$ = vkGetDeviceGroupPeerMemoryFeaturesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceGroupPeerMemoryFeaturesKHR", device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
            }
            mh$.invokeExact(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetDeviceMaskKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetDeviceMaskKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask)
     * }
     */
    public static FunctionDescriptor vkCmdSetDeviceMaskKHR$descriptor() {
        return vkCmdSetDeviceMaskKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask)
     * }
     */
    public static MethodHandle vkCmdSetDeviceMaskKHR$handle() {
        return vkCmdSetDeviceMaskKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask)
     * }
     */
    public static MemorySegment vkCmdSetDeviceMaskKHR$address() {
        return vkCmdSetDeviceMaskKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask)
     * }
     */
    public static void vkCmdSetDeviceMaskKHR(MemorySegment commandBuffer, int deviceMask) {
        var mh$ = vkCmdSetDeviceMaskKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetDeviceMaskKHR", commandBuffer, deviceMask);
            }
            mh$.invokeExact(commandBuffer, deviceMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDispatchBaseKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDispatchBaseKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static FunctionDescriptor vkCmdDispatchBaseKHR$descriptor() {
        return vkCmdDispatchBaseKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static MethodHandle vkCmdDispatchBaseKHR$handle() {
        return vkCmdDispatchBaseKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static MemorySegment vkCmdDispatchBaseKHR$address() {
        return vkCmdDispatchBaseKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
     * }
     */
    public static void vkCmdDispatchBaseKHR(MemorySegment commandBuffer, int baseGroupX, int baseGroupY, int baseGroupZ, int groupCountX, int groupCountY, int groupCountZ) {
        var mh$ = vkCmdDispatchBaseKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDispatchBaseKHR", commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
            }
            mh$.invokeExact(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkCommandPoolTrimFlags VkCommandPoolTrimFlagsKHR
     * }
     */
    public static final OfInt VkCommandPoolTrimFlagsKHR = vulkan_h.C_INT;

    private static class vkTrimCommandPoolKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkTrimCommandPoolKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
     * }
     */
    public static FunctionDescriptor vkTrimCommandPoolKHR$descriptor() {
        return vkTrimCommandPoolKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
     * }
     */
    public static MethodHandle vkTrimCommandPoolKHR$handle() {
        return vkTrimCommandPoolKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
     * }
     */
    public static MemorySegment vkTrimCommandPoolKHR$address() {
        return vkTrimCommandPoolKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkTrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
     * }
     */
    public static void vkTrimCommandPoolKHR(MemorySegment device, MemorySegment commandPool, int flags) {
        var mh$ = vkTrimCommandPoolKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkTrimCommandPoolKHR", device, commandPool, flags);
            }
            mh$.invokeExact(device, commandPool, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkEnumeratePhysicalDeviceGroupsKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEnumeratePhysicalDeviceGroupsKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties)
     * }
     */
    public static FunctionDescriptor vkEnumeratePhysicalDeviceGroupsKHR$descriptor() {
        return vkEnumeratePhysicalDeviceGroupsKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties)
     * }
     */
    public static MethodHandle vkEnumeratePhysicalDeviceGroupsKHR$handle() {
        return vkEnumeratePhysicalDeviceGroupsKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties)
     * }
     */
    public static MemorySegment vkEnumeratePhysicalDeviceGroupsKHR$address() {
        return vkEnumeratePhysicalDeviceGroupsKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties)
     * }
     */
    public static int vkEnumeratePhysicalDeviceGroupsKHR(MemorySegment instance, MemorySegment pPhysicalDeviceGroupCount, MemorySegment pPhysicalDeviceGroupProperties) {
        var mh$ = vkEnumeratePhysicalDeviceGroupsKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEnumeratePhysicalDeviceGroupsKHR", instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
            }
            return (int)mh$.invokeExact(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkExternalMemoryHandleTypeFlags VkExternalMemoryHandleTypeFlagsKHR
     * }
     */
    public static final OfInt VkExternalMemoryHandleTypeFlagsKHR = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkExternalMemoryFeatureFlags VkExternalMemoryFeatureFlagsKHR
     * }
     */
    public static final OfInt VkExternalMemoryFeatureFlagsKHR = vulkan_h.C_INT;

    private static class vkGetPhysicalDeviceExternalBufferPropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceExternalBufferPropertiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceExternalBufferPropertiesKHR$descriptor() {
        return vkGetPhysicalDeviceExternalBufferPropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceExternalBufferPropertiesKHR$handle() {
        return vkGetPhysicalDeviceExternalBufferPropertiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceExternalBufferPropertiesKHR$address() {
        return vkGetPhysicalDeviceExternalBufferPropertiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties)
     * }
     */
    public static void vkGetPhysicalDeviceExternalBufferPropertiesKHR(MemorySegment physicalDevice, MemorySegment pExternalBufferInfo, MemorySegment pExternalBufferProperties) {
        var mh$ = vkGetPhysicalDeviceExternalBufferPropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceExternalBufferPropertiesKHR", physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
            }
            mh$.invokeExact(physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetMemoryFdKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetMemoryFdKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static FunctionDescriptor vkGetMemoryFdKHR$descriptor() {
        return vkGetMemoryFdKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static MethodHandle vkGetMemoryFdKHR$handle() {
        return vkGetMemoryFdKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static MemorySegment vkGetMemoryFdKHR$address() {
        return vkGetMemoryFdKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static int vkGetMemoryFdKHR(MemorySegment device, MemorySegment pGetFdInfo, MemorySegment pFd) {
        var mh$ = vkGetMemoryFdKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetMemoryFdKHR", device, pGetFdInfo, pFd);
            }
            return (int)mh$.invokeExact(device, pGetFdInfo, pFd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetMemoryFdPropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetMemoryFdPropertiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties)
     * }
     */
    public static FunctionDescriptor vkGetMemoryFdPropertiesKHR$descriptor() {
        return vkGetMemoryFdPropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties)
     * }
     */
    public static MethodHandle vkGetMemoryFdPropertiesKHR$handle() {
        return vkGetMemoryFdPropertiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties)
     * }
     */
    public static MemorySegment vkGetMemoryFdPropertiesKHR$address() {
        return vkGetMemoryFdPropertiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties)
     * }
     */
    public static int vkGetMemoryFdPropertiesKHR(MemorySegment device, int handleType, int fd, MemorySegment pMemoryFdProperties) {
        var mh$ = vkGetMemoryFdPropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetMemoryFdPropertiesKHR", device, handleType, fd, pMemoryFdProperties);
            }
            return (int)mh$.invokeExact(device, handleType, fd, pMemoryFdProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkExternalSemaphoreHandleTypeFlags VkExternalSemaphoreHandleTypeFlagsKHR
     * }
     */
    public static final OfInt VkExternalSemaphoreHandleTypeFlagsKHR = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkExternalSemaphoreFeatureFlags VkExternalSemaphoreFeatureFlagsKHR
     * }
     */
    public static final OfInt VkExternalSemaphoreFeatureFlagsKHR = vulkan_h.C_INT;

    private static class vkGetPhysicalDeviceExternalSemaphorePropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceExternalSemaphorePropertiesKHR$descriptor() {
        return vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceExternalSemaphorePropertiesKHR$handle() {
        return vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceExternalSemaphorePropertiesKHR$address() {
        return vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties)
     * }
     */
    public static void vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(MemorySegment physicalDevice, MemorySegment pExternalSemaphoreInfo, MemorySegment pExternalSemaphoreProperties) {
        var mh$ = vkGetPhysicalDeviceExternalSemaphorePropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
            }
            mh$.invokeExact(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkSemaphoreImportFlags VkSemaphoreImportFlagsKHR
     * }
     */
    public static final OfInt VkSemaphoreImportFlagsKHR = vulkan_h.C_INT;

    private static class vkImportSemaphoreFdKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkImportSemaphoreFdKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo)
     * }
     */
    public static FunctionDescriptor vkImportSemaphoreFdKHR$descriptor() {
        return vkImportSemaphoreFdKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo)
     * }
     */
    public static MethodHandle vkImportSemaphoreFdKHR$handle() {
        return vkImportSemaphoreFdKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo)
     * }
     */
    public static MemorySegment vkImportSemaphoreFdKHR$address() {
        return vkImportSemaphoreFdKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo)
     * }
     */
    public static int vkImportSemaphoreFdKHR(MemorySegment device, MemorySegment pImportSemaphoreFdInfo) {
        var mh$ = vkImportSemaphoreFdKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkImportSemaphoreFdKHR", device, pImportSemaphoreFdInfo);
            }
            return (int)mh$.invokeExact(device, pImportSemaphoreFdInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetSemaphoreFdKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetSemaphoreFdKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static FunctionDescriptor vkGetSemaphoreFdKHR$descriptor() {
        return vkGetSemaphoreFdKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static MethodHandle vkGetSemaphoreFdKHR$handle() {
        return vkGetSemaphoreFdKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static MemorySegment vkGetSemaphoreFdKHR$address() {
        return vkGetSemaphoreFdKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static int vkGetSemaphoreFdKHR(MemorySegment device, MemorySegment pGetFdInfo, MemorySegment pFd) {
        var mh$ = vkGetSemaphoreFdKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetSemaphoreFdKHR", device, pGetFdInfo, pFd);
            }
            return (int)mh$.invokeExact(device, pGetFdInfo, pFd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdPushDescriptorSetKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdPushDescriptorSetKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites)
     * }
     */
    public static FunctionDescriptor vkCmdPushDescriptorSetKHR$descriptor() {
        return vkCmdPushDescriptorSetKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites)
     * }
     */
    public static MethodHandle vkCmdPushDescriptorSetKHR$handle() {
        return vkCmdPushDescriptorSetKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites)
     * }
     */
    public static MemorySegment vkCmdPushDescriptorSetKHR$address() {
        return vkCmdPushDescriptorSetKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites)
     * }
     */
    public static void vkCmdPushDescriptorSetKHR(MemorySegment commandBuffer, int pipelineBindPoint, MemorySegment layout, int set, int descriptorWriteCount, MemorySegment pDescriptorWrites) {
        var mh$ = vkCmdPushDescriptorSetKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdPushDescriptorSetKHR", commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
            }
            mh$.invokeExact(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdPushDescriptorSetWithTemplateKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdPushDescriptorSetWithTemplateKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData)
     * }
     */
    public static FunctionDescriptor vkCmdPushDescriptorSetWithTemplateKHR$descriptor() {
        return vkCmdPushDescriptorSetWithTemplateKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData)
     * }
     */
    public static MethodHandle vkCmdPushDescriptorSetWithTemplateKHR$handle() {
        return vkCmdPushDescriptorSetWithTemplateKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData)
     * }
     */
    public static MemorySegment vkCmdPushDescriptorSetWithTemplateKHR$address() {
        return vkCmdPushDescriptorSetWithTemplateKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData)
     * }
     */
    public static void vkCmdPushDescriptorSetWithTemplateKHR(MemorySegment commandBuffer, MemorySegment descriptorUpdateTemplate, MemorySegment layout, int set, MemorySegment pData) {
        var mh$ = vkCmdPushDescriptorSetWithTemplateKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdPushDescriptorSetWithTemplateKHR", commandBuffer, descriptorUpdateTemplate, layout, set, pData);
            }
            mh$.invokeExact(commandBuffer, descriptorUpdateTemplate, layout, set, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkDescriptorUpdateTemplate VkDescriptorUpdateTemplateKHR
     * }
     */
    public static final AddressLayout VkDescriptorUpdateTemplateKHR = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef VkDescriptorUpdateTemplateCreateFlags VkDescriptorUpdateTemplateCreateFlagsKHR
     * }
     */
    public static final OfInt VkDescriptorUpdateTemplateCreateFlagsKHR = vulkan_h.C_INT;

    private static class vkCreateDescriptorUpdateTemplateKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateDescriptorUpdateTemplateKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate)
     * }
     */
    public static FunctionDescriptor vkCreateDescriptorUpdateTemplateKHR$descriptor() {
        return vkCreateDescriptorUpdateTemplateKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate)
     * }
     */
    public static MethodHandle vkCreateDescriptorUpdateTemplateKHR$handle() {
        return vkCreateDescriptorUpdateTemplateKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate)
     * }
     */
    public static MemorySegment vkCreateDescriptorUpdateTemplateKHR$address() {
        return vkCreateDescriptorUpdateTemplateKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate)
     * }
     */
    public static int vkCreateDescriptorUpdateTemplateKHR(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pDescriptorUpdateTemplate) {
        var mh$ = vkCreateDescriptorUpdateTemplateKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateDescriptorUpdateTemplateKHR", device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyDescriptorUpdateTemplateKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyDescriptorUpdateTemplateKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyDescriptorUpdateTemplateKHR$descriptor() {
        return vkDestroyDescriptorUpdateTemplateKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyDescriptorUpdateTemplateKHR$handle() {
        return vkDestroyDescriptorUpdateTemplateKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyDescriptorUpdateTemplateKHR$address() {
        return vkDestroyDescriptorUpdateTemplateKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyDescriptorUpdateTemplateKHR(MemorySegment device, MemorySegment descriptorUpdateTemplate, MemorySegment pAllocator) {
        var mh$ = vkDestroyDescriptorUpdateTemplateKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyDescriptorUpdateTemplateKHR", device, descriptorUpdateTemplate, pAllocator);
            }
            mh$.invokeExact(device, descriptorUpdateTemplate, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkUpdateDescriptorSetWithTemplateKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkUpdateDescriptorSetWithTemplateKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkUpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData)
     * }
     */
    public static FunctionDescriptor vkUpdateDescriptorSetWithTemplateKHR$descriptor() {
        return vkUpdateDescriptorSetWithTemplateKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkUpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData)
     * }
     */
    public static MethodHandle vkUpdateDescriptorSetWithTemplateKHR$handle() {
        return vkUpdateDescriptorSetWithTemplateKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkUpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData)
     * }
     */
    public static MemorySegment vkUpdateDescriptorSetWithTemplateKHR$address() {
        return vkUpdateDescriptorSetWithTemplateKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkUpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData)
     * }
     */
    public static void vkUpdateDescriptorSetWithTemplateKHR(MemorySegment device, MemorySegment descriptorSet, MemorySegment descriptorUpdateTemplate, MemorySegment pData) {
        var mh$ = vkUpdateDescriptorSetWithTemplateKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkUpdateDescriptorSetWithTemplateKHR", device, descriptorSet, descriptorUpdateTemplate, pData);
            }
            mh$.invokeExact(device, descriptorSet, descriptorUpdateTemplate, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateRenderPass2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateRenderPass2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static FunctionDescriptor vkCreateRenderPass2KHR$descriptor() {
        return vkCreateRenderPass2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static MethodHandle vkCreateRenderPass2KHR$handle() {
        return vkCreateRenderPass2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static MemorySegment vkCreateRenderPass2KHR$address() {
        return vkCreateRenderPass2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass)
     * }
     */
    public static int vkCreateRenderPass2KHR(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pRenderPass) {
        var mh$ = vkCreateRenderPass2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateRenderPass2KHR", device, pCreateInfo, pAllocator, pRenderPass);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pRenderPass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBeginRenderPass2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBeginRenderPass2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo)
     * }
     */
    public static FunctionDescriptor vkCmdBeginRenderPass2KHR$descriptor() {
        return vkCmdBeginRenderPass2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo)
     * }
     */
    public static MethodHandle vkCmdBeginRenderPass2KHR$handle() {
        return vkCmdBeginRenderPass2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo)
     * }
     */
    public static MemorySegment vkCmdBeginRenderPass2KHR$address() {
        return vkCmdBeginRenderPass2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo)
     * }
     */
    public static void vkCmdBeginRenderPass2KHR(MemorySegment commandBuffer, MemorySegment pRenderPassBegin, MemorySegment pSubpassBeginInfo) {
        var mh$ = vkCmdBeginRenderPass2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBeginRenderPass2KHR", commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
            }
            mh$.invokeExact(commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdNextSubpass2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdNextSubpass2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static FunctionDescriptor vkCmdNextSubpass2KHR$descriptor() {
        return vkCmdNextSubpass2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static MethodHandle vkCmdNextSubpass2KHR$handle() {
        return vkCmdNextSubpass2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static MemorySegment vkCmdNextSubpass2KHR$address() {
        return vkCmdNextSubpass2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static void vkCmdNextSubpass2KHR(MemorySegment commandBuffer, MemorySegment pSubpassBeginInfo, MemorySegment pSubpassEndInfo) {
        var mh$ = vkCmdNextSubpass2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdNextSubpass2KHR", commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
            }
            mh$.invokeExact(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdEndRenderPass2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdEndRenderPass2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static FunctionDescriptor vkCmdEndRenderPass2KHR$descriptor() {
        return vkCmdEndRenderPass2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static MethodHandle vkCmdEndRenderPass2KHR$handle() {
        return vkCmdEndRenderPass2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static MemorySegment vkCmdEndRenderPass2KHR$address() {
        return vkCmdEndRenderPass2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo)
     * }
     */
    public static void vkCmdEndRenderPass2KHR(MemorySegment commandBuffer, MemorySegment pSubpassEndInfo) {
        var mh$ = vkCmdEndRenderPass2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdEndRenderPass2KHR", commandBuffer, pSubpassEndInfo);
            }
            mh$.invokeExact(commandBuffer, pSubpassEndInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetSwapchainStatusKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetSwapchainStatusKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain)
     * }
     */
    public static FunctionDescriptor vkGetSwapchainStatusKHR$descriptor() {
        return vkGetSwapchainStatusKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain)
     * }
     */
    public static MethodHandle vkGetSwapchainStatusKHR$handle() {
        return vkGetSwapchainStatusKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain)
     * }
     */
    public static MemorySegment vkGetSwapchainStatusKHR$address() {
        return vkGetSwapchainStatusKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain)
     * }
     */
    public static int vkGetSwapchainStatusKHR(MemorySegment device, MemorySegment swapchain) {
        var mh$ = vkGetSwapchainStatusKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetSwapchainStatusKHR", device, swapchain);
            }
            return (int)mh$.invokeExact(device, swapchain);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkExternalFenceHandleTypeFlags VkExternalFenceHandleTypeFlagsKHR
     * }
     */
    public static final OfInt VkExternalFenceHandleTypeFlagsKHR = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkExternalFenceFeatureFlags VkExternalFenceFeatureFlagsKHR
     * }
     */
    public static final OfInt VkExternalFenceFeatureFlagsKHR = vulkan_h.C_INT;

    private static class vkGetPhysicalDeviceExternalFencePropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceExternalFencePropertiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceExternalFencePropertiesKHR$descriptor() {
        return vkGetPhysicalDeviceExternalFencePropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceExternalFencePropertiesKHR$handle() {
        return vkGetPhysicalDeviceExternalFencePropertiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceExternalFencePropertiesKHR$address() {
        return vkGetPhysicalDeviceExternalFencePropertiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties)
     * }
     */
    public static void vkGetPhysicalDeviceExternalFencePropertiesKHR(MemorySegment physicalDevice, MemorySegment pExternalFenceInfo, MemorySegment pExternalFenceProperties) {
        var mh$ = vkGetPhysicalDeviceExternalFencePropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceExternalFencePropertiesKHR", physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
            }
            mh$.invokeExact(physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkFenceImportFlags VkFenceImportFlagsKHR
     * }
     */
    public static final OfInt VkFenceImportFlagsKHR = vulkan_h.C_INT;

    private static class vkImportFenceFdKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkImportFenceFdKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo)
     * }
     */
    public static FunctionDescriptor vkImportFenceFdKHR$descriptor() {
        return vkImportFenceFdKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo)
     * }
     */
    public static MethodHandle vkImportFenceFdKHR$handle() {
        return vkImportFenceFdKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo)
     * }
     */
    public static MemorySegment vkImportFenceFdKHR$address() {
        return vkImportFenceFdKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo)
     * }
     */
    public static int vkImportFenceFdKHR(MemorySegment device, MemorySegment pImportFenceFdInfo) {
        var mh$ = vkImportFenceFdKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkImportFenceFdKHR", device, pImportFenceFdInfo);
            }
            return (int)mh$.invokeExact(device, pImportFenceFdInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetFenceFdKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetFenceFdKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static FunctionDescriptor vkGetFenceFdKHR$descriptor() {
        return vkGetFenceFdKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static MethodHandle vkGetFenceFdKHR$handle() {
        return vkGetFenceFdKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static MemorySegment vkGetFenceFdKHR$address() {
        return vkGetFenceFdKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd)
     * }
     */
    public static int vkGetFenceFdKHR(MemorySegment device, MemorySegment pGetFdInfo, MemorySegment pFd) {
        var mh$ = vkGetFenceFdKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetFenceFdKHR", device, pGetFdInfo, pFd);
            }
            return (int)mh$.invokeExact(device, pGetFdInfo, pFd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_BEGIN_RANGE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_BEGIN_RANGE_KHR = 0
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_BEGIN_RANGE_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_BEGIN_RANGE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_END_RANGE_KHR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_END_RANGE_KHR = 10
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_END_RANGE_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_END_RANGE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_RANGE_SIZE_KHR = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_RANGE_SIZE_KHR = 11
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_RANGE_SIZE_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_RANGE_SIZE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterUnitKHR.VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR() {
        return VK_PERFORMANCE_COUNTER_UNIT_MAX_ENUM_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR() {
        return VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR() {
        return VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR() {
        return VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR;
    }
    private static final int VK_QUERY_SCOPE_COMMAND_BUFFER_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_QUERY_SCOPE_COMMAND_BUFFER_KHR = 0
     * }
     */
    public static int VK_QUERY_SCOPE_COMMAND_BUFFER_KHR() {
        return VK_QUERY_SCOPE_COMMAND_BUFFER_KHR;
    }
    private static final int VK_QUERY_SCOPE_RENDER_PASS_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_QUERY_SCOPE_RENDER_PASS_KHR = 1
     * }
     */
    public static int VK_QUERY_SCOPE_RENDER_PASS_KHR() {
        return VK_QUERY_SCOPE_RENDER_PASS_KHR;
    }
    private static final int VK_QUERY_SCOPE_COMMAND_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_QUERY_SCOPE_COMMAND_KHR = 2
     * }
     */
    public static int VK_QUERY_SCOPE_COMMAND_KHR() {
        return VK_QUERY_SCOPE_COMMAND_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_SCOPE_BEGIN_RANGE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_PERFORMANCE_COUNTER_SCOPE_BEGIN_RANGE_KHR = 0
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_SCOPE_BEGIN_RANGE_KHR() {
        return VK_PERFORMANCE_COUNTER_SCOPE_BEGIN_RANGE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_SCOPE_END_RANGE_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_PERFORMANCE_COUNTER_SCOPE_END_RANGE_KHR = 2
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_SCOPE_END_RANGE_KHR() {
        return VK_PERFORMANCE_COUNTER_SCOPE_END_RANGE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_SCOPE_RANGE_SIZE_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_PERFORMANCE_COUNTER_SCOPE_RANGE_SIZE_KHR = 3
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_SCOPE_RANGE_SIZE_KHR() {
        return VK_PERFORMANCE_COUNTER_SCOPE_RANGE_SIZE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterScopeKHR.VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR() {
        return VK_PERFORMANCE_COUNTER_SCOPE_MAX_ENUM_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_BEGIN_RANGE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_BEGIN_RANGE_KHR = 0
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_BEGIN_RANGE_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_BEGIN_RANGE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_END_RANGE_KHR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_END_RANGE_KHR = 5
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_END_RANGE_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_END_RANGE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_RANGE_SIZE_KHR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_RANGE_SIZE_KHR = 6
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_RANGE_SIZE_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_RANGE_SIZE_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterStorageKHR.VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR() {
        return VK_PERFORMANCE_COUNTER_STORAGE_MAX_ENUM_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterDescriptionFlagBitsKHR.VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = 1
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR() {
        return VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterDescriptionFlagBitsKHR.VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = 2
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR() {
        return VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR;
    }
    private static final int VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPerformanceCounterDescriptionFlagBitsKHR.VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR() {
        return VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_MAX_ENUM_KHR;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPerformanceCounterDescriptionFlagsKHR
     * }
     */
    public static final OfInt VkPerformanceCounterDescriptionFlagsKHR = vulkan_h.C_INT;
    private static final int VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkAcquireProfilingLockFlagBitsKHR.VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR() {
        return VK_ACQUIRE_PROFILING_LOCK_FLAG_BITS_MAX_ENUM_KHR;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkAcquireProfilingLockFlagsKHR
     * }
     */
    public static final OfInt VkAcquireProfilingLockFlagsKHR = vulkan_h.C_INT;

    private static class vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions)
     * }
     */
    public static FunctionDescriptor vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR$descriptor() {
        return vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions)
     * }
     */
    public static MethodHandle vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR$handle() {
        return vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions)
     * }
     */
    public static MemorySegment vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR$address() {
        return vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions)
     * }
     */
    public static int vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(MemorySegment physicalDevice, int queueFamilyIndex, MemorySegment pCounterCount, MemorySegment pCounters, MemorySegment pCounterDescriptions) {
        var mh$ = vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
            }
            return (int)mh$.invokeExact(physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR$descriptor() {
        return vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR$handle() {
        return vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR$address() {
        return vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses)
     * }
     */
    public static void vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(MemorySegment physicalDevice, MemorySegment pPerformanceQueryCreateInfo, MemorySegment pNumPasses) {
        var mh$ = vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
            }
            mh$.invokeExact(physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkAcquireProfilingLockKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkAcquireProfilingLockKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkAcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo)
     * }
     */
    public static FunctionDescriptor vkAcquireProfilingLockKHR$descriptor() {
        return vkAcquireProfilingLockKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkAcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo)
     * }
     */
    public static MethodHandle vkAcquireProfilingLockKHR$handle() {
        return vkAcquireProfilingLockKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkAcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo)
     * }
     */
    public static MemorySegment vkAcquireProfilingLockKHR$address() {
        return vkAcquireProfilingLockKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkAcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo)
     * }
     */
    public static int vkAcquireProfilingLockKHR(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkAcquireProfilingLockKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkAcquireProfilingLockKHR", device, pInfo);
            }
            return (int)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkReleaseProfilingLockKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkReleaseProfilingLockKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkReleaseProfilingLockKHR(VkDevice device)
     * }
     */
    public static FunctionDescriptor vkReleaseProfilingLockKHR$descriptor() {
        return vkReleaseProfilingLockKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkReleaseProfilingLockKHR(VkDevice device)
     * }
     */
    public static MethodHandle vkReleaseProfilingLockKHR$handle() {
        return vkReleaseProfilingLockKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkReleaseProfilingLockKHR(VkDevice device)
     * }
     */
    public static MemorySegment vkReleaseProfilingLockKHR$address() {
        return vkReleaseProfilingLockKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkReleaseProfilingLockKHR(VkDevice device)
     * }
     */
    public static void vkReleaseProfilingLockKHR(MemorySegment device) {
        var mh$ = vkReleaseProfilingLockKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkReleaseProfilingLockKHR", device);
            }
            mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceSurfaceCapabilities2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSurfaceCapabilities2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSurfaceCapabilities2KHR$descriptor() {
        return vkGetPhysicalDeviceSurfaceCapabilities2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSurfaceCapabilities2KHR$handle() {
        return vkGetPhysicalDeviceSurfaceCapabilities2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSurfaceCapabilities2KHR$address() {
        return vkGetPhysicalDeviceSurfaceCapabilities2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities)
     * }
     */
    public static int vkGetPhysicalDeviceSurfaceCapabilities2KHR(MemorySegment physicalDevice, MemorySegment pSurfaceInfo, MemorySegment pSurfaceCapabilities) {
        var mh$ = vkGetPhysicalDeviceSurfaceCapabilities2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSurfaceCapabilities2KHR", physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
            }
            return (int)mh$.invokeExact(physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceSurfaceFormats2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSurfaceFormats2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSurfaceFormats2KHR$descriptor() {
        return vkGetPhysicalDeviceSurfaceFormats2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSurfaceFormats2KHR$handle() {
        return vkGetPhysicalDeviceSurfaceFormats2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSurfaceFormats2KHR$address() {
        return vkGetPhysicalDeviceSurfaceFormats2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats)
     * }
     */
    public static int vkGetPhysicalDeviceSurfaceFormats2KHR(MemorySegment physicalDevice, MemorySegment pSurfaceInfo, MemorySegment pSurfaceFormatCount, MemorySegment pSurfaceFormats) {
        var mh$ = vkGetPhysicalDeviceSurfaceFormats2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSurfaceFormats2KHR", physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
            }
            return (int)mh$.invokeExact(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceDisplayProperties2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceDisplayProperties2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceDisplayProperties2KHR$descriptor() {
        return vkGetPhysicalDeviceDisplayProperties2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceDisplayProperties2KHR$handle() {
        return vkGetPhysicalDeviceDisplayProperties2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceDisplayProperties2KHR$address() {
        return vkGetPhysicalDeviceDisplayProperties2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties)
     * }
     */
    public static int vkGetPhysicalDeviceDisplayProperties2KHR(MemorySegment physicalDevice, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceDisplayProperties2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceDisplayProperties2KHR", physicalDevice, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceDisplayPlaneProperties2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceDisplayPlaneProperties2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceDisplayPlaneProperties2KHR$descriptor() {
        return vkGetPhysicalDeviceDisplayPlaneProperties2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceDisplayPlaneProperties2KHR$handle() {
        return vkGetPhysicalDeviceDisplayPlaneProperties2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceDisplayPlaneProperties2KHR$address() {
        return vkGetPhysicalDeviceDisplayPlaneProperties2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties)
     * }
     */
    public static int vkGetPhysicalDeviceDisplayPlaneProperties2KHR(MemorySegment physicalDevice, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetPhysicalDeviceDisplayPlaneProperties2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceDisplayPlaneProperties2KHR", physicalDevice, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDisplayModeProperties2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDisplayModeProperties2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetDisplayModeProperties2KHR$descriptor() {
        return vkGetDisplayModeProperties2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties)
     * }
     */
    public static MethodHandle vkGetDisplayModeProperties2KHR$handle() {
        return vkGetDisplayModeProperties2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties)
     * }
     */
    public static MemorySegment vkGetDisplayModeProperties2KHR$address() {
        return vkGetDisplayModeProperties2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties)
     * }
     */
    public static int vkGetDisplayModeProperties2KHR(MemorySegment physicalDevice, MemorySegment display, MemorySegment pPropertyCount, MemorySegment pProperties) {
        var mh$ = vkGetDisplayModeProperties2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDisplayModeProperties2KHR", physicalDevice, display, pPropertyCount, pProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, display, pPropertyCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDisplayPlaneCapabilities2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDisplayPlaneCapabilities2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities)
     * }
     */
    public static FunctionDescriptor vkGetDisplayPlaneCapabilities2KHR$descriptor() {
        return vkGetDisplayPlaneCapabilities2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities)
     * }
     */
    public static MethodHandle vkGetDisplayPlaneCapabilities2KHR$handle() {
        return vkGetDisplayPlaneCapabilities2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities)
     * }
     */
    public static MemorySegment vkGetDisplayPlaneCapabilities2KHR$address() {
        return vkGetDisplayPlaneCapabilities2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities)
     * }
     */
    public static int vkGetDisplayPlaneCapabilities2KHR(MemorySegment physicalDevice, MemorySegment pDisplayPlaneInfo, MemorySegment pCapabilities) {
        var mh$ = vkGetDisplayPlaneCapabilities2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDisplayPlaneCapabilities2KHR", physicalDevice, pDisplayPlaneInfo, pCapabilities);
            }
            return (int)mh$.invokeExact(physicalDevice, pDisplayPlaneInfo, pCapabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageMemoryRequirements2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetImageMemoryRequirements2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetImageMemoryRequirements2KHR$descriptor() {
        return vkGetImageMemoryRequirements2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetImageMemoryRequirements2KHR$handle() {
        return vkGetImageMemoryRequirements2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetImageMemoryRequirements2KHR$address() {
        return vkGetImageMemoryRequirements2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static void vkGetImageMemoryRequirements2KHR(MemorySegment device, MemorySegment pInfo, MemorySegment pMemoryRequirements) {
        var mh$ = vkGetImageMemoryRequirements2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageMemoryRequirements2KHR", device, pInfo, pMemoryRequirements);
            }
            mh$.invokeExact(device, pInfo, pMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetBufferMemoryRequirements2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetBufferMemoryRequirements2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetBufferMemoryRequirements2KHR$descriptor() {
        return vkGetBufferMemoryRequirements2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetBufferMemoryRequirements2KHR$handle() {
        return vkGetBufferMemoryRequirements2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetBufferMemoryRequirements2KHR$address() {
        return vkGetBufferMemoryRequirements2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements)
     * }
     */
    public static void vkGetBufferMemoryRequirements2KHR(MemorySegment device, MemorySegment pInfo, MemorySegment pMemoryRequirements) {
        var mh$ = vkGetBufferMemoryRequirements2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetBufferMemoryRequirements2KHR", device, pInfo, pMemoryRequirements);
            }
            mh$.invokeExact(device, pInfo, pMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageSparseMemoryRequirements2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetImageSparseMemoryRequirements2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements)
     * }
     */
    public static FunctionDescriptor vkGetImageSparseMemoryRequirements2KHR$descriptor() {
        return vkGetImageSparseMemoryRequirements2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements)
     * }
     */
    public static MethodHandle vkGetImageSparseMemoryRequirements2KHR$handle() {
        return vkGetImageSparseMemoryRequirements2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements)
     * }
     */
    public static MemorySegment vkGetImageSparseMemoryRequirements2KHR$address() {
        return vkGetImageSparseMemoryRequirements2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements)
     * }
     */
    public static void vkGetImageSparseMemoryRequirements2KHR(MemorySegment device, MemorySegment pInfo, MemorySegment pSparseMemoryRequirementCount, MemorySegment pSparseMemoryRequirements) {
        var mh$ = vkGetImageSparseMemoryRequirements2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageSparseMemoryRequirements2KHR", device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
            }
            mh$.invokeExact(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkSamplerYcbcrConversion VkSamplerYcbcrConversionKHR
     * }
     */
    public static final AddressLayout VkSamplerYcbcrConversionKHR = vulkan_h.C_POINTER;

    private static class vkCreateSamplerYcbcrConversionKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateSamplerYcbcrConversionKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion)
     * }
     */
    public static FunctionDescriptor vkCreateSamplerYcbcrConversionKHR$descriptor() {
        return vkCreateSamplerYcbcrConversionKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion)
     * }
     */
    public static MethodHandle vkCreateSamplerYcbcrConversionKHR$handle() {
        return vkCreateSamplerYcbcrConversionKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion)
     * }
     */
    public static MemorySegment vkCreateSamplerYcbcrConversionKHR$address() {
        return vkCreateSamplerYcbcrConversionKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion)
     * }
     */
    public static int vkCreateSamplerYcbcrConversionKHR(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pYcbcrConversion) {
        var mh$ = vkCreateSamplerYcbcrConversionKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateSamplerYcbcrConversionKHR", device, pCreateInfo, pAllocator, pYcbcrConversion);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pYcbcrConversion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroySamplerYcbcrConversionKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroySamplerYcbcrConversionKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroySamplerYcbcrConversionKHR$descriptor() {
        return vkDestroySamplerYcbcrConversionKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroySamplerYcbcrConversionKHR$handle() {
        return vkDestroySamplerYcbcrConversionKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroySamplerYcbcrConversionKHR$address() {
        return vkDestroySamplerYcbcrConversionKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroySamplerYcbcrConversionKHR(MemorySegment device, MemorySegment ycbcrConversion, MemorySegment pAllocator) {
        var mh$ = vkDestroySamplerYcbcrConversionKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroySamplerYcbcrConversionKHR", device, ycbcrConversion, pAllocator);
            }
            mh$.invokeExact(device, ycbcrConversion, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBindBufferMemory2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkBindBufferMemory2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos)
     * }
     */
    public static FunctionDescriptor vkBindBufferMemory2KHR$descriptor() {
        return vkBindBufferMemory2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos)
     * }
     */
    public static MethodHandle vkBindBufferMemory2KHR$handle() {
        return vkBindBufferMemory2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos)
     * }
     */
    public static MemorySegment vkBindBufferMemory2KHR$address() {
        return vkBindBufferMemory2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkBindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos)
     * }
     */
    public static int vkBindBufferMemory2KHR(MemorySegment device, int bindInfoCount, MemorySegment pBindInfos) {
        var mh$ = vkBindBufferMemory2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBindBufferMemory2KHR", device, bindInfoCount, pBindInfos);
            }
            return (int)mh$.invokeExact(device, bindInfoCount, pBindInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkBindImageMemory2KHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkBindImageMemory2KHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos)
     * }
     */
    public static FunctionDescriptor vkBindImageMemory2KHR$descriptor() {
        return vkBindImageMemory2KHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos)
     * }
     */
    public static MethodHandle vkBindImageMemory2KHR$handle() {
        return vkBindImageMemory2KHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos)
     * }
     */
    public static MemorySegment vkBindImageMemory2KHR$address() {
        return vkBindImageMemory2KHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkBindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos)
     * }
     */
    public static int vkBindImageMemory2KHR(MemorySegment device, int bindInfoCount, MemorySegment pBindInfos) {
        var mh$ = vkBindImageMemory2KHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkBindImageMemory2KHR", device, bindInfoCount, pBindInfos);
            }
            return (int)mh$.invokeExact(device, bindInfoCount, pBindInfos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDescriptorSetLayoutSupportKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDescriptorSetLayoutSupportKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport)
     * }
     */
    public static FunctionDescriptor vkGetDescriptorSetLayoutSupportKHR$descriptor() {
        return vkGetDescriptorSetLayoutSupportKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport)
     * }
     */
    public static MethodHandle vkGetDescriptorSetLayoutSupportKHR$handle() {
        return vkGetDescriptorSetLayoutSupportKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport)
     * }
     */
    public static MemorySegment vkGetDescriptorSetLayoutSupportKHR$address() {
        return vkGetDescriptorSetLayoutSupportKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport)
     * }
     */
    public static void vkGetDescriptorSetLayoutSupportKHR(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pSupport) {
        var mh$ = vkGetDescriptorSetLayoutSupportKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDescriptorSetLayoutSupportKHR", device, pCreateInfo, pSupport);
            }
            mh$.invokeExact(device, pCreateInfo, pSupport);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawIndirectCountKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndirectCountKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndirectCountKHR$descriptor() {
        return vkCmdDrawIndirectCountKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawIndirectCountKHR$handle() {
        return vkCmdDrawIndirectCountKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawIndirectCountKHR$address() {
        return vkCmdDrawIndirectCountKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawIndirectCountKHR(MemorySegment commandBuffer, MemorySegment buffer, long offset, MemorySegment countBuffer, long countBufferOffset, int maxDrawCount, int stride) {
        var mh$ = vkCmdDrawIndirectCountKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndirectCountKHR", commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawIndexedIndirectCountKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndexedIndirectCountKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndexedIndirectCountKHR$descriptor() {
        return vkCmdDrawIndexedIndirectCountKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawIndexedIndirectCountKHR$handle() {
        return vkCmdDrawIndexedIndirectCountKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawIndexedIndirectCountKHR$address() {
        return vkCmdDrawIndexedIndirectCountKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawIndexedIndirectCountKHR(MemorySegment commandBuffer, MemorySegment buffer, long offset, MemorySegment countBuffer, long countBufferOffset, int maxDrawCount, int stride) {
        var mh$ = vkCmdDrawIndexedIndirectCountKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndexedIndirectCountKHR", commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkResolveModeFlags VkResolveModeFlagsKHR
     * }
     */
    public static final OfInt VkResolveModeFlagsKHR = vulkan_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef VkSemaphoreWaitFlags VkSemaphoreWaitFlagsKHR
     * }
     */
    public static final OfInt VkSemaphoreWaitFlagsKHR = vulkan_h.C_INT;

    private static class vkGetSemaphoreCounterValueKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetSemaphoreCounterValueKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue)
     * }
     */
    public static FunctionDescriptor vkGetSemaphoreCounterValueKHR$descriptor() {
        return vkGetSemaphoreCounterValueKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue)
     * }
     */
    public static MethodHandle vkGetSemaphoreCounterValueKHR$handle() {
        return vkGetSemaphoreCounterValueKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue)
     * }
     */
    public static MemorySegment vkGetSemaphoreCounterValueKHR$address() {
        return vkGetSemaphoreCounterValueKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue)
     * }
     */
    public static int vkGetSemaphoreCounterValueKHR(MemorySegment device, MemorySegment semaphore, MemorySegment pValue) {
        var mh$ = vkGetSemaphoreCounterValueKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetSemaphoreCounterValueKHR", device, semaphore, pValue);
            }
            return (int)mh$.invokeExact(device, semaphore, pValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkWaitSemaphoresKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkWaitSemaphoresKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout)
     * }
     */
    public static FunctionDescriptor vkWaitSemaphoresKHR$descriptor() {
        return vkWaitSemaphoresKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout)
     * }
     */
    public static MethodHandle vkWaitSemaphoresKHR$handle() {
        return vkWaitSemaphoresKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout)
     * }
     */
    public static MemorySegment vkWaitSemaphoresKHR$address() {
        return vkWaitSemaphoresKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkWaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout)
     * }
     */
    public static int vkWaitSemaphoresKHR(MemorySegment device, MemorySegment pWaitInfo, long timeout) {
        var mh$ = vkWaitSemaphoresKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkWaitSemaphoresKHR", device, pWaitInfo, timeout);
            }
            return (int)mh$.invokeExact(device, pWaitInfo, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkSignalSemaphoreKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkSignalSemaphoreKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo)
     * }
     */
    public static FunctionDescriptor vkSignalSemaphoreKHR$descriptor() {
        return vkSignalSemaphoreKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo)
     * }
     */
    public static MethodHandle vkSignalSemaphoreKHR$handle() {
        return vkSignalSemaphoreKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo)
     * }
     */
    public static MemorySegment vkSignalSemaphoreKHR$address() {
        return vkSignalSemaphoreKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkSignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo)
     * }
     */
    public static int vkSignalSemaphoreKHR(MemorySegment device, MemorySegment pSignalInfo) {
        var mh$ = vkSignalSemaphoreKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkSignalSemaphoreKHR", device, pSignalInfo);
            }
            return (int)mh$.invokeExact(device, pSignalInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetBufferDeviceAddressKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetBufferDeviceAddressKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetBufferDeviceAddressKHR$descriptor() {
        return vkGetBufferDeviceAddressKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MethodHandle vkGetBufferDeviceAddressKHR$handle() {
        return vkGetBufferDeviceAddressKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MemorySegment vkGetBufferDeviceAddressKHR$address() {
        return vkGetBufferDeviceAddressKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkDeviceAddress vkGetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static long vkGetBufferDeviceAddressKHR(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetBufferDeviceAddressKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetBufferDeviceAddressKHR", device, pInfo);
            }
            return (long)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetBufferOpaqueCaptureAddressKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetBufferOpaqueCaptureAddressKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t vkGetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetBufferOpaqueCaptureAddressKHR$descriptor() {
        return vkGetBufferOpaqueCaptureAddressKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t vkGetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MethodHandle vkGetBufferOpaqueCaptureAddressKHR$handle() {
        return vkGetBufferOpaqueCaptureAddressKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t vkGetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static MemorySegment vkGetBufferOpaqueCaptureAddressKHR$address() {
        return vkGetBufferOpaqueCaptureAddressKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t vkGetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo)
     * }
     */
    public static long vkGetBufferOpaqueCaptureAddressKHR(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetBufferOpaqueCaptureAddressKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetBufferOpaqueCaptureAddressKHR", device, pInfo);
            }
            return (long)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetDeviceMemoryOpaqueCaptureAddressKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetDeviceMemoryOpaqueCaptureAddressKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetDeviceMemoryOpaqueCaptureAddressKHR$descriptor() {
        return vkGetDeviceMemoryOpaqueCaptureAddressKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo)
     * }
     */
    public static MethodHandle vkGetDeviceMemoryOpaqueCaptureAddressKHR$handle() {
        return vkGetDeviceMemoryOpaqueCaptureAddressKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo)
     * }
     */
    public static MemorySegment vkGetDeviceMemoryOpaqueCaptureAddressKHR$address() {
        return vkGetDeviceMemoryOpaqueCaptureAddressKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t vkGetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo)
     * }
     */
    public static long vkGetDeviceMemoryOpaqueCaptureAddressKHR(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetDeviceMemoryOpaqueCaptureAddressKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetDeviceMemoryOpaqueCaptureAddressKHR", device, pInfo);
            }
            return (long)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineExecutableStatisticFormatKHR.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR = 0
     * }
     */
    public static int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR() {
        return VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR;
    }
    private static final int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineExecutableStatisticFormatKHR.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR = 1
     * }
     */
    public static int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR() {
        return VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR;
    }
    private static final int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineExecutableStatisticFormatKHR.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR = 2
     * }
     */
    public static int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR() {
        return VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR;
    }
    private static final int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineExecutableStatisticFormatKHR.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR = 3
     * }
     */
    public static int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR() {
        return VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR;
    }
    private static final int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BEGIN_RANGE_KHR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineExecutableStatisticFormatKHR.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BEGIN_RANGE_KHR = 0
     * }
     */
    public static int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BEGIN_RANGE_KHR() {
        return VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BEGIN_RANGE_KHR;
    }
    private static final int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_END_RANGE_KHR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineExecutableStatisticFormatKHR.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_END_RANGE_KHR = 3
     * }
     */
    public static int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_END_RANGE_KHR() {
        return VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_END_RANGE_KHR;
    }
    private static final int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_RANGE_SIZE_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineExecutableStatisticFormatKHR.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_RANGE_SIZE_KHR = 4
     * }
     */
    public static int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_RANGE_SIZE_KHR() {
        return VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_RANGE_SIZE_KHR;
    }
    private static final int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkPipelineExecutableStatisticFormatKHR.VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR = 2147483647
     * }
     */
    public static int VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR() {
        return VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_MAX_ENUM_KHR;
    }

    private static class vkGetPipelineExecutablePropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPipelineExecutablePropertiesKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties)
     * }
     */
    public static FunctionDescriptor vkGetPipelineExecutablePropertiesKHR$descriptor() {
        return vkGetPipelineExecutablePropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties)
     * }
     */
    public static MethodHandle vkGetPipelineExecutablePropertiesKHR$handle() {
        return vkGetPipelineExecutablePropertiesKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties)
     * }
     */
    public static MemorySegment vkGetPipelineExecutablePropertiesKHR$address() {
        return vkGetPipelineExecutablePropertiesKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties)
     * }
     */
    public static int vkGetPipelineExecutablePropertiesKHR(MemorySegment device, MemorySegment pPipelineInfo, MemorySegment pExecutableCount, MemorySegment pProperties) {
        var mh$ = vkGetPipelineExecutablePropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPipelineExecutablePropertiesKHR", device, pPipelineInfo, pExecutableCount, pProperties);
            }
            return (int)mh$.invokeExact(device, pPipelineInfo, pExecutableCount, pProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPipelineExecutableStatisticsKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPipelineExecutableStatisticsKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics)
     * }
     */
    public static FunctionDescriptor vkGetPipelineExecutableStatisticsKHR$descriptor() {
        return vkGetPipelineExecutableStatisticsKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics)
     * }
     */
    public static MethodHandle vkGetPipelineExecutableStatisticsKHR$handle() {
        return vkGetPipelineExecutableStatisticsKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics)
     * }
     */
    public static MemorySegment vkGetPipelineExecutableStatisticsKHR$address() {
        return vkGetPipelineExecutableStatisticsKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics)
     * }
     */
    public static int vkGetPipelineExecutableStatisticsKHR(MemorySegment device, MemorySegment pExecutableInfo, MemorySegment pStatisticCount, MemorySegment pStatistics) {
        var mh$ = vkGetPipelineExecutableStatisticsKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPipelineExecutableStatisticsKHR", device, pExecutableInfo, pStatisticCount, pStatistics);
            }
            return (int)mh$.invokeExact(device, pExecutableInfo, pStatisticCount, pStatistics);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPipelineExecutableInternalRepresentationsKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPipelineExecutableInternalRepresentationsKHR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations)
     * }
     */
    public static FunctionDescriptor vkGetPipelineExecutableInternalRepresentationsKHR$descriptor() {
        return vkGetPipelineExecutableInternalRepresentationsKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations)
     * }
     */
    public static MethodHandle vkGetPipelineExecutableInternalRepresentationsKHR$handle() {
        return vkGetPipelineExecutableInternalRepresentationsKHR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations)
     * }
     */
    public static MemorySegment vkGetPipelineExecutableInternalRepresentationsKHR$address() {
        return vkGetPipelineExecutableInternalRepresentationsKHR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations)
     * }
     */
    public static int vkGetPipelineExecutableInternalRepresentationsKHR(MemorySegment device, MemorySegment pExecutableInfo, MemorySegment pInternalRepresentationCount, MemorySegment pInternalRepresentations) {
        var mh$ = vkGetPipelineExecutableInternalRepresentationsKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPipelineExecutableInternalRepresentationsKHR", device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
            }
            return (int)mh$.invokeExact(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkDebugReportCallbackEXT_T *VkDebugReportCallbackEXT
     * }
     */
    public static final AddressLayout VkDebugReportCallbackEXT = vulkan_h.C_POINTER;
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = (int)14L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = (int)15L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = (int)17L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = (int)18L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = (int)19L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = (int)20L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = (int)21L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = (int)22L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = (int)23L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = (int)24L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = (int)25L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = (int)26L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = (int)27L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = (int)28L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = (int)29L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = (int)30L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = (int)31L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = 31
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = (int)33L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = (int)1000156000L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = (int)1000085000L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = (int)1000165000L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = (int)28L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = (int)33L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = 33
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = (int)1000085000L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = 1000085000
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = (int)1000156000L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = 1000156000
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT = 0
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = (int)33L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT = 33
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = (int)34L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = 34
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT;
    }
    private static final int VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportObjectTypeEXT.VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT() {
        return VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT;
    }
    private static final int VK_DEBUG_REPORT_INFORMATION_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 1
     * }
     */
    public static int VK_DEBUG_REPORT_INFORMATION_BIT_EXT() {
        return VK_DEBUG_REPORT_INFORMATION_BIT_EXT;
    }
    private static final int VK_DEBUG_REPORT_WARNING_BIT_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_WARNING_BIT_EXT = 2
     * }
     */
    public static int VK_DEBUG_REPORT_WARNING_BIT_EXT() {
        return VK_DEBUG_REPORT_WARNING_BIT_EXT;
    }
    private static final int VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 4
     * }
     */
    public static int VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT() {
        return VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;
    }
    private static final int VK_DEBUG_REPORT_ERROR_BIT_EXT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_ERROR_BIT_EXT = 8
     * }
     */
    public static int VK_DEBUG_REPORT_ERROR_BIT_EXT() {
        return VK_DEBUG_REPORT_ERROR_BIT_EXT;
    }
    private static final int VK_DEBUG_REPORT_DEBUG_BIT_EXT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_DEBUG_BIT_EXT = 16
     * }
     */
    public static int VK_DEBUG_REPORT_DEBUG_BIT_EXT() {
        return VK_DEBUG_REPORT_DEBUG_BIT_EXT;
    }
    private static final int VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDebugReportFlagBitsEXT.VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkDebugReportFlagsEXT
     * }
     */
    public static final OfInt VkDebugReportFlagsEXT = vulkan_h.C_INT;

    private static class vkCreateDebugReportCallbackEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateDebugReportCallbackEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback)
     * }
     */
    public static FunctionDescriptor vkCreateDebugReportCallbackEXT$descriptor() {
        return vkCreateDebugReportCallbackEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback)
     * }
     */
    public static MethodHandle vkCreateDebugReportCallbackEXT$handle() {
        return vkCreateDebugReportCallbackEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback)
     * }
     */
    public static MemorySegment vkCreateDebugReportCallbackEXT$address() {
        return vkCreateDebugReportCallbackEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback)
     * }
     */
    public static int vkCreateDebugReportCallbackEXT(MemorySegment instance, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pCallback) {
        var mh$ = vkCreateDebugReportCallbackEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateDebugReportCallbackEXT", instance, pCreateInfo, pAllocator, pCallback);
            }
            return (int)mh$.invokeExact(instance, pCreateInfo, pAllocator, pCallback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyDebugReportCallbackEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyDebugReportCallbackEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyDebugReportCallbackEXT$descriptor() {
        return vkDestroyDebugReportCallbackEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyDebugReportCallbackEXT$handle() {
        return vkDestroyDebugReportCallbackEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyDebugReportCallbackEXT$address() {
        return vkDestroyDebugReportCallbackEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyDebugReportCallbackEXT(MemorySegment instance, MemorySegment callback, MemorySegment pAllocator) {
        var mh$ = vkDestroyDebugReportCallbackEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyDebugReportCallbackEXT", instance, callback, pAllocator);
            }
            mh$.invokeExact(instance, callback, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDebugReportMessageEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_LONG,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDebugReportMessageEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage)
     * }
     */
    public static FunctionDescriptor vkDebugReportMessageEXT$descriptor() {
        return vkDebugReportMessageEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage)
     * }
     */
    public static MethodHandle vkDebugReportMessageEXT$handle() {
        return vkDebugReportMessageEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage)
     * }
     */
    public static MemorySegment vkDebugReportMessageEXT$address() {
        return vkDebugReportMessageEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage)
     * }
     */
    public static void vkDebugReportMessageEXT(MemorySegment instance, int flags, int objectType, long object, long location, int messageCode, MemorySegment pLayerPrefix, MemorySegment pMessage) {
        var mh$ = vkDebugReportMessageEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDebugReportMessageEXT", instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
            }
            mh$.invokeExact(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_RASTERIZATION_ORDER_STRICT_AMD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_STRICT_AMD = 0
     * }
     */
    public static int VK_RASTERIZATION_ORDER_STRICT_AMD() {
        return VK_RASTERIZATION_ORDER_STRICT_AMD;
    }
    private static final int VK_RASTERIZATION_ORDER_RELAXED_AMD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_RELAXED_AMD = 1
     * }
     */
    public static int VK_RASTERIZATION_ORDER_RELAXED_AMD() {
        return VK_RASTERIZATION_ORDER_RELAXED_AMD;
    }
    private static final int VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD = 0
     * }
     */
    public static int VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD() {
        return VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD;
    }
    private static final int VK_RASTERIZATION_ORDER_END_RANGE_AMD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_END_RANGE_AMD = 1
     * }
     */
    public static int VK_RASTERIZATION_ORDER_END_RANGE_AMD() {
        return VK_RASTERIZATION_ORDER_END_RANGE_AMD;
    }
    private static final int VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD = 2
     * }
     */
    public static int VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD() {
        return VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD;
    }
    private static final int VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkRasterizationOrderAMD.VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 2147483647
     * }
     */
    public static int VK_RASTERIZATION_ORDER_MAX_ENUM_AMD() {
        return VK_RASTERIZATION_ORDER_MAX_ENUM_AMD;
    }

    private static class vkDebugMarkerSetObjectTagEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDebugMarkerSetObjectTagEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkDebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo)
     * }
     */
    public static FunctionDescriptor vkDebugMarkerSetObjectTagEXT$descriptor() {
        return vkDebugMarkerSetObjectTagEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkDebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo)
     * }
     */
    public static MethodHandle vkDebugMarkerSetObjectTagEXT$handle() {
        return vkDebugMarkerSetObjectTagEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkDebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo)
     * }
     */
    public static MemorySegment vkDebugMarkerSetObjectTagEXT$address() {
        return vkDebugMarkerSetObjectTagEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkDebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo)
     * }
     */
    public static int vkDebugMarkerSetObjectTagEXT(MemorySegment device, MemorySegment pTagInfo) {
        var mh$ = vkDebugMarkerSetObjectTagEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDebugMarkerSetObjectTagEXT", device, pTagInfo);
            }
            return (int)mh$.invokeExact(device, pTagInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDebugMarkerSetObjectNameEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDebugMarkerSetObjectNameEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkDebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo)
     * }
     */
    public static FunctionDescriptor vkDebugMarkerSetObjectNameEXT$descriptor() {
        return vkDebugMarkerSetObjectNameEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkDebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo)
     * }
     */
    public static MethodHandle vkDebugMarkerSetObjectNameEXT$handle() {
        return vkDebugMarkerSetObjectNameEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkDebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo)
     * }
     */
    public static MemorySegment vkDebugMarkerSetObjectNameEXT$address() {
        return vkDebugMarkerSetObjectNameEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkDebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo)
     * }
     */
    public static int vkDebugMarkerSetObjectNameEXT(MemorySegment device, MemorySegment pNameInfo) {
        var mh$ = vkDebugMarkerSetObjectNameEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDebugMarkerSetObjectNameEXT", device, pNameInfo);
            }
            return (int)mh$.invokeExact(device, pNameInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDebugMarkerBeginEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDebugMarkerBeginEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo)
     * }
     */
    public static FunctionDescriptor vkCmdDebugMarkerBeginEXT$descriptor() {
        return vkCmdDebugMarkerBeginEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo)
     * }
     */
    public static MethodHandle vkCmdDebugMarkerBeginEXT$handle() {
        return vkCmdDebugMarkerBeginEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo)
     * }
     */
    public static MemorySegment vkCmdDebugMarkerBeginEXT$address() {
        return vkCmdDebugMarkerBeginEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo)
     * }
     */
    public static void vkCmdDebugMarkerBeginEXT(MemorySegment commandBuffer, MemorySegment pMarkerInfo) {
        var mh$ = vkCmdDebugMarkerBeginEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDebugMarkerBeginEXT", commandBuffer, pMarkerInfo);
            }
            mh$.invokeExact(commandBuffer, pMarkerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDebugMarkerEndEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDebugMarkerEndEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer)
     * }
     */
    public static FunctionDescriptor vkCmdDebugMarkerEndEXT$descriptor() {
        return vkCmdDebugMarkerEndEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer)
     * }
     */
    public static MethodHandle vkCmdDebugMarkerEndEXT$handle() {
        return vkCmdDebugMarkerEndEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer)
     * }
     */
    public static MemorySegment vkCmdDebugMarkerEndEXT$address() {
        return vkCmdDebugMarkerEndEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer)
     * }
     */
    public static void vkCmdDebugMarkerEndEXT(MemorySegment commandBuffer) {
        var mh$ = vkCmdDebugMarkerEndEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDebugMarkerEndEXT", commandBuffer);
            }
            mh$.invokeExact(commandBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDebugMarkerInsertEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDebugMarkerInsertEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo)
     * }
     */
    public static FunctionDescriptor vkCmdDebugMarkerInsertEXT$descriptor() {
        return vkCmdDebugMarkerInsertEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo)
     * }
     */
    public static MethodHandle vkCmdDebugMarkerInsertEXT$handle() {
        return vkCmdDebugMarkerInsertEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo)
     * }
     */
    public static MemorySegment vkCmdDebugMarkerInsertEXT$address() {
        return vkCmdDebugMarkerInsertEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo)
     * }
     */
    public static void vkCmdDebugMarkerInsertEXT(MemorySegment commandBuffer, MemorySegment pMarkerInfo) {
        var mh$ = vkCmdDebugMarkerInsertEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDebugMarkerInsertEXT", commandBuffer, pMarkerInfo);
            }
            mh$.invokeExact(commandBuffer, pMarkerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineRasterizationStateStreamCreateFlagsEXT
     * }
     */
    public static final OfInt VkPipelineRasterizationStateStreamCreateFlagsEXT = vulkan_h.C_INT;

    private static class vkCmdBindTransformFeedbackBuffersEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBindTransformFeedbackBuffersEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes)
     * }
     */
    public static FunctionDescriptor vkCmdBindTransformFeedbackBuffersEXT$descriptor() {
        return vkCmdBindTransformFeedbackBuffersEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes)
     * }
     */
    public static MethodHandle vkCmdBindTransformFeedbackBuffersEXT$handle() {
        return vkCmdBindTransformFeedbackBuffersEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes)
     * }
     */
    public static MemorySegment vkCmdBindTransformFeedbackBuffersEXT$address() {
        return vkCmdBindTransformFeedbackBuffersEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes)
     * }
     */
    public static void vkCmdBindTransformFeedbackBuffersEXT(MemorySegment commandBuffer, int firstBinding, int bindingCount, MemorySegment pBuffers, MemorySegment pOffsets, MemorySegment pSizes) {
        var mh$ = vkCmdBindTransformFeedbackBuffersEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBindTransformFeedbackBuffersEXT", commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
            }
            mh$.invokeExact(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBeginTransformFeedbackEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBeginTransformFeedbackEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets)
     * }
     */
    public static FunctionDescriptor vkCmdBeginTransformFeedbackEXT$descriptor() {
        return vkCmdBeginTransformFeedbackEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets)
     * }
     */
    public static MethodHandle vkCmdBeginTransformFeedbackEXT$handle() {
        return vkCmdBeginTransformFeedbackEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets)
     * }
     */
    public static MemorySegment vkCmdBeginTransformFeedbackEXT$address() {
        return vkCmdBeginTransformFeedbackEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets)
     * }
     */
    public static void vkCmdBeginTransformFeedbackEXT(MemorySegment commandBuffer, int firstCounterBuffer, int counterBufferCount, MemorySegment pCounterBuffers, MemorySegment pCounterBufferOffsets) {
        var mh$ = vkCmdBeginTransformFeedbackEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBeginTransformFeedbackEXT", commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
            }
            mh$.invokeExact(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdEndTransformFeedbackEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdEndTransformFeedbackEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets)
     * }
     */
    public static FunctionDescriptor vkCmdEndTransformFeedbackEXT$descriptor() {
        return vkCmdEndTransformFeedbackEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets)
     * }
     */
    public static MethodHandle vkCmdEndTransformFeedbackEXT$handle() {
        return vkCmdEndTransformFeedbackEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets)
     * }
     */
    public static MemorySegment vkCmdEndTransformFeedbackEXT$address() {
        return vkCmdEndTransformFeedbackEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets)
     * }
     */
    public static void vkCmdEndTransformFeedbackEXT(MemorySegment commandBuffer, int firstCounterBuffer, int counterBufferCount, MemorySegment pCounterBuffers, MemorySegment pCounterBufferOffsets) {
        var mh$ = vkCmdEndTransformFeedbackEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdEndTransformFeedbackEXT", commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
            }
            mh$.invokeExact(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdBeginQueryIndexedEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBeginQueryIndexedEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index)
     * }
     */
    public static FunctionDescriptor vkCmdBeginQueryIndexedEXT$descriptor() {
        return vkCmdBeginQueryIndexedEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index)
     * }
     */
    public static MethodHandle vkCmdBeginQueryIndexedEXT$handle() {
        return vkCmdBeginQueryIndexedEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index)
     * }
     */
    public static MemorySegment vkCmdBeginQueryIndexedEXT$address() {
        return vkCmdBeginQueryIndexedEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index)
     * }
     */
    public static void vkCmdBeginQueryIndexedEXT(MemorySegment commandBuffer, MemorySegment queryPool, int query, int flags, int index) {
        var mh$ = vkCmdBeginQueryIndexedEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBeginQueryIndexedEXT", commandBuffer, queryPool, query, flags, index);
            }
            mh$.invokeExact(commandBuffer, queryPool, query, flags, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdEndQueryIndexedEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdEndQueryIndexedEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index)
     * }
     */
    public static FunctionDescriptor vkCmdEndQueryIndexedEXT$descriptor() {
        return vkCmdEndQueryIndexedEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index)
     * }
     */
    public static MethodHandle vkCmdEndQueryIndexedEXT$handle() {
        return vkCmdEndQueryIndexedEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index)
     * }
     */
    public static MemorySegment vkCmdEndQueryIndexedEXT$address() {
        return vkCmdEndQueryIndexedEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index)
     * }
     */
    public static void vkCmdEndQueryIndexedEXT(MemorySegment commandBuffer, MemorySegment queryPool, int query, int index) {
        var mh$ = vkCmdEndQueryIndexedEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdEndQueryIndexedEXT", commandBuffer, queryPool, query, index);
            }
            mh$.invokeExact(commandBuffer, queryPool, query, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawIndirectByteCountEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndirectByteCountEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndirectByteCountEXT$descriptor() {
        return vkCmdDrawIndirectByteCountEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride)
     * }
     */
    public static MethodHandle vkCmdDrawIndirectByteCountEXT$handle() {
        return vkCmdDrawIndirectByteCountEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride)
     * }
     */
    public static MemorySegment vkCmdDrawIndirectByteCountEXT$address() {
        return vkCmdDrawIndirectByteCountEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride)
     * }
     */
    public static void vkCmdDrawIndirectByteCountEXT(MemorySegment commandBuffer, int instanceCount, int firstInstance, MemorySegment counterBuffer, long counterBufferOffset, int counterOffset, int vertexStride) {
        var mh$ = vkCmdDrawIndirectByteCountEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndirectByteCountEXT", commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
            }
            mh$.invokeExact(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetImageViewHandleNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetImageViewHandleNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t vkGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetImageViewHandleNVX$descriptor() {
        return vkGetImageViewHandleNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t vkGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX *pInfo)
     * }
     */
    public static MethodHandle vkGetImageViewHandleNVX$handle() {
        return vkGetImageViewHandleNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t vkGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX *pInfo)
     * }
     */
    public static MemorySegment vkGetImageViewHandleNVX$address() {
        return vkGetImageViewHandleNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t vkGetImageViewHandleNVX(VkDevice device, const VkImageViewHandleInfoNVX *pInfo)
     * }
     */
    public static int vkGetImageViewHandleNVX(MemorySegment device, MemorySegment pInfo) {
        var mh$ = vkGetImageViewHandleNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetImageViewHandleNVX", device, pInfo);
            }
            return (int)mh$.invokeExact(device, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawIndirectCountAMD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndirectCountAMD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndirectCountAMD$descriptor() {
        return vkCmdDrawIndirectCountAMD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawIndirectCountAMD$handle() {
        return vkCmdDrawIndirectCountAMD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawIndirectCountAMD$address() {
        return vkCmdDrawIndirectCountAMD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawIndirectCountAMD(MemorySegment commandBuffer, MemorySegment buffer, long offset, MemorySegment countBuffer, long countBufferOffset, int maxDrawCount, int stride) {
        var mh$ = vkCmdDrawIndirectCountAMD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndirectCountAMD", commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdDrawIndexedIndirectCountAMD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_POINTER,
            vulkan_h.C_LONG,
            vulkan_h.C_INT,
            vulkan_h.C_INT
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdDrawIndexedIndirectCountAMD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static FunctionDescriptor vkCmdDrawIndexedIndirectCountAMD$descriptor() {
        return vkCmdDrawIndexedIndirectCountAMD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MethodHandle vkCmdDrawIndexedIndirectCountAMD$handle() {
        return vkCmdDrawIndexedIndirectCountAMD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static MemorySegment vkCmdDrawIndexedIndirectCountAMD$address() {
        return vkCmdDrawIndexedIndirectCountAMD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
     * }
     */
    public static void vkCmdDrawIndexedIndirectCountAMD(MemorySegment commandBuffer, MemorySegment buffer, long offset, MemorySegment countBuffer, long countBufferOffset, int maxDrawCount, int stride) {
        var mh$ = vkCmdDrawIndexedIndirectCountAMD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdDrawIndexedIndirectCountAMD", commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
            }
            mh$.invokeExact(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_SHADER_INFO_TYPE_STATISTICS_AMD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0
     * }
     */
    public static int VK_SHADER_INFO_TYPE_STATISTICS_AMD() {
        return VK_SHADER_INFO_TYPE_STATISTICS_AMD;
    }
    private static final int VK_SHADER_INFO_TYPE_BINARY_AMD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_BINARY_AMD = 1
     * }
     */
    public static int VK_SHADER_INFO_TYPE_BINARY_AMD() {
        return VK_SHADER_INFO_TYPE_BINARY_AMD;
    }
    private static final int VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2
     * }
     */
    public static int VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD() {
        return VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD;
    }
    private static final int VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD = 0
     * }
     */
    public static int VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD() {
        return VK_SHADER_INFO_TYPE_BEGIN_RANGE_AMD;
    }
    private static final int VK_SHADER_INFO_TYPE_END_RANGE_AMD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_END_RANGE_AMD = 2
     * }
     */
    public static int VK_SHADER_INFO_TYPE_END_RANGE_AMD() {
        return VK_SHADER_INFO_TYPE_END_RANGE_AMD;
    }
    private static final int VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD = 3
     * }
     */
    public static int VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD() {
        return VK_SHADER_INFO_TYPE_RANGE_SIZE_AMD;
    }
    private static final int VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkShaderInfoTypeAMD.VK_SHADER_INFO_TYPE_MAX_ENUM_AMD = 2147483647
     * }
     */
    public static int VK_SHADER_INFO_TYPE_MAX_ENUM_AMD() {
        return VK_SHADER_INFO_TYPE_MAX_ENUM_AMD;
    }

    private static class vkGetShaderInfoAMD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetShaderInfoAMD");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo)
     * }
     */
    public static FunctionDescriptor vkGetShaderInfoAMD$descriptor() {
        return vkGetShaderInfoAMD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo)
     * }
     */
    public static MethodHandle vkGetShaderInfoAMD$handle() {
        return vkGetShaderInfoAMD.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo)
     * }
     */
    public static MemorySegment vkGetShaderInfoAMD$address() {
        return vkGetShaderInfoAMD.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo)
     * }
     */
    public static int vkGetShaderInfoAMD(MemorySegment device, MemorySegment pipeline, int shaderStage, int infoType, MemorySegment pInfoSize, MemorySegment pInfo) {
        var mh$ = vkGetShaderInfoAMD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetShaderInfoAMD", device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
            }
            return (int)mh$.invokeExact(device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBitsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 1
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBitsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 2
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBitsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 4
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBitsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 8
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV;
    }
    private static final int VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryHandleTypeFlagBitsNV.VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkExternalMemoryHandleTypeFlagsNV
     * }
     */
    public static final OfInt VkExternalMemoryHandleTypeFlagsNV = vulkan_h.C_INT;
    private static final int VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBitsNV.VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 1
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV() {
        return VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV;
    }
    private static final int VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBitsNV.VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 2
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV() {
        return VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV;
    }
    private static final int VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBitsNV.VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 4
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV() {
        return VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV;
    }
    private static final int VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkExternalMemoryFeatureFlagBitsNV.VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV() {
        return VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkExternalMemoryFeatureFlagsNV
     * }
     */
    public static final OfInt VkExternalMemoryFeatureFlagsNV = vulkan_h.C_INT;

    private static class vkGetPhysicalDeviceExternalImageFormatPropertiesNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceExternalImageFormatPropertiesNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceExternalImageFormatPropertiesNV$descriptor() {
        return vkGetPhysicalDeviceExternalImageFormatPropertiesNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceExternalImageFormatPropertiesNV$handle() {
        return vkGetPhysicalDeviceExternalImageFormatPropertiesNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceExternalImageFormatPropertiesNV$address() {
        return vkGetPhysicalDeviceExternalImageFormatPropertiesNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties)
     * }
     */
    public static int vkGetPhysicalDeviceExternalImageFormatPropertiesNV(MemorySegment physicalDevice, int format, int type, int tiling, int usage, int flags, int externalHandleType, MemorySegment pExternalImageFormatProperties) {
        var mh$ = vkGetPhysicalDeviceExternalImageFormatPropertiesNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceExternalImageFormatPropertiesNV", physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
            }
            return (int)mh$.invokeExact(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_VALIDATION_CHECK_ALL_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkValidationCheckEXT.VK_VALIDATION_CHECK_ALL_EXT = 0
     * }
     */
    public static int VK_VALIDATION_CHECK_ALL_EXT() {
        return VK_VALIDATION_CHECK_ALL_EXT;
    }
    private static final int VK_VALIDATION_CHECK_SHADERS_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkValidationCheckEXT.VK_VALIDATION_CHECK_SHADERS_EXT = 1
     * }
     */
    public static int VK_VALIDATION_CHECK_SHADERS_EXT() {
        return VK_VALIDATION_CHECK_SHADERS_EXT;
    }
    private static final int VK_VALIDATION_CHECK_BEGIN_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkValidationCheckEXT.VK_VALIDATION_CHECK_BEGIN_RANGE_EXT = 0
     * }
     */
    public static int VK_VALIDATION_CHECK_BEGIN_RANGE_EXT() {
        return VK_VALIDATION_CHECK_BEGIN_RANGE_EXT;
    }
    private static final int VK_VALIDATION_CHECK_END_RANGE_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkValidationCheckEXT.VK_VALIDATION_CHECK_END_RANGE_EXT = 1
     * }
     */
    public static int VK_VALIDATION_CHECK_END_RANGE_EXT() {
        return VK_VALIDATION_CHECK_END_RANGE_EXT;
    }
    private static final int VK_VALIDATION_CHECK_RANGE_SIZE_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkValidationCheckEXT.VK_VALIDATION_CHECK_RANGE_SIZE_EXT = 2
     * }
     */
    public static int VK_VALIDATION_CHECK_RANGE_SIZE_EXT() {
        return VK_VALIDATION_CHECK_RANGE_SIZE_EXT;
    }
    private static final int VK_VALIDATION_CHECK_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkValidationCheckEXT.VK_VALIDATION_CHECK_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_VALIDATION_CHECK_MAX_ENUM_EXT() {
        return VK_VALIDATION_CHECK_MAX_ENUM_EXT;
    }
    private static final int VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkConditionalRenderingFlagBitsEXT.VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 1
     * }
     */
    public static int VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT() {
        return VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT;
    }
    private static final int VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkConditionalRenderingFlagBitsEXT.VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_CONDITIONAL_RENDERING_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkConditionalRenderingFlagsEXT
     * }
     */
    public static final OfInt VkConditionalRenderingFlagsEXT = vulkan_h.C_INT;

    private static class vkCmdBeginConditionalRenderingEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdBeginConditionalRenderingEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin)
     * }
     */
    public static FunctionDescriptor vkCmdBeginConditionalRenderingEXT$descriptor() {
        return vkCmdBeginConditionalRenderingEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin)
     * }
     */
    public static MethodHandle vkCmdBeginConditionalRenderingEXT$handle() {
        return vkCmdBeginConditionalRenderingEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin)
     * }
     */
    public static MemorySegment vkCmdBeginConditionalRenderingEXT$address() {
        return vkCmdBeginConditionalRenderingEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin)
     * }
     */
    public static void vkCmdBeginConditionalRenderingEXT(MemorySegment commandBuffer, MemorySegment pConditionalRenderingBegin) {
        var mh$ = vkCmdBeginConditionalRenderingEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdBeginConditionalRenderingEXT", commandBuffer, pConditionalRenderingBegin);
            }
            mh$.invokeExact(commandBuffer, pConditionalRenderingBegin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdEndConditionalRenderingEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdEndConditionalRenderingEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer)
     * }
     */
    public static FunctionDescriptor vkCmdEndConditionalRenderingEXT$descriptor() {
        return vkCmdEndConditionalRenderingEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer)
     * }
     */
    public static MethodHandle vkCmdEndConditionalRenderingEXT$handle() {
        return vkCmdEndConditionalRenderingEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer)
     * }
     */
    public static MemorySegment vkCmdEndConditionalRenderingEXT$address() {
        return vkCmdEndConditionalRenderingEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer)
     * }
     */
    public static void vkCmdEndConditionalRenderingEXT(MemorySegment commandBuffer) {
        var mh$ = vkCmdEndConditionalRenderingEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdEndConditionalRenderingEXT", commandBuffer);
            }
            mh$.invokeExact(commandBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct VkObjectTableNVX_T *VkObjectTableNVX
     * }
     */
    public static final AddressLayout VkObjectTableNVX = vulkan_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct VkIndirectCommandsLayoutNVX_T *VkIndirectCommandsLayoutNVX
     * }
     */
    public static final AddressLayout VkIndirectCommandsLayoutNVX = vulkan_h.C_POINTER;
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX = 0
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX = 1
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX = 2
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX = 3
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX = 4
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX = 5
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX = 6
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX = 7
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX = 0
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX = 7
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX = 8
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsTokenTypeNVX.VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX = 2147483647
     * }
     */
    public static int VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX() {
        return VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX;
    }
    private static final int VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX = 0
     * }
     */
    public static int VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX() {
        return VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX;
    }
    private static final int VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX = 1
     * }
     */
    public static int VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX() {
        return VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX;
    }
    private static final int VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX = 2
     * }
     */
    public static int VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX() {
        return VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX;
    }
    private static final int VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX = 3
     * }
     */
    public static int VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX() {
        return VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX;
    }
    private static final int VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX = 4
     * }
     */
    public static int VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX() {
        return VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX;
    }
    private static final int VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX = 0
     * }
     */
    public static int VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX() {
        return VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX;
    }
    private static final int VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX = 4
     * }
     */
    public static int VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX() {
        return VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX;
    }
    private static final int VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX = 5
     * }
     */
    public static int VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX() {
        return VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX;
    }
    private static final int VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryTypeNVX.VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX = 2147483647
     * }
     */
    public static int VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX() {
        return VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsLayoutUsageFlagBitsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = 1
     * }
     */
    public static int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX() {
        return VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsLayoutUsageFlagBitsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = 2
     * }
     */
    public static int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX() {
        return VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsLayoutUsageFlagBitsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = 4
     * }
     */
    public static int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX() {
        return VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsLayoutUsageFlagBitsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = 8
     * }
     */
    public static int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX() {
        return VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX;
    }
    private static final int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkIndirectCommandsLayoutUsageFlagBitsNVX.VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX = 2147483647
     * }
     */
    public static int VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX() {
        return VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkIndirectCommandsLayoutUsageFlagsNVX
     * }
     */
    public static final OfInt VkIndirectCommandsLayoutUsageFlagsNVX = vulkan_h.C_INT;
    private static final int VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryUsageFlagBitsNVX.VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = 1
     * }
     */
    public static int VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX() {
        return VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX;
    }
    private static final int VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryUsageFlagBitsNVX.VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = 2
     * }
     */
    public static int VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX() {
        return VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX;
    }
    private static final int VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkObjectEntryUsageFlagBitsNVX.VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX = 2147483647
     * }
     */
    public static int VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX() {
        return VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkObjectEntryUsageFlagsNVX
     * }
     */
    public static final OfInt VkObjectEntryUsageFlagsNVX = vulkan_h.C_INT;

    private static class vkCmdProcessCommandsNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdProcessCommandsNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdProcessCommandsNVX(VkCommandBuffer commandBuffer, const VkCmdProcessCommandsInfoNVX *pProcessCommandsInfo)
     * }
     */
    public static FunctionDescriptor vkCmdProcessCommandsNVX$descriptor() {
        return vkCmdProcessCommandsNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdProcessCommandsNVX(VkCommandBuffer commandBuffer, const VkCmdProcessCommandsInfoNVX *pProcessCommandsInfo)
     * }
     */
    public static MethodHandle vkCmdProcessCommandsNVX$handle() {
        return vkCmdProcessCommandsNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdProcessCommandsNVX(VkCommandBuffer commandBuffer, const VkCmdProcessCommandsInfoNVX *pProcessCommandsInfo)
     * }
     */
    public static MemorySegment vkCmdProcessCommandsNVX$address() {
        return vkCmdProcessCommandsNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdProcessCommandsNVX(VkCommandBuffer commandBuffer, const VkCmdProcessCommandsInfoNVX *pProcessCommandsInfo)
     * }
     */
    public static void vkCmdProcessCommandsNVX(MemorySegment commandBuffer, MemorySegment pProcessCommandsInfo) {
        var mh$ = vkCmdProcessCommandsNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdProcessCommandsNVX", commandBuffer, pProcessCommandsInfo);
            }
            mh$.invokeExact(commandBuffer, pProcessCommandsInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdReserveSpaceForCommandsNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdReserveSpaceForCommandsNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdReserveSpaceForCommandsNVX(VkCommandBuffer commandBuffer, const VkCmdReserveSpaceForCommandsInfoNVX *pReserveSpaceInfo)
     * }
     */
    public static FunctionDescriptor vkCmdReserveSpaceForCommandsNVX$descriptor() {
        return vkCmdReserveSpaceForCommandsNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdReserveSpaceForCommandsNVX(VkCommandBuffer commandBuffer, const VkCmdReserveSpaceForCommandsInfoNVX *pReserveSpaceInfo)
     * }
     */
    public static MethodHandle vkCmdReserveSpaceForCommandsNVX$handle() {
        return vkCmdReserveSpaceForCommandsNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdReserveSpaceForCommandsNVX(VkCommandBuffer commandBuffer, const VkCmdReserveSpaceForCommandsInfoNVX *pReserveSpaceInfo)
     * }
     */
    public static MemorySegment vkCmdReserveSpaceForCommandsNVX$address() {
        return vkCmdReserveSpaceForCommandsNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdReserveSpaceForCommandsNVX(VkCommandBuffer commandBuffer, const VkCmdReserveSpaceForCommandsInfoNVX *pReserveSpaceInfo)
     * }
     */
    public static void vkCmdReserveSpaceForCommandsNVX(MemorySegment commandBuffer, MemorySegment pReserveSpaceInfo) {
        var mh$ = vkCmdReserveSpaceForCommandsNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdReserveSpaceForCommandsNVX", commandBuffer, pReserveSpaceInfo);
            }
            mh$.invokeExact(commandBuffer, pReserveSpaceInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateIndirectCommandsLayoutNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateIndirectCommandsLayoutNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateIndirectCommandsLayoutNVX(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNVX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNVX *pIndirectCommandsLayout)
     * }
     */
    public static FunctionDescriptor vkCreateIndirectCommandsLayoutNVX$descriptor() {
        return vkCreateIndirectCommandsLayoutNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateIndirectCommandsLayoutNVX(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNVX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNVX *pIndirectCommandsLayout)
     * }
     */
    public static MethodHandle vkCreateIndirectCommandsLayoutNVX$handle() {
        return vkCreateIndirectCommandsLayoutNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateIndirectCommandsLayoutNVX(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNVX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNVX *pIndirectCommandsLayout)
     * }
     */
    public static MemorySegment vkCreateIndirectCommandsLayoutNVX$address() {
        return vkCreateIndirectCommandsLayoutNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateIndirectCommandsLayoutNVX(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNVX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNVX *pIndirectCommandsLayout)
     * }
     */
    public static int vkCreateIndirectCommandsLayoutNVX(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pIndirectCommandsLayout) {
        var mh$ = vkCreateIndirectCommandsLayoutNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateIndirectCommandsLayoutNVX", device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyIndirectCommandsLayoutNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyIndirectCommandsLayoutNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyIndirectCommandsLayoutNVX(VkDevice device, VkIndirectCommandsLayoutNVX indirectCommandsLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyIndirectCommandsLayoutNVX$descriptor() {
        return vkDestroyIndirectCommandsLayoutNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyIndirectCommandsLayoutNVX(VkDevice device, VkIndirectCommandsLayoutNVX indirectCommandsLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyIndirectCommandsLayoutNVX$handle() {
        return vkDestroyIndirectCommandsLayoutNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyIndirectCommandsLayoutNVX(VkDevice device, VkIndirectCommandsLayoutNVX indirectCommandsLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyIndirectCommandsLayoutNVX$address() {
        return vkDestroyIndirectCommandsLayoutNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyIndirectCommandsLayoutNVX(VkDevice device, VkIndirectCommandsLayoutNVX indirectCommandsLayout, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyIndirectCommandsLayoutNVX(MemorySegment device, MemorySegment indirectCommandsLayout, MemorySegment pAllocator) {
        var mh$ = vkDestroyIndirectCommandsLayoutNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyIndirectCommandsLayoutNVX", device, indirectCommandsLayout, pAllocator);
            }
            mh$.invokeExact(device, indirectCommandsLayout, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCreateObjectTableNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCreateObjectTableNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkCreateObjectTableNVX(VkDevice device, const VkObjectTableCreateInfoNVX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkObjectTableNVX *pObjectTable)
     * }
     */
    public static FunctionDescriptor vkCreateObjectTableNVX$descriptor() {
        return vkCreateObjectTableNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkCreateObjectTableNVX(VkDevice device, const VkObjectTableCreateInfoNVX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkObjectTableNVX *pObjectTable)
     * }
     */
    public static MethodHandle vkCreateObjectTableNVX$handle() {
        return vkCreateObjectTableNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkCreateObjectTableNVX(VkDevice device, const VkObjectTableCreateInfoNVX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkObjectTableNVX *pObjectTable)
     * }
     */
    public static MemorySegment vkCreateObjectTableNVX$address() {
        return vkCreateObjectTableNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkCreateObjectTableNVX(VkDevice device, const VkObjectTableCreateInfoNVX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkObjectTableNVX *pObjectTable)
     * }
     */
    public static int vkCreateObjectTableNVX(MemorySegment device, MemorySegment pCreateInfo, MemorySegment pAllocator, MemorySegment pObjectTable) {
        var mh$ = vkCreateObjectTableNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCreateObjectTableNVX", device, pCreateInfo, pAllocator, pObjectTable);
            }
            return (int)mh$.invokeExact(device, pCreateInfo, pAllocator, pObjectTable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkDestroyObjectTableNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDestroyObjectTableNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkDestroyObjectTableNVX(VkDevice device, VkObjectTableNVX objectTable, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static FunctionDescriptor vkDestroyObjectTableNVX$descriptor() {
        return vkDestroyObjectTableNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkDestroyObjectTableNVX(VkDevice device, VkObjectTableNVX objectTable, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MethodHandle vkDestroyObjectTableNVX$handle() {
        return vkDestroyObjectTableNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkDestroyObjectTableNVX(VkDevice device, VkObjectTableNVX objectTable, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static MemorySegment vkDestroyObjectTableNVX$address() {
        return vkDestroyObjectTableNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkDestroyObjectTableNVX(VkDevice device, VkObjectTableNVX objectTable, const VkAllocationCallbacks *pAllocator)
     * }
     */
    public static void vkDestroyObjectTableNVX(MemorySegment device, MemorySegment objectTable, MemorySegment pAllocator) {
        var mh$ = vkDestroyObjectTableNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDestroyObjectTableNVX", device, objectTable, pAllocator);
            }
            mh$.invokeExact(device, objectTable, pAllocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkRegisterObjectsNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkRegisterObjectsNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkRegisterObjectsNVX(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectTableEntryNVX *const *ppObjectTableEntries, const uint32_t *pObjectIndices)
     * }
     */
    public static FunctionDescriptor vkRegisterObjectsNVX$descriptor() {
        return vkRegisterObjectsNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkRegisterObjectsNVX(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectTableEntryNVX *const *ppObjectTableEntries, const uint32_t *pObjectIndices)
     * }
     */
    public static MethodHandle vkRegisterObjectsNVX$handle() {
        return vkRegisterObjectsNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkRegisterObjectsNVX(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectTableEntryNVX *const *ppObjectTableEntries, const uint32_t *pObjectIndices)
     * }
     */
    public static MemorySegment vkRegisterObjectsNVX$address() {
        return vkRegisterObjectsNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkRegisterObjectsNVX(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectTableEntryNVX *const *ppObjectTableEntries, const uint32_t *pObjectIndices)
     * }
     */
    public static int vkRegisterObjectsNVX(MemorySegment device, MemorySegment objectTable, int objectCount, MemorySegment ppObjectTableEntries, MemorySegment pObjectIndices) {
        var mh$ = vkRegisterObjectsNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkRegisterObjectsNVX", device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
            }
            return (int)mh$.invokeExact(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkUnregisterObjectsNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkUnregisterObjectsNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkUnregisterObjectsNVX(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectEntryTypeNVX *pObjectEntryTypes, const uint32_t *pObjectIndices)
     * }
     */
    public static FunctionDescriptor vkUnregisterObjectsNVX$descriptor() {
        return vkUnregisterObjectsNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkUnregisterObjectsNVX(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectEntryTypeNVX *pObjectEntryTypes, const uint32_t *pObjectIndices)
     * }
     */
    public static MethodHandle vkUnregisterObjectsNVX$handle() {
        return vkUnregisterObjectsNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkUnregisterObjectsNVX(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectEntryTypeNVX *pObjectEntryTypes, const uint32_t *pObjectIndices)
     * }
     */
    public static MemorySegment vkUnregisterObjectsNVX$address() {
        return vkUnregisterObjectsNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkUnregisterObjectsNVX(VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectEntryTypeNVX *pObjectEntryTypes, const uint32_t *pObjectIndices)
     * }
     */
    public static int vkUnregisterObjectsNVX(MemorySegment device, MemorySegment objectTable, int objectCount, MemorySegment pObjectEntryTypes, MemorySegment pObjectIndices) {
        var mh$ = vkUnregisterObjectsNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkUnregisterObjectsNVX", device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
            }
            return (int)mh$.invokeExact(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(VkPhysicalDevice physicalDevice, VkDeviceGeneratedCommandsFeaturesNVX *pFeatures, VkDeviceGeneratedCommandsLimitsNVX *pLimits)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX$descriptor() {
        return vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(VkPhysicalDevice physicalDevice, VkDeviceGeneratedCommandsFeaturesNVX *pFeatures, VkDeviceGeneratedCommandsLimitsNVX *pLimits)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX$handle() {
        return vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(VkPhysicalDevice physicalDevice, VkDeviceGeneratedCommandsFeaturesNVX *pFeatures, VkDeviceGeneratedCommandsLimitsNVX *pLimits)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX$address() {
        return vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(VkPhysicalDevice physicalDevice, VkDeviceGeneratedCommandsFeaturesNVX *pFeatures, VkDeviceGeneratedCommandsLimitsNVX *pLimits)
     * }
     */
    public static void vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(MemorySegment physicalDevice, MemorySegment pFeatures, MemorySegment pLimits) {
        var mh$ = vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX", physicalDevice, pFeatures, pLimits);
            }
            mh$.invokeExact(physicalDevice, pFeatures, pLimits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkCmdSetViewportWScalingNV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkCmdSetViewportWScalingNV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void vkCmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings)
     * }
     */
    public static FunctionDescriptor vkCmdSetViewportWScalingNV$descriptor() {
        return vkCmdSetViewportWScalingNV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void vkCmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings)
     * }
     */
    public static MethodHandle vkCmdSetViewportWScalingNV$handle() {
        return vkCmdSetViewportWScalingNV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void vkCmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings)
     * }
     */
    public static MemorySegment vkCmdSetViewportWScalingNV$address() {
        return vkCmdSetViewportWScalingNV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void vkCmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings)
     * }
     */
    public static void vkCmdSetViewportWScalingNV(MemorySegment commandBuffer, int firstViewport, int viewportCount, MemorySegment pViewportWScalings) {
        var mh$ = vkCmdSetViewportWScalingNV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkCmdSetViewportWScalingNV", commandBuffer, firstViewport, viewportCount, pViewportWScalings);
            }
            mh$.invokeExact(commandBuffer, firstViewport, viewportCount, pViewportWScalings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkReleaseDisplayEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkReleaseDisplayEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display)
     * }
     */
    public static FunctionDescriptor vkReleaseDisplayEXT$descriptor() {
        return vkReleaseDisplayEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display)
     * }
     */
    public static MethodHandle vkReleaseDisplayEXT$handle() {
        return vkReleaseDisplayEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display)
     * }
     */
    public static MemorySegment vkReleaseDisplayEXT$address() {
        return vkReleaseDisplayEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display)
     * }
     */
    public static int vkReleaseDisplayEXT(MemorySegment physicalDevice, MemorySegment display) {
        var mh$ = vkReleaseDisplayEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkReleaseDisplayEXT", physicalDevice, display);
            }
            return (int)mh$.invokeExact(physicalDevice, display);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_SURFACE_COUNTER_VBLANK_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceCounterFlagBitsEXT.VK_SURFACE_COUNTER_VBLANK_EXT = 1
     * }
     */
    public static int VK_SURFACE_COUNTER_VBLANK_EXT() {
        return VK_SURFACE_COUNTER_VBLANK_EXT;
    }
    private static final int VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkSurfaceCounterFlagBitsEXT.VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT() {
        return VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkSurfaceCounterFlagsEXT
     * }
     */
    public static final OfInt VkSurfaceCounterFlagsEXT = vulkan_h.C_INT;

    private static class vkGetPhysicalDeviceSurfaceCapabilities2EXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPhysicalDeviceSurfaceCapabilities2EXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities)
     * }
     */
    public static FunctionDescriptor vkGetPhysicalDeviceSurfaceCapabilities2EXT$descriptor() {
        return vkGetPhysicalDeviceSurfaceCapabilities2EXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities)
     * }
     */
    public static MethodHandle vkGetPhysicalDeviceSurfaceCapabilities2EXT$handle() {
        return vkGetPhysicalDeviceSurfaceCapabilities2EXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities)
     * }
     */
    public static MemorySegment vkGetPhysicalDeviceSurfaceCapabilities2EXT$address() {
        return vkGetPhysicalDeviceSurfaceCapabilities2EXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities)
     * }
     */
    public static int vkGetPhysicalDeviceSurfaceCapabilities2EXT(MemorySegment physicalDevice, MemorySegment surface, MemorySegment pSurfaceCapabilities) {
        var mh$ = vkGetPhysicalDeviceSurfaceCapabilities2EXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPhysicalDeviceSurfaceCapabilities2EXT", physicalDevice, surface, pSurfaceCapabilities);
            }
            return (int)mh$.invokeExact(physicalDevice, surface, pSurfaceCapabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_DISPLAY_POWER_STATE_OFF_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_OFF_EXT = 0
     * }
     */
    public static int VK_DISPLAY_POWER_STATE_OFF_EXT() {
        return VK_DISPLAY_POWER_STATE_OFF_EXT;
    }
    private static final int VK_DISPLAY_POWER_STATE_SUSPEND_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1
     * }
     */
    public static int VK_DISPLAY_POWER_STATE_SUSPEND_EXT() {
        return VK_DISPLAY_POWER_STATE_SUSPEND_EXT;
    }
    private static final int VK_DISPLAY_POWER_STATE_ON_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_ON_EXT = 2
     * }
     */
    public static int VK_DISPLAY_POWER_STATE_ON_EXT() {
        return VK_DISPLAY_POWER_STATE_ON_EXT;
    }
    private static final int VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT = 0
     * }
     */
    public static int VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT() {
        return VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT;
    }
    private static final int VK_DISPLAY_POWER_STATE_END_RANGE_EXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_END_RANGE_EXT = 2
     * }
     */
    public static int VK_DISPLAY_POWER_STATE_END_RANGE_EXT() {
        return VK_DISPLAY_POWER_STATE_END_RANGE_EXT;
    }
    private static final int VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT = 3
     * }
     */
    public static int VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT() {
        return VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT;
    }
    private static final int VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayPowerStateEXT.VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT() {
        return VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT;
    }
    private static final int VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceEventTypeEXT.VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0
     * }
     */
    public static int VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT() {
        return VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
    }
    private static final int VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceEventTypeEXT.VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT = 0
     * }
     */
    public static int VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT() {
        return VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT;
    }
    private static final int VK_DEVICE_EVENT_TYPE_END_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceEventTypeEXT.VK_DEVICE_EVENT_TYPE_END_RANGE_EXT = 0
     * }
     */
    public static int VK_DEVICE_EVENT_TYPE_END_RANGE_EXT() {
        return VK_DEVICE_EVENT_TYPE_END_RANGE_EXT;
    }
    private static final int VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceEventTypeEXT.VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT = 1
     * }
     */
    public static int VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT() {
        return VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT;
    }
    private static final int VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDeviceEventTypeEXT.VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT() {
        return VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT;
    }
    private static final int VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayEventTypeEXT.VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0
     * }
     */
    public static int VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT() {
        return VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
    }
    private static final int VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayEventTypeEXT.VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT = 0
     * }
     */
    public static int VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT() {
        return VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT;
    }
    private static final int VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayEventTypeEXT.VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT = 0
     * }
     */
    public static int VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT() {
        return VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT;
    }
    private static final int VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayEventTypeEXT.VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT = 1
     * }
     */
    public static int VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT() {
        return VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT;
    }
    private static final int VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkDisplayEventTypeEXT.VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 2147483647
     * }
     */
    public static int VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT() {
        return VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT;
    }

    private static class vkDisplayPowerControlEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkDisplayPowerControlEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkDisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo)
     * }
     */
    public static FunctionDescriptor vkDisplayPowerControlEXT$descriptor() {
        return vkDisplayPowerControlEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkDisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo)
     * }
     */
    public static MethodHandle vkDisplayPowerControlEXT$handle() {
        return vkDisplayPowerControlEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkDisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo)
     * }
     */
    public static MemorySegment vkDisplayPowerControlEXT$address() {
        return vkDisplayPowerControlEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkDisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo)
     * }
     */
    public static int vkDisplayPowerControlEXT(MemorySegment device, MemorySegment display, MemorySegment pDisplayPowerInfo) {
        var mh$ = vkDisplayPowerControlEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkDisplayPowerControlEXT", device, display, pDisplayPowerInfo);
            }
            return (int)mh$.invokeExact(device, display, pDisplayPowerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkRegisterDeviceEventEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkRegisterDeviceEventEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkRegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static FunctionDescriptor vkRegisterDeviceEventEXT$descriptor() {
        return vkRegisterDeviceEventEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkRegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static MethodHandle vkRegisterDeviceEventEXT$handle() {
        return vkRegisterDeviceEventEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkRegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static MemorySegment vkRegisterDeviceEventEXT$address() {
        return vkRegisterDeviceEventEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkRegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static int vkRegisterDeviceEventEXT(MemorySegment device, MemorySegment pDeviceEventInfo, MemorySegment pAllocator, MemorySegment pFence) {
        var mh$ = vkRegisterDeviceEventEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkRegisterDeviceEventEXT", device, pDeviceEventInfo, pAllocator, pFence);
            }
            return (int)mh$.invokeExact(device, pDeviceEventInfo, pAllocator, pFence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkRegisterDisplayEventEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkRegisterDisplayEventEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkRegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static FunctionDescriptor vkRegisterDisplayEventEXT$descriptor() {
        return vkRegisterDisplayEventEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkRegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static MethodHandle vkRegisterDisplayEventEXT$handle() {
        return vkRegisterDisplayEventEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkRegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static MemorySegment vkRegisterDisplayEventEXT$address() {
        return vkRegisterDisplayEventEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkRegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence)
     * }
     */
    public static int vkRegisterDisplayEventEXT(MemorySegment device, MemorySegment display, MemorySegment pDisplayEventInfo, MemorySegment pAllocator, MemorySegment pFence) {
        var mh$ = vkRegisterDisplayEventEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkRegisterDisplayEventEXT", device, display, pDisplayEventInfo, pAllocator, pFence);
            }
            return (int)mh$.invokeExact(device, display, pDisplayEventInfo, pAllocator, pFence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetSwapchainCounterEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_INT,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetSwapchainCounterEXT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue)
     * }
     */
    public static FunctionDescriptor vkGetSwapchainCounterEXT$descriptor() {
        return vkGetSwapchainCounterEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue)
     * }
     */
    public static MethodHandle vkGetSwapchainCounterEXT$handle() {
        return vkGetSwapchainCounterEXT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue)
     * }
     */
    public static MemorySegment vkGetSwapchainCounterEXT$address() {
        return vkGetSwapchainCounterEXT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue)
     * }
     */
    public static int vkGetSwapchainCounterEXT(MemorySegment device, MemorySegment swapchain, int counter, MemorySegment pCounterValue) {
        var mh$ = vkGetSwapchainCounterEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetSwapchainCounterEXT", device, swapchain, counter, pCounterValue);
            }
            return (int)mh$.invokeExact(device, swapchain, counter, pCounterValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetRefreshCycleDurationGOOGLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetRefreshCycleDurationGOOGLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties)
     * }
     */
    public static FunctionDescriptor vkGetRefreshCycleDurationGOOGLE$descriptor() {
        return vkGetRefreshCycleDurationGOOGLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties)
     * }
     */
    public static MethodHandle vkGetRefreshCycleDurationGOOGLE$handle() {
        return vkGetRefreshCycleDurationGOOGLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties)
     * }
     */
    public static MemorySegment vkGetRefreshCycleDurationGOOGLE$address() {
        return vkGetRefreshCycleDurationGOOGLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties)
     * }
     */
    public static int vkGetRefreshCycleDurationGOOGLE(MemorySegment device, MemorySegment swapchain, MemorySegment pDisplayTimingProperties) {
        var mh$ = vkGetRefreshCycleDurationGOOGLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetRefreshCycleDurationGOOGLE", device, swapchain, pDisplayTimingProperties);
            }
            return (int)mh$.invokeExact(device, swapchain, pDisplayTimingProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vkGetPastPresentationTimingGOOGLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            vulkan_h.C_INT,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER,
            vulkan_h.C_POINTER
        );

        public static final MemorySegment ADDR = vulkan_h.findOrThrow("vkGetPastPresentationTimingGOOGLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * VkResult vkGetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings)
     * }
     */
    public static FunctionDescriptor vkGetPastPresentationTimingGOOGLE$descriptor() {
        return vkGetPastPresentationTimingGOOGLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * VkResult vkGetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings)
     * }
     */
    public static MethodHandle vkGetPastPresentationTimingGOOGLE$handle() {
        return vkGetPastPresentationTimingGOOGLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * VkResult vkGetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings)
     * }
     */
    public static MemorySegment vkGetPastPresentationTimingGOOGLE$address() {
        return vkGetPastPresentationTimingGOOGLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * VkResult vkGetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings)
     * }
     */
    public static int vkGetPastPresentationTimingGOOGLE(MemorySegment device, MemorySegment swapchain, MemorySegment pPresentationTimingCount, MemorySegment pPresentationTimings) {
        var mh$ = vkGetPastPresentationTimingGOOGLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vkGetPastPresentationTimingGOOGLE", device, swapchain, pPresentationTimingCount, pPresentationTimings);
            }
            return (int)mh$.invokeExact(device, swapchain, pPresentationTimingCount, pPresentationTimings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV = 0
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV = 7
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV = 8
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV;
    }
    private static final int VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * enum VkViewportCoordinateSwizzleNV.VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 2147483647
     * }
     */
    public static int VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV() {
        return VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV;
    }
    /**
     * {@snippet lang=c :
     * typedef VkFlags VkPipelineViewportSwizzleStateCreateFlagsNV
     * }
     */
    public static final OfInt VkPipelineViewportSwizzleStateCreateFlagsNV = vulkan_h.C_INT;
    private static final int VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VkDiscardRectangleModeEXT.VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0
     * }
     */
    public static int VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT() {
        return VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT;
    }
}

